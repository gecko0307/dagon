/*
Copyright (c) 2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Messaging module.
 *
 * Description:
 * The `dagon.core.messaging` provides wait-free, single-producer single-consumer (SPSC)
 * event queues, messaging endpoints, threaded services, workers, and a message broker
 * for inter-thread communication and bidirectional messaging.
 *
 * Copyright: Timur Gafarov 2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.core.messaging;

import core.atomic;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.core.thread;
import dlib.container.array;

import dagon.core.event;
import dagon.core.logger;

/**
 * Generic, wait-free single-producer single-consumer queue.
 *
 * Params:
 *   T = element type.
 *   capacity = Maximum number of elements in the queue.
 *
 * Members:
 *   buffer = Circular buffer.
 *   head = Producer write index.
 *   tail = Consumer read index.
 *
 * Methods:
 *   push = Add an element to the queue. Returns false if full.
 *   pop = Remove an element from the queue. Returns false if empty.
 */
struct SPSCQueue(T, size_t capacity)
{
    /// Circular buffer.
    T[capacity] buffer;

    shared size_t head = 0; // producer writes here
    shared size_t tail = 0; // consumer reads here

    /// Add an element to the queue. Returns false if full.
    bool push(T value)
    {
        auto next = (head + 1) % capacity;
        if (next == tail) // queue full
            return false;

        buffer[head] = value;
        atomicStore!(MemoryOrder.rel)(head, next);
        return true;
    }

    /// Remove an element from the queue. Returns false if empty.
    bool pop(out T value)
    {
        if (tail == atomicLoad!(MemoryOrder.acq)(head))
            return false; // empty

        value = buffer[tail];
        tail = (tail + 1) % capacity;
        return true;
    }
}

/**
 * Base class for senders/receivers with a lock-free inbox/outbox messaging.
 */
abstract class Endpoint: EventDispatcher
{
    /// Reference to a message broker
    MessageBroker broker;
    
    /// Incoming event queue.
    SPSCQueue!(Event, 50) inbox;

    /// Outgoing event queue.
    SPSCQueue!(Event, 50) outbox;

    /// Receiver enabled flag.
    bool enabled = true;
    
    this(string address, MessageBroker broker, Owner owner)
    {
        super(owner);
        this.broker = broker;
        this.domain = MessageDomain.ITC;
        this.address = address;
        broker.add(this);
    }
    
    this(string address, MessageBroker broker)
    {
        this(address, broker, broker);
    }
    
    protected:
    
    bool queue(Event e)
    {
        return outbox.push(e);
    }

    /// Send a message to a recipient.
    bool queueMessage(string recipient, string message, void* payload = null, int domain = MessageDomain.ITC)
    {
        return outbox.push(messageEvent(address, recipient, message, payload, domain));
    }
    
    alias send = queueMessage;

    /// Initiate a main thread task.
    bool queueTask(string recipient, scope TaskCallback callback, void* payload = null, int domain = MessageDomain.MainThread)
    {
        return outbox.push(taskEvent(address, recipient, callback, payload, domain));
    }
    
    /// Thread-safe log
    void queueLog(LogLevel level, string message)
    {
        Event e = Event(EventType.Log);
        e.logLevel = level;
        e.message = message;
        queue(e);
    }

    public:
    
    /// Process all events in the inbox.
    void processEvents()
    {
        if (!enabled)
            return;
        
        Event event;
        while(inbox.pop(event))
        {
            processEvent(&event);
        }
    }
}

/**
 * An endpoint that runs in its own thread to process events asynchronously.
 */
class Service: Endpoint
{
    /// Internal thread.
    Thread thread;

    /// Thread running flag.
    shared bool running = false;
    
    this(string address, MessageBroker broker, Owner owner)
    {
        super(address, broker, owner);
        thread = New!Thread(&threadFunc);
    }
    
    ~this()
    {
        if (thread.isRunning)
            stop();
        Delete(thread);
    }
    
    /// Start the thread.
    void run()
    {
        if (!thread.isRunning)
        {
            atomicStore!(MemoryOrder.rel)(running, true);
            thread.start();
        }
    }
    
    /// Thread main loop.
    void threadFunc()
    {
        while(atomicLoad!(MemoryOrder.acq)(running))
        {
            processEvents();
            onUpdate();
        }
    }

    /// Called every update cycle.
    void onUpdate()
    {
        //
    }
    
    /// Stop the thread.
    void stop()
    {
        atomicStore!(MemoryOrder.rel)(running, false);
        thread.join();
    }
}

/**
 * A specialized threaded endpoint that executes tasks in the background.
 */
class Worker: Service
{
    this(string address, MessageBroker broker, Owner owner)
    {
        super(address, broker, owner);
    }
    
    override void onTask(int domain, string sender, TaskCallback callback, void* payload)
    {
        callback(null, payload);
    }
}

/**
 * Message broker for distributing messages and scheduling tasks.
 * Collects and routes events from EventManager and registered endpoints.
 */
class MessageBroker: Owner
{
    public:
    
    /// Broker enabled flag.
    bool enabled = false;

    protected:
    
    /// Associated event manager.
    EventManager eventManager;

    /// Temporary buffer for collected events.
    Event[1024] eventBuffer;

    /// List of registered endpoints.
    Array!Endpoint endpoints;

    /// List of registered workers.
    Array!Worker workers;

    /// Last worker index for round-robin scheduling
    size_t lastWorkerIndex = 0;

    public:

    this(EventManager eventManager)
    {
        super(eventManager);
        this.eventManager = eventManager;
    }

    ~this()
    {
        endpoints.free();
        workers.free();
    }

    /// Register a receiver.
    void add(Endpoint endpoint)
    {
        Worker worker = cast(Worker)endpoint;
        if (worker)
            workers.append(worker);
        else
            endpoints.append(endpoint);
    }
    
    bool canRunTasks()
    {
        return !enabled && workers.length == 0;
    }

    /// Collect and dispatch events/messages.
    void update()
    {
        if (!enabled)
            return;
        
        size_t numCollected = 0;
        
        // Collect events from the main event queue
        for (uint i = 0; i < eventManager.numEvents; i++)
        {
            Event event = eventManager.eventQueue[i];
            
            // Ignore any log events
            if (event.type == EventType.Log)
                continue;
            
            // Ignore main-thread messages
            if (event.type == EventType.Message && event.domain >= MessageDomain.MainThread)
                continue;
            
            // Ignore main-thread tasks
            if (event.type == EventType.Task && event.domain > MessageDomain.ITC)
                continue;

            if (numCollected < eventBuffer.length)
            {
                eventBuffer[numCollected] = eventManager.eventQueue[i];
                numCollected++;
                
                // Cancel the original message/task
                if (event.type == EventType.Message || event.type == EventType.Task)
                    eventManager.eventQueue[i].type = EventType.Cancelled;
            }
            else
            {
                // TODO
            }
        }

        // Collect endpoint outgoing events
        foreach(endpoint; endpoints)
        {
            Event event;
            if (endpoint.outbox.pop(event))
            {
                if (numCollected < eventBuffer.length)
                {
                    eventBuffer[numCollected] = event;
                    numCollected++;
                }
                else
                {
                    // TODO
                }
            }
        }

        // Dispatch collected events
        for (size_t i = 0; i < numCollected; i++)
        {
            Event event = eventBuffer[i];
            if (event.type == EventType.Log)
            {
                // Asynchronous log from an endpoint
                // (this is guaranteed, because we have previously filtered out
                // all logs from the main event queue)
                eventManager.queueEvent(event);
            }
            else if (event.type == EventType.Task)
            {
                if (event.domain <= MessageDomain.ITC)
                {
                    // ITC task, obtain a worker with round-robin method
                    size_t idx = lastWorkerIndex % workers.length;
                    workers[idx].inbox.push(event);
                    lastWorkerIndex++;
                }
                else
                {
                    // Main-thread task, forward to the synchronous bus
                    eventManager.addEvent(event);
                }
            }
            else if (event.type == EventType.Message)
            {
                if (event.domain < MessageDomain.MainThread)
                {
                    // ITC or circular message, route to an endpoint
                    foreach(endpoint; endpoints)
                    {
                        if (event.recipient.length == 0)
                        {
                            // Broadcast to all but the sender
                            if (event.sender != endpoint.address)
                                endpoint.inbox.push(event);
                        }
                        else if (event.recipient == endpoint.address)
                            endpoint.inbox.push(event);
                    }
                }
                
                if (event.domain > MessageDomain.ITC)
                {
                    // Main-thread or circular message, forward to the synchronous bus
                    eventManager.addEvent(event);
                }
            }
            else
            {
                // Global events
                foreach(endpoint; endpoints)
                {
                    endpoint.inbox.push(event);
                }
            }
        }
    }
}
