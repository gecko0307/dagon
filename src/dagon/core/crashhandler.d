/*
Copyright (c) 2026 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Utility module for graceful error handling, mainly on Windows
 *
 * Description:
 * Under Windows, the `dagon.core.crashhandler` module registers a global
 * unhandled exception filter that logs a stack trace (for debug builds under x86_64).
 * This is useful to debug access violations such as acessing invalid pointers.
 * The module also provides `exitWithError` function to terminate the application
 * with an error message box.
 *
 * Copyright: Timur Gafarov 2026.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.core.crashhandler;

import std.string;
import core.stdc.stdlib;

import dagon.core.logger;
import dagon.core.bindings;

/**
 * Immediately terminates the application,
 * printing an optional fatal error to the logger.
 *
 * Params:
 *   message = Optional error message to log before exiting.
 */
void exitWithError(string message = "")
{
    if (message.length)
    {
        logFatalError(message);
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Fatal error", message.toStringz, null);
    }
    
    version(Windows)
        TerminateProcess(GetCurrentProcess(), 1);
    else
        core.stdc.stdlib.exit(1);
}

version(Windows)
{
    import core.sys.windows.windows;
    import core.sys.windows.dbghelp;
    
    version(X86_64)
    {
        import core.sys.windows.stacktrace;
        
        extern(Windows) nothrow @nogc
        {
            alias PREAD_PROCESS_MEMORY_ROUTINE64 = BOOL function(HANDLE hProcess, DWORD64 qwBaseAddress, PVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead);
            alias PFUNCTION_TABLE_ACCESS_ROUTINE64 = PVOID function(HANDLE ahProcess, DWORD64 AddrBase);
            alias PGET_MODULE_BASE_ROUTINE64 = DWORD64 function(HANDLE hProcess, DWORD64 Address);
            alias PTRANSLATE_ADDRESS_ROUTINE64 = DWORD function(HANDLE hProcess, HANDLE hThread, LPADDRESS lpaddr);
            
            BOOL StackWalk64(
                DWORD MachineType,
                HANDLE hProcess,
                HANDLE hThread,
                STACKFRAME64* StackFrame,
                PVOID ContextRecord,
                PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
                PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
                PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
                PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
            );
            
            PVOID SymFunctionTableAccess64(HANDLE hProcess, DWORD64 AddrBase);
            DWORD64 SymGetModuleBase64(HANDLE hProcess, DWORD64 qwAddr);
        }
        
        private enum MAX_FRAMES = 64;
        private __gshared ulong[MAX_FRAMES] addresses;
        
        private ulong[] traceContext(CONTEXT* ctx)
        {
            STACKFRAME64 frame;
            frame.AddrPC.Offset    = ctx.Rip;
            frame.AddrFrame.Offset = ctx.Rbp;
            frame.AddrStack.Offset = ctx.Rsp;
            frame.AddrPC.Mode    = ADDRESS_MODE.AddrModeFlat;
            frame.AddrFrame.Mode = ADDRESS_MODE.AddrModeFlat;
            frame.AddrStack.Mode = ADDRESS_MODE.AddrModeFlat;

            auto process = GetCurrentProcess();
            auto thread  = GetCurrentThread();

            int numFrames = 0;
            for (numFrames = 0; numFrames < MAX_FRAMES; numFrames++)
            {
                if (!StackWalk64(
                    IMAGE_FILE_MACHINE_AMD64,
                    process,
                    thread,
                    &frame,
                    ctx,
                    null,
                    &SymFunctionTableAccess64,
                    &SymGetModuleBase64,
                    null))
                {
                    break;
                }
                
                if (frame.AddrPC.Offset == 0)
                    break;
                
                addresses[numFrames] = frame.AddrPC.Offset;
            }
            
            return addresses[0..numFrames];
        }
    }
    
    private string exceptionName(DWORD code)
    {
        switch(code)
        {
            case 0xC0000005: return "access violation";
            case 0x80000003: return "breakpoint";
            case 0xC0000094: return "integer division by zero";
            default: return "unknown exception";
        }
    }
    
    private extern(Windows) LONG windowsCrashHandler(EXCEPTION_POINTERS* info)
    {
        auto record = info.ExceptionRecord;
        debug version(X86_64)
        {
            ulong[] addresses = traceContext(info.ContextRecord);
            char[][] symbols = StackTrace.resolve(addresses);
            
            logInfo("Stack trace:");
            foreach (i, symbol; symbols)
            {
                logInfo("  ", symbol);
            }
        }
        
        SymCleanup(GetCurrentProcess());
        
        exitWithError(format("Unhandled exception: %s (0x%08X)",
            exceptionName(record.ExceptionCode),
            record.ExceptionCode));
        
        return EXCEPTION_EXECUTE_HANDLER;
    }
}

static this()
{
    version(Windows)
    {
        SetUnhandledExceptionFilter(&windowsCrashHandler);
    }
}
