/*
Copyright (c) 2014-2025 Timur Gafarov, Mateusz Muszyński

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Primitives and tools for event-driven programming.
 *
 * Description:
 * The `dagon.core.event` module defines the `EventType` enumeration, 
 * the `Event` struct, the `EventManager` class for event polling and storing, 
 * and the `EventListener` base class for handling events.
 *
 * `EventManager` is single-threaded. For multi-threaded event/message passing,
 * use `MessageBroker`.
 *
 * Copyright: Timur Gafarov, Mateusz Muszyński 2014-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov, Mateusz Muszyński
 */
module dagon.core.event;

import std.stdio;
import std.ascii;
import std.conv;
import std.file;
import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.utils;
import dlib.container.array;
import dagon.core.bindings;
import dagon.core.application;
import dagon.core.input;
import dagon.core.logger;
import dagon.core.messaging;

/**
 * All supported event types in Dagon.
 */
enum EventType
{
    Cancelled = 0,
    KeyDown,
    KeyUp,
    TextInput,
    LocaleChange,
    MouseMotion,
    MouseButtonDown,
    MouseButtonUp,
    MouseWheel,
    JoystickButtonDown,
    JoystickButtonUp,
    JoystickAxisMotion,
    ControllerButtonDown,
    ControllerButtonUp,
    ControllerAxisMotion,
    ControllerAdd,
    ControllerRemove,
    PenMotion,
    Resize,
    FocusLoss,
    FocusGain,
    Quit,
    FileChange,
    DropFile,
    Log,
    Message,
    Task,
    UserEvent
}

/**
 * A delegate that can be used as an asynchronous callback in task events.
 * `executor` parameter is meant to be the object that executes the task.
 * `payload` is user-defined pointer passed with the event.
 */
alias TaskCallback = void delegate(Object executor, void* payload);

/**
 * Represents a single event in the Dagon event system.
 * Contains event type and relevant data for the event.
 */
struct Event
{
    EventType type;
    int key;
    dchar unicode;
    int button;
    int joystickButton;
    int joystickAxis;
    float joystickAxisValue;
    int controllerButton;
    int controllerAxis;
    float controllerAxisValue;
    int controllerDeviceIndex = -1;
    int x;
    int y;
    int width;
    int height;
    int userCode;
    int mouseWheelX;
    int mouseWheelY;
    float pressure;
    LogLevel logLevel;
    int domain;
    string filename;
    string message;
    string sender;
    string recipient;
    TaskCallback callback;
    void* payload;
}

/**
 * Communication layer `Event` is subject to.
 * Circular - event goes to both message broker and main-thread event listeners;
 * ITC - event goes to the message broker;
 * MainThread - event goes to main-thread event listeners.
 */
enum MessageDomain
{
    Circular = 0,
    ITC = -1,
    MainThread = 1
}

/**
 * Constructs a message event.
 */
Event messageEvent(string sender, string recipient, string message, void* payload, int domain = MessageDomain.ITC)
{
    Event e;
    e.type = EventType.Message;
    e.sender = sender;
    e.recipient = recipient;
    e.message = message;
    e.payload = payload;
    e.domain = domain;
    return e;
}

/**
 * Constructs a task event.
 */
Event taskEvent(string sender, string recipient, TaskCallback callback, void* payload, int domain = MessageDomain.ITC)
{
    Event e;
    e.type = EventType.Task;
    e.sender = sender;
    e.recipient = recipient;
    e.callback = callback;
    e.payload = payload;
    e.domain = domain;
    return e;
}

interface CustomInputDevice
{
    bool initialize(EventManager eventManager);
    bool pollEvents();
}

/**
 * Maximum number of supported controllers.
 */
enum MAX_CONTROLLERS = 1;

/**
 * Manages event polling, event queue and input state.
 *
 * Description:
 * EventManager polls SDL events and aggregates them in a queue. It also tracks
 * keyboard, mouse, joystick and controller state. Provides methods for generating
 * custom events.
 */
class EventManager: Owner
{
    /// Application object that owns this EventManager.
    Application application;
    
    /// A pointer to main application window.
    SDL_Window* window;
    
    /// Maximum number of simultaneous events.
    enum maxNumEvents = 50;
    
    /**
     * Inbox event queue. All synchronous events from SDL (such as user input) go here.
     * Inbox queue is cleared at the beginning of each event loop iteration,
     * so for emitting custom events, outboxEventQueue should be used.
     */
    Event[maxNumEvents] inboxEventQueue;
    
    alias eventQueue = inboxEventQueue;
    
    /// Number of events in the inbox queue.
    uint numInboxEvents;
    
    alias numEvents = numInboxEvents;
    
    /**
     * Outbox event queue. All external events (user events, messages, tasks) should go here.
     */
    Event[maxNumEvents] outboxEventQueue;
    
    /// Number of events in the outbox queue.
    uint numOutboxEvents;
    
    /// Used by Application to indicate activity. Set to false to stop the main loop.
    bool running = true;
    
    /// Keyboard key is currently pressed/released.
    bool[512] keyPressed = false;
    
    /// Keyboard key went up this frame (valid only if `trackUpDownState` is true).
    bool[512] keyUp = false;
    
    /// Keyboard key went down this frame (valid only if `trackUpDownState` is true).
    bool[512] keyDown = false;
    
    /// Mouse button is currently pressed/released.
    bool[255] mouseButtonPressed = false;
    
    /// Mouse button went up this frame (valid only if `trackUpDownState` is true).
    bool[255] mouseButtonUp = false;
    
    /// Mouse button went down this frame (valid only if `trackUpDownState` is true).
    bool[255] mouseButtonDown = false;
    
    /// Joystick button is currently pressed/released.
    bool[255] joystickButtonPressed = false;
    
    /// Joystick button went up this frame (valid only if `trackUpDownState` is true).
    bool[255] joystickButtonUp = false;
    
    /// Joystick button went down this frame (valid only if `trackUpDownState` is true).
    bool[255] joystickButtonDown = false;
    
    /// Controller button is currently pressed/released.
    bool[255] controllerButtonPressed = false;
    
    /// Controller button went up this frame (valid only if `trackUpDownState` is true).
    bool[255] controllerButtonUp = false;
    
    /// Controller button went down this frame (valid only if `trackUpDownState` is true).
    bool[255] controllerButtonDown = false;
    
    /// Whether to update up/down states for keys and buttons.
    bool trackUpDownState = false;
    
    protected
    {
        bool needToResetKeyUp = false;
        bool needToResetKeyDown = false;
        bool needToResetMouseUp = false;
        bool needToResetMouseDown = false;
        bool needToResetJoystickUp = false;
        bool needToResetJoystickDown = false;
        bool needToResetControllerUp = false;
        bool needToResetControllerDown = false;
    }
    
    /// Mouse pointer's X-coordinate relative to the window.
    int mouseX = 0;
    
    /// Mouse pointer's Y-coordinate relative to the window.
    int mouseY = 0;
    
    /// Relative change of the X-coordinate of the mouse pointer's position.
    int mouseRelX = 0;
    
    /// Relative change of the Y-coordinate of the mouse pointer's position.
    int mouseRelY = 0;
    
    /// Switch key repeat.
    bool enableKeyRepeat = false;
    
    /// Time in seconds since the last `updateTimer` call.
    double deltaTime = 0.0;
    
    /// Time in milliseconds since the last `updateTimer` call.
    uint deltaTimeMs = 0;
    
    /// Application's main window width.
    uint windowWidth;
    
    /// Application's main window height.
    uint windowHeight;
    
    /// Application's main window focus state.
    bool windowFocused = true;
    
    /// Last opened controller, if any.
    SDL_GameController* controller = null; // TODO: support multiple controllers
    
    /// Last opened joystick, if any.
    SDL_Joystick* joystick = null;
    
    /// A maximum that controller axis value is clamped to (for normalization in 0..1 range).
    int controllerAxisThreshold = 32639;
    
    deprecated("use controllerAxisThreshold instead")
    alias joystickAxisThreshold = controllerAxisThreshold;
    
    /// Current controller vibration support.
    bool controllerHasRumble = false;
    
    /// Current controller name.
    string controllerName;
    
    /// Current joystick name.
    string joystickName;
    
    /// Configurable input manager.
    InputManager inputManager;
    
    /// Message broker for distributing messages and scheduling tasks.
    MessageBroker messageBroker;
    
    Array!CustomInputDevice customInputDevices;
    
    /// Event dispatching hook. Provide your delegate to receive SDL events directly.
    void delegate(SDL_Event* event) onProcessEvent;

    /**
     * Constructs an EventManager for the given `Application`.
     *
     * Params:
     *   app = application object.
     */
    this(Application app)
    {
        super(app);
        
        application = app;
        
        window = app.window;

        windowWidth = app.width;
        windowHeight = app.height;
        
        if (exists("gamecontrollerdb.txt"))
            SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt");

        if (SDL_NumJoysticks() > 0)
        {
            gameControllerOpen(0);
        }

        inputManager = New!InputManager(this);
        
        messageBroker = New!MessageBroker(this);
    }

    /// Destructor. Cleans up resources.
    ~this()
    {
        Delete(inputManager);
        customInputDevices.free();
    }

    /// Signals the Application to stop running.
    void exit()
    {
        running = false;
    }

    void addCustomInputDevice(CustomInputDevice device)
    {
        customInputDevices.append(device);
    }

    /**
     * Adds a new event to the inbox queue.
     *
     * Params:
     *   e = The event to add.
     */
    void addEvent(Event e) nothrow
    {
        if (numEvents < maxNumEvents)
        {
            eventQueue[numEvents] = e;
            numEvents++;
        }
    }
    
    /**
     * Adds a new event to the outbox queue.
     *
     * Params:
     *   e = The event to add.
     */
    void queueEvent(Event e) nothrow
    {
        if (numOutboxEvents < maxNumEvents)
        {
            outboxEventQueue[numOutboxEvents] = e;
            numOutboxEvents++;
        }
    }

    deprecated("use queueEvent instead") alias addUserEvent = queueEvent;

    /**
     * Generates a file change event for the given filename.
     *
     * Params:
     *   filename = The changed file's name.
     */
    void queueFileChangeEvent(string filename) nothrow
    {
        Event e = Event(EventType.FileChange);
        e.filename = filename;
        queueEvent(e);
    }
    
    deprecated("use queueFileChangeEvent instead") alias generateFileChangeEvent = queueFileChangeEvent;

    /**
     * Generates a user event with the given code.
     *
     * Params:
     *   code = User event code.
     */
    void queueUserEvent(int code) nothrow
    {
        Event e = Event(EventType.UserEvent);
        e.userCode = code;
        queueEvent(e);
    }
    
    deprecated("use queueUserEvent instead") alias generateUserEvent = queueUserEvent;
    
    /**
     * Prints to the logger asynchronically using the event queue.
     * This method is also useful to log from nothrow functions,
     * because the logger itself is not nothrow.
     *
     * Params:
     *   code = User event code.
     */
    void queueLogEvent(LogLevel level, string message) nothrow
    {
        Event e = Event(EventType.Log);
        e.logLevel = level;
        e.message = message;
        queueEvent(e);
    }
    
    deprecated("use queueLogEvent instead") alias asyncLog = queueLogEvent;
    
    /**
     * Opens a game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to open.
     */
    void gameControllerOpen(uint deviceIndex)
    {
        if (SDL_IsGameController(deviceIndex))
        {
            if (joystick)
                SDL_JoystickClose(joystick);
            
            if (controller)
                SDL_GameControllerClose(controller);
            
            controller = SDL_GameControllerOpen(deviceIndex);
            
            auto name = SDL_GameControllerName(controller);
            if (name)
            {
                controllerName = name.to!string;
                logInfo("Game controller: ", controllerName);
            }
            
            if (SDL_GameControllerMapping(controller) is null)
                logWarning("No mapping found for controller!");

            SDL_GameControllerEventState(SDL_ENABLE);
            
            joystick = SDL_GameControllerGetJoystick(controller);
            
            controllerHasRumble = cast(bool)SDL_GameControllerHasRumble(controller);
        }
        else
        {
            if (joystick)
                SDL_JoystickClose(joystick);
            
            joystick = SDL_JoystickOpen(deviceIndex);
            
            auto name = SDL_JoystickName(joystick);
            if (name)
            {
                joystickName = name.to!string;
                logInfo("Joystick: ", joystickName);
            }
        }
    }
    
    /**
     * Closes the game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to close.
     */
    void gameControllerClose(uint deviceIndex)
    {
        if (joystick)
        {
            SDL_JoystickClose(joystick);
            joystickName = "";
        }
        
        if (controller)
        {
            SDL_GameControllerClose(controller);
            controllerName = "";
            controllerHasRumble = false;
        }
    }

    /// Returns true if a game controller is available.
    bool gameControllerAvailable()
    {
        return (controller !is null);
    }

    /// Returns true if a joystick is available.
    bool joystickAvailable()
    {
        return (joystick !is null);
    }

    /**
     * Gets the normalized value of a game controller axis.
     *
     * Params:
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float gameControllerAxis(int axis)
    {
        int axisVal = SDL_GameControllerGetAxis(controller, cast(SDL_GameControllerAxis)axis);
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }

    /**
     * Gets the normalized value of a joystick axis.
     *
     * Params:
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float joystickAxis(int axis)
    {
        int axisVal = 0;
        if (joystick)
            axisVal = SDL_JoystickGetAxis(joystick, axis);
        else if (controller)
            axisVal = SDL_GameControllerGetAxis(controller, cast(SDL_GameControllerAxis)axis);
        else
            return 0.0f;
        
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }
    
    /**
     * Triggers controller rumble (vibration) if supported.
     *
     * Params:
     *   lowFreq = Low frequency rumble intensity.
     *   hiFreg = High frequency rumble intensity.
     *   duration = Duration in seconds.
     */
    void gameControllerRumble(uint lowFreq, uint hiFreg, float duration)
    {
        if (controllerHasRumble)
            SDL_GameControllerRumble(controller,
                cast(ushort)clamp(lowFreq, 0, ushort.max),
                cast(ushort)clamp(hiFreg, 0, ushort.max),
                cast(uint)(duration * 1000.0f));
    }

    /// Polls and processes all pending events.
    void update()
    {
        numEvents = 0;

        mouseRelX = 0;
        mouseRelY = 0;
        
        // Aggregate user-emitted events
        for (uint i = 0; i < numOutboxEvents; i++)
        {
            Event e = outboxEventQueue[i];
            if (e.type == EventType.Log)
                log(e.logLevel, e.message);
            else if (e.type == EventType.Task && !messageBroker.canRunTasks)
                e.callback(null, e.payload);
            else
                addEvent(e);
        }
        
        numOutboxEvents = 0;
        
        if (trackUpDownState)
            resetUpDown();

        SDL_Event event;

        while(SDL_PollEvent(&event))
        {
            if (onProcessEvent) onProcessEvent(&event);
            Event e;
            switch (event.type)
            {
                case SDL_KEYDOWN:
                    if (event.key.repeat && !enableKeyRepeat)
                        break;

                    keyPressed[event.key.keysym.scancode] = true;
                    
                    if (trackUpDownState)
                    {
                        keyDown[event.key.keysym.scancode] = true;
                        needToResetKeyDown = true;
                    }

                    e = Event(EventType.KeyDown);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_KEYUP:
                    keyPressed[event.key.keysym.scancode] = false;
                    
                    if (trackUpDownState)
                    {
                        keyUp[event.key.keysym.scancode] = true;
                        needToResetKeyUp = true;
                    }

                    e = Event(EventType.KeyUp);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_TEXTINPUT:
                    e = Event(EventType.TextInput);
                    char[] input = event.text.text;
                    if ((input[0] & 0x80) == 0)
                        e.unicode = input[0];
                    else if ((input[0] & 0xE0) == 0xC0)
                        e.unicode = ((input[0] & 0x1F) << 6) | (input[1] & 0x3F);
                    else if ((input[0] & 0xF0) == 0xE0)
                        e.unicode = ((input[0] & 0x0F) << 12) | ((input[1] & 0x3F) << 6) | (input[2] & 0x3F);
                    else if ((input[0] & 0xF8) == 0xF0)
                        e.unicode = (((input[0] & 0x0F) << 18) | ((input[1] & 0x3F) << 12) | ((input[2] & 0x3F) << 6) | (input[3] & 0x3F));
                    addEvent(e);
                    break;

                case SDL_LOCALECHANGED:
                    e = Event(EventType.LocaleChange);
                    //application.locale = systemLocale(); // do we need this?
                    addEvent(e);
                    break;

                case SDL_MOUSEMOTION:
                    mouseX = event.motion.x;
                    mouseY = event.motion.y;
                    mouseRelX = event.motion.xrel;
                    mouseRelY = event.motion.yrel;
                    break;

                case SDL_MOUSEBUTTONDOWN:
                    mouseButtonPressed[event.button.button] = true;
                    
                    if (trackUpDownState)
                    {
                        mouseButtonDown[event.button.button] = true;
                        needToResetMouseDown = true;
                    }
                    
                    e = Event(EventType.MouseButtonDown);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEBUTTONUP:
                    mouseButtonPressed[event.button.button] = false;
                    
                    if (trackUpDownState)
                    {
                        mouseButtonUp[event.button.button] = true;
                        needToResetMouseUp = true;
                    }
                    
                    e = Event(EventType.MouseButtonUp);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEWHEEL:
                    e = Event(EventType.MouseWheel);
                    e.mouseWheelX = event.wheel.x;
                    e.mouseWheelY = event.wheel.y;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONDOWN:
                    if(joystick is null) break;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        joystickButtonPressed[event.jbutton.button] = true;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonDown[event.jbutton.button] = true;
                            needToResetJoystickDown = true;
                        }
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        joystickButtonPressed[event.jbutton.button] = false;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonUp[event.jbutton.button] = true;
                            needToResetJoystickUp = true;
                        }
                    }
                    e.joystickButton = event.jbutton.button;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONUP:
                    if(joystick is null) break;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        joystickButtonPressed[event.jbutton.button] = true;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonDown[event.jbutton.button] = true;
                            needToResetJoystickDown = true;
                        }
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        joystickButtonPressed[event.jbutton.button] = false;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonUp[event.jbutton.button] = true;
                            needToResetJoystickUp = true;
                        }
                    }
                    e.joystickButton = event.jbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONDOWN:
                    controllerButtonPressed[event.cbutton.button] = true;
                    
                    if (trackUpDownState)
                    {
                        controllerButtonDown[event.cbutton.button] = true;
                        needToResetControllerDown = true;
                    }

                    e = Event(EventType.ControllerButtonDown);
                    e.controllerButton = event.cbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONUP:
                    controllerButtonPressed[event.cbutton.button] = false;
                    
                    if (trackUpDownState)
                    {
                        controllerButtonUp[event.cbutton.button] = true;
                        needToResetControllerUp = true;
                    }

                    e = Event(EventType.ControllerButtonUp);
                    e.controllerButton = event.cbutton.button;
                    addEvent(e);
                    break;

                case SDL_JOYAXISMOTION:
                    // TODO: add state modification
                    e = Event(EventType.JoystickAxisMotion);
                    e.joystickAxis = event.caxis.axis;
                    int axisValue = event.caxis.value;
                    if (joystick)
                    {
                        axisValue = SDL_JoystickGetAxis(joystick, e.joystickAxis);
                    }
                    e.joystickAxisValue =
                        cast(float)clamp(axisValue, -controllerAxisThreshold, controllerAxisThreshold) / 
                        cast(float)controllerAxisThreshold;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERAXISMOTION:
                    // TODO: add state modification
                    e = Event(EventType.ControllerAxisMotion);
                    e.controllerAxis = event.caxis.axis;
                    int axisValue = event.caxis.value;
                    if (controller)
                    {
                        if (e.controllerAxis == 0)
                            axisValue = SDL_GameControllerGetAxis(controller, SDL_CONTROLLER_AXIS_LEFTY);
                        if (e.controllerAxis == 1)
                            axisValue = SDL_GameControllerGetAxis(controller, SDL_CONTROLLER_AXIS_LEFTX);
                    }
                    e.controllerAxisValue =
                        cast(float)clamp(axisValue, -controllerAxisThreshold, controllerAxisThreshold) / 
                        cast(float)controllerAxisThreshold;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEADDED:
                    e = Event(EventType.ControllerAdd);
                    e.controllerDeviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                        gameControllerOpen(event.cdevice.which);
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEREMOVED:
                    e = Event(EventType.ControllerRemove);
                    e.controllerDeviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                        gameControllerClose(event.cdevice.which);
                    addEvent(e);
                    break;

                case SDL_WINDOWEVENT:
                    if (event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)
                    {
                        windowWidth = event.window.data1;
                        windowHeight = event.window.data2;
                        e = Event(EventType.Resize);
                        e.width = windowWidth;
                        e.height = windowHeight;
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED)
                    {
                        e = Event(EventType.FocusGain);
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_LOST)
                    {
                        e = Event(EventType.FocusLoss);
                        addEvent(e);
                    }
                    break;

                case SDL_DROPFILE:
                    e = Event(EventType.DropFile);
                    e.filename = to!string(event.drop.file);
                    addEvent(e);
                    break;

                case SDL_QUIT:
                    exit();
                    e = Event(EventType.Quit);
                    addEvent(e);
                    break;

                default:
                    break;
            }
        }
        
        foreach(device; customInputDevices)
        {
            while(device.pollEvents())
            {
                //
            }
        }
        
        messageBroker.update();
    }

    protected int lastTime = 0;

    /// Updates the internal timer and computes delta time.
    void updateTimer()
    {
        int currentTime = SDL_GetTicks();
        auto elapsedTime = currentTime - lastTime;
        lastTime = currentTime;
        deltaTimeMs = elapsedTime;
        deltaTime = cast(double)(elapsedTime) * 0.001;
    }

    /**
     * Sets the mouse cursor position.
     *
     * Params:
     *   x = X coordinate.
     *   y = Y coordinate.
     */
    void setMouse(int x, int y)
    {
        SDL_WarpMouseInWindow(window, x, y);
        mouseX = x;
        mouseY = y;
    }

    /// Centers the mouse cursor in the window.
    void setMouseToCenter()
    {
        float x = (cast(float)windowWidth) / 2;
        float y = (cast(float)windowHeight) / 2;
        setMouse(cast(int)x, cast(int)y);
    }

    /**
     * Shows or hides the mouse cursor.
     *
     * Params:
     *   mode = true to show, false to hide.
     * Returns:
     *   SDL result code.
     */
    int showCursor(bool mode)
    {
        return SDL_ShowCursor(mode);
    }

    /**
     * Enables or disables relative mouse mode.
     *
     * Params:
     *   mode = true to enable, false to disable.
     * Returns:
     *   SDL result code.
     */
    int setRelativeMouseMode(bool mode)
    {
        return SDL_SetRelativeMouseMode(cast(SDL_bool)mode);
    }

     /// Returns the current window aspect ratio.
    float aspectRatio()
    {
        return cast(float)windowWidth / cast(float)windowHeight;
    }

    /// Resets all up and down input event states.
    void resetUpDown()
    {
        if (needToResetKeyUp)
        {
            keyUp[] = false;
            needToResetKeyUp = false;
        }
        
        if (needToResetKeyDown)
        {
            keyDown[] = false;
            needToResetKeyDown = false;
        }
        
        if (needToResetMouseUp)
        {
            mouseButtonUp[] = false;
            needToResetMouseUp = false;
        }
        
        if (needToResetMouseDown)
        {
            mouseButtonDown[] = false;
            needToResetMouseDown = false;
        }
        
        if (needToResetJoystickUp)
        {
            joystickButtonUp[] = false;
            needToResetJoystickUp = false;
        }
        
        if (needToResetJoystickDown)
        {
            joystickButtonDown[] = false;
            needToResetJoystickDown = false;
        }
        
        if (needToResetControllerUp)
        {
            controllerButtonUp[] = false;
            needToResetControllerUp = false;
        }
        
        if (needToResetControllerDown)
        {
            controllerButtonDown[] = false;
            needToResetControllerDown = false;
        }
    }
}

/**
 * Base class for event dispatchers.
 *
 * Description:
 * Inherit from `EventDispatcher` and override the relevant event handler methods.
 * Call `processEvents` to dispatch an event to your handlers.
 */
abstract class EventDispatcher: Owner
{
    /// Addressing domain of this dispatcher.
    protected int domain = MessageDomain.MainThread;
    
    /// Address of this dispatcher.
    string address = "";
    
    /**
     * Constructs an EventDispatcher.
     *
     * Params:
     *   owner = owner object.
     */
    this(Owner owner)
    {
        super(owner);
    }
    
    /**
     * Processes a single event, dispatching it to the appropriate handler.
     *
     * Params:
     *   e = The event to process.
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvent(Event* e, bool enableInputEvents = true)
    {
        switch(e.type)
        {
            case EventType.KeyDown:
                if (enableInputEvents) onKeyDown(e.key);
                break;
            case EventType.KeyUp:
                if (enableInputEvents) onKeyUp(e.key);
                break;
            case EventType.TextInput:
                if (enableInputEvents) onTextInput(e.unicode);
                break;
            case EventType.MouseButtonDown:
                if (enableInputEvents) onMouseButtonDown(e.button);
                break;
            case EventType.MouseButtonUp:
                if (enableInputEvents) onMouseButtonUp(e.button);
                break;
            case EventType.MouseWheel:
                if (enableInputEvents) onMouseWheel(e.mouseWheelX, e.mouseWheelY);
                break;
            case EventType.JoystickButtonDown:
                if (enableInputEvents) onJoystickButtonDown(e.joystickButton);
                break;
            case EventType.JoystickButtonUp:
                if (enableInputEvents) onJoystickButtonUp(e.joystickButton);
                break;
            case EventType.JoystickAxisMotion:
                if (enableInputEvents) onJoystickAxisMotion(e.joystickAxis, e.joystickAxisValue);
                break;
            case EventType.ControllerButtonDown:
                if (enableInputEvents) onControllerButtonDown(e.controllerButton);
                break;
            case EventType.ControllerButtonUp:
                if (enableInputEvents) onControllerButtonUp(e.controllerButton);
                break;
            case EventType.ControllerAxisMotion:
                if (enableInputEvents) onControllerAxisMotion(e.controllerAxis, e.controllerAxisValue);
                break;
            case EventType.ControllerAdd:
                if (enableInputEvents) onControllerAdd(e.controllerDeviceIndex);
                break;
            case EventType.ControllerRemove:
                if (enableInputEvents) onControllerRemove(e.controllerDeviceIndex);
                break;
            case EventType.PenMotion:
                if (enableInputEvents) onPenMotion(e.x, e.y, e.pressure);
                break;
            case EventType.Resize:
                onResize(e.width, e.height);
                break;
            case EventType.FocusLoss:
                onFocusLoss();
                break;
            case EventType.FocusGain:
                onFocusGain();
                break;
            case EventType.Quit:
                onQuit();
                break;
            case EventType.LocaleChange:
                onLocaleChange();
                break;
            case EventType.FileChange:
                onFileChange(e.filename);
                break;
            case EventType.DropFile:
                if (enableInputEvents) onDropFile(e.filename);
                break;
            case EventType.Message:
                if (e.domain * domain >= 0) // if domains are same
                    if (e.recipient.length == 0 || e.recipient == address)
                        onMessage(e.domain, e.sender, e.message, e.payload);
                break;
            case EventType.Task:
                if (e.domain * domain >= 0) // if domains are same
                    if (e.recipient.length == 0 || e.recipient == address)
                        onTask(e.domain, e.sender, e.callback, e.payload);
                break;
            case EventType.UserEvent:
                onUserEvent(e.userCode);
                break;
            default:
                break;
        }
    }

    /// Called when a key is pressed.
    void onKeyDown(int key) {}

    /// Called when a key is released.
    void onKeyUp(int key) {}

    /// Called when text input is received.
    void onTextInput(dchar code) {}

    /// Called when a mouse button is pressed.
    void onMouseButtonDown(int button) {}

    /// Called when a mouse button is released.
    void onMouseButtonUp(int button) {}

    /// Called when the mouse wheel is scrolled.
    void onMouseWheel(int x, int y) {}

    /// Called when a joystick button is pressed.
    void onJoystickButtonDown(int button) {}

    /// Called when a joystick button is released.
    void onJoystickButtonUp(int button) {}
    
    /// Called when a joystick axis is moved.
    void onJoystickAxisMotion(int axis, float value) {}

    /// Called when a controller button is pressed.
    void onControllerButtonDown(int button) {}

    /// Called when a controller button is released.
    void onControllerButtonUp(int button) {}

    /// Called when a controller axis is moved.
    void onControllerAxisMotion(int axis, float value) {}

    /// Called when a controller is added.
    void onControllerAdd(uint deviceIndex) {}

    /// Called when a controller is removed.
    void onControllerRemove(uint deviceIndex) {}
    
    void onPenMotion(int x, int y, float pressure) {}

    /// Called when the window is resized.
    void onResize(int width, int height) {}

    /// Called when the window loses focus.
    void onFocusLoss() {}

    /// Called when the window gains focus.
    void onFocusGain() {}

    /// Called when a quit event is received.
    void onQuit() {}

    /// Called when a user locale preferences have changed.
    void onLocaleChange() {}

    /// Called when a file change is detected.
    void onFileChange(string filename) {}

    /// Called when a file is dropped onto the window.
    void onDropFile(string filename) {}

    /// Called when a message event is received.
    void onMessage(int domain, string sender, string message, void* payload) {}
    
    /// Called when a task event is received.
    void onTask(int domain, string sender, TaskCallback callback, void* payload) {}

    /// Called when a user event is received.
    void onUserEvent(int code) {}
}

/**
 * Base class for single-threaded event listeners.
 */
abstract class EventListener: EventDispatcher
{
    /// The event manager used for polling events.
    EventManager eventManager;
    
    /// The input manager for input state queries.
    InputManager inputManager;
    
    /// If false, disables event processing.
    bool enabled = true;
    
    /**
     * Constructs an EventListener.
     *
     * Params:
     *   emngr = The event manager to use.
     *   owner = The owner object for memory management.
     */
    this(EventManager emngr, Owner owner)
    {
        super(owner);
        domain = MessageDomain.MainThread;
        eventManager = emngr;
        if(emngr !is null)
            inputManager = emngr.inputManager;
    }

    /**
     * Queues a user event with the given code.
     *
     * Params:
     *   code = User event code.
     */
    protected void generateUserEvent(int code)
    {
        eventManager.queueUserEvent(code);
    }
    
    /**
     * Queues a message event.
     *
     * Params:
     *   recipient = Recipient object's address. Leave empty for broadcast.
     *   message = Message string.
     *   payload = Optional pointer to be passed with the event.
     *   domain = Message domain/communication layer (ITC or main-thread).
     */
    protected void queueMessage(string recipient, string message, void* payload = null, int domain = MessageDomain.ITC)
    {
        Event task = messageEvent(address, recipient, message, payload, domain);
        eventManager.queueEvent(task);
    }
    
    alias send = queueMessage;
    
    /**
     * Queues a task event.
     *
     * Params:
     *   callback = A delegate that should be executed.
     *   payload = Optional pointer to be passed with the event.
     *   domain = Message domain/communication layer (ITC or main-thread).
     */
    protected void queueTask(scope TaskCallback callback, void* payload = null, int domain = MessageDomain.ITC)
    {
        Event task = taskEvent(address, "", callback, payload, domain);
        eventManager.queueEvent(task);
    }
    
    /**
     * Queues a log event.
     *
     * Params:
     *   level = Log level.
     *   message = Log message.
     */
    protected void queueLog(LogLevel level, string message)
    {
        Event e = Event(EventType.Log);
        e.logLevel = level;
        e.message = message;
        eventManager.queueEvent(e);
    }

    /**
     * Processes all pending events, dispatching them to handler methods.
     *
     * Params:
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvents(bool enableInputEvents = true)
    {
        if (!enabled)
            return;

        for (uint i = 0; i < eventManager.numEvents; i++)
        {
            Event* e = &eventManager.eventQueue[i];
            processEvent(e, enableInputEvents);
        }
    }
}
