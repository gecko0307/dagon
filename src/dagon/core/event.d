/*
Copyright (c) 2014-2025 Timur Gafarov, Mateusz Muszyński

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides an event manager for input, window, and user-defined events.
 *
 * Description:
 * The `dagon.core.event` module defines the `EventType` enumeration, 
 * the `Event` struct, the `EventManager` class for event polling and dispatch, 
 * and the `EventListener` base class for handling events.
 *
 * Copyright: Timur Gafarov, Mateusz Muszyński 2014-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov, Mateusz Muszyński
 */
module dagon.core.event;

import std.stdio;
import std.ascii;
import std.conv;
import std.file;
import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.utils;
import dlib.container.array;
import dagon.core.bindings;
import dagon.core.input;
import dagon.core.logger;

/**
 * All supported event types in Dagon.
 */
enum EventType
{
    KeyDown,
    KeyUp,
    TextInput,
    MouseMotion,
    MouseButtonDown,
    MouseButtonUp,
    MouseWheel,
    JoystickButtonDown,
    JoystickButtonUp,
    ControllerButtonDown,
    ControllerButtonUp,
    ControllerAxisMotion,
    ControllerAdd,
    ControllerRemove,
    Resize,
    FocusLoss,
    FocusGain,
    Quit,
    FileChange,
    DropFile,
    AsyncLogEvent,
    UserEvent
}

/**
 * Represents a single event in the Dagon event system.
 * Contains event type and relevant data for the event.
 */
struct Event
{
    EventType type;
    int key;
    dchar unicode;
    int button;
    int joystickButton;
    int controllerButton;
    int controllerAxis;
    float controllerAxisValue;
    int controllerDeviceIndex = -1;
    int width;
    int height;
    int userCode;
    int mouseWheelX;
    int mouseWheelY;
    string filename;
    LogLevel logLevel;
    string message;
}

/**
 * Maximum number of supported controllers.
 */
enum MAX_CONTROLLERS = 1;

/**
 * Manages event polling, state, and dispatch.
 *
 * Description:
 * Handles input events, window events, controller/joystick events, and user-defined events.
 * Provides methods for polling SDL events, generating custom events, and querying input state.
 */
class EventManager
{
    SDL_Window* window;

    enum maxNumEvents = 50;
    Event[maxNumEvents] eventQueue;
    Event[maxNumEvents] userEventQueue;
    uint numEvents;
    uint numUserEvents;

    bool running = true;

    bool[512] keyPressed = false;
    bool[512] keyUp = false;
    bool[512] keyDown = false;

    bool[255] mouseButtonPressed = false;
    bool[255] mouseButtonUp = false;
    bool[255] mouseButtonDown = false;
    
    bool[255] joystickButtonPressed = false;
    bool[255] joystickButtonUp = false;
    bool[255] joystickButtonDown = false;

    bool[255] controllerButtonPressed = false;
    bool[255] controllerButtonUp = false;
    bool[255] controllerButtonDown = false;
    
    Array!(bool*) toReset; // Used for resetting UP and DOWN events after end of frame

    int mouseX = 0;
    int mouseY = 0;
    int mouseRelX = 0;
    int mouseRelY = 0;
    bool enableKeyRepeat = false;

    double deltaTime = 0.0;
    uint deltaTimeMs = 0;

    uint windowWidth;
    uint windowHeight;
    bool windowFocused = true;

    // TODO: support multiple controllers up to MAX_CONTROLLERS
    SDL_GameController* controller = null;
    SDL_Joystick* joystick = null;
    int controllerAxisThreshold = 32639;
    deprecated("use controllerAxisThreshold instead")
    alias joystickAxisThreshold = controllerAxisThreshold;
    bool controllerHasRumble = false;
    string controllerName;
    string joystickName;
    
    InputManager inputManager;
    
    void delegate(SDL_Event* event) onProcessEvent;

    /**
     * Constructs an EventManager for the given SDL window and dimensions.
     *
     * Params:
     *   win = SDL window pointer.
     *   winWidth = Window width.
     *   winHeight = Window height.
     */
    this(SDL_Window* win, uint winWidth, uint winHeight)
    {
        window = win;

        windowWidth = winWidth;
        windowHeight = winHeight;
        
        if (exists("gamecontrollerdb.txt"))
            SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt");

        if (SDL_NumJoysticks() > 0)
        {
            gameControllerOpen(0);
        }

        toReset = Array!(bool*)();

        inputManager = New!InputManager(this);
    }

    /// Destructor. Cleans up resources.
    ~this()
    {
        toReset.free();
        Delete(inputManager);
    }

    /// Signals the event manager to stop running (application exit).
    void exit()
    {
        running = false;
    }

    /**
     * Adds a new event to the event stack.
     *
     * Params:
     *   e = The event to add.
     */
    void addEvent(Event e) nothrow
    {
        if (numEvents < maxNumEvents)
        {
            eventQueue[numEvents] = e;
            numEvents++;
        }
    }

    /**
     * Generates a file change event for the given filename.
     *
     * Params:
     *   filename = The changed file's name.
     */
    void generateFileChangeEvent(string filename) nothrow
    {
        Event e = Event(EventType.FileChange);
        e.filename = filename;
        addUserEvent(e);
    }

    /**
     * Adds a user event to the user event queue.
     *
     * Params:
     *   e = The user event to add.
     */
    void addUserEvent(Event e) nothrow
    {
        if (numUserEvents < maxNumEvents)
        {
            userEventQueue[numUserEvents] = e;
            numUserEvents++;
        }
    }

    /**
     * Generates a user event with the given code.
     *
     * Params:
     *   code = User event code.
     */
    void generateUserEvent(int code) nothrow
    {
        Event e = Event(EventType.UserEvent);
        e.userCode = code;
        addUserEvent(e);
    }
    
    /**
     * Prints to the logger asynchronically using the event queue.
     * This method is also useful to log from nothrow functions,
     * because the logger itself is not nothrow.
     *
     * Params:
     *   code = User event code.
     */
    void asyncLog(LogLevel level, string message) nothrow
    {
        Event e = Event(EventType.AsyncLogEvent);
        e.logLevel = level;
        e.message = message;
        addUserEvent(e);
    }
    
    /**
     * Opens a game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to open.
     */
    void gameControllerOpen(uint deviceIndex)
    {
        if (SDL_IsGameController(deviceIndex))
        {
            if (joystick)
                SDL_JoystickClose(joystick);
            
            if (controller)
                SDL_GameControllerClose(controller);
            
            controller = SDL_GameControllerOpen(deviceIndex);
            
            auto name = SDL_GameControllerName(controller);
            if (name)
            {
                controllerName = name.to!string;
                logInfo("Game controller: ", controllerName);
            }
            
            if (SDL_GameControllerMapping(controller) is null)
                logWarning("No mapping found for controller!");

            SDL_GameControllerEventState(SDL_ENABLE);
            
            joystick = SDL_GameControllerGetJoystick(controller);
            
            controllerHasRumble = cast(bool)SDL_GameControllerHasRumble(controller);
        }
        else
        {
            if (joystick)
                SDL_JoystickClose(joystick);
            
            joystick = SDL_JoystickOpen(deviceIndex);
            
            auto name = SDL_JoystickName(joystick);
            if (name)
            {
                joystickName = name.to!string;
                logInfo("Joystick: ", joystickName);
            }
        }
    }
    
    /**
     * Closes the game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to close.
     */
    void gameControllerClose(uint deviceIndex)
    {
        if (joystick)
        {
            SDL_JoystickClose(joystick);
            joystickName = "";
        }
        
        if (controller)
        {
            SDL_GameControllerClose(controller);
            controllerName = "";
            controllerHasRumble = false;
        }
    }

    /// Returns true if a game controller is available.
    bool gameControllerAvailable()
    {
        return (controller !is null);
    }

    /// Returns true if a joystick is available.
    bool joystickAvailable()
    {
        return (joystick !is null);
    }

    /**
     * Gets the normalized value of a game controller axis.
     *
     * Params:
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float gameControllerAxis(int axis)
    {
        int axisVal = SDL_GameControllerGetAxis(controller, cast(SDL_GameControllerAxis)axis);
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }

    /**
     * Gets the normalized value of a joystick axis.
     *
     * Params:
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float joystickAxis(int axis)
    {
        int axisVal = 0;
        if (joystick)
            axisVal = SDL_JoystickGetAxis(joystick, axis);
        else if (controller)
            axisVal = SDL_GameControllerGetAxis(controller, cast(SDL_GameControllerAxis)axis);
        else
            return 0.0f;
        
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }
    
    /**
     * Triggers controller rumble (vibration) if supported.
     *
     * Params:
     *   lowFreq = Low frequency rumble intensity.
     *   hiFreg = High frequency rumble intensity.
     *   duration = Duration in seconds.
     */
    void gameControllerRumble(uint lowFreq, uint hiFreg, float duration)
    {
        if (controllerHasRumble)
            SDL_GameControllerRumble(controller,
                cast(ushort)clamp(lowFreq, 0, ushort.max),
                cast(ushort)clamp(hiFreg, 0, ushort.max),
                cast(uint)(duration * 1000.0f));
    }

    /// Polls and processes all pending events.
    void update()
    {
        numEvents = 0;

        mouseRelX = 0;
        mouseRelY = 0;

        for (uint i = 0; i < numUserEvents; i++)
        {
            Event e = userEventQueue[i];
            if (e.type == EventType.AsyncLogEvent)
                log(e.logLevel, e.message);
            else
                addEvent(e);
        }

        numUserEvents = 0;

        SDL_Event event;

        while(SDL_PollEvent(&event))
        {
            if (onProcessEvent) onProcessEvent(&event);
            Event e;
            switch (event.type)
            {
                case SDL_KEYDOWN:
                    if (event.key.repeat && !enableKeyRepeat)
                        break;

                    keyPressed[event.key.keysym.scancode] = true;
                    keyDown[event.key.keysym.scancode] = true;
                    keyUp[event.key.keysym.scancode] = false;
                    toReset.insertBack(&keyDown[event.key.keysym.scancode]);

                    e = Event(EventType.KeyDown);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_KEYUP:
                    keyPressed[event.key.keysym.scancode] = false;
                    keyDown[event.key.keysym.scancode] = false;
                    keyUp[event.key.keysym.scancode] = true;
                    toReset.insertBack(&keyUp[event.key.keysym.scancode]);

                    e = Event(EventType.KeyUp);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_TEXTINPUT:
                    e = Event(EventType.TextInput);
                    char[] input = event.text.text;
                    if ((input[0] & 0x80) == 0)
                        e.unicode = input[0];
                    else if ((input[0] & 0xE0) == 0xC0)
                        e.unicode = ((input[0] & 0x1F) << 6) | (input[1] & 0x3F);
                    else if ((input[0] & 0xF0) == 0xE0)
                        e.unicode = ((input[0] & 0x0F) << 12) | ((input[1] & 0x3F) << 6) | (input[2] & 0x3F);
                    else if ((input[0] & 0xF8) == 0xF0)
                        e.unicode = (((input[0] & 0x0F) << 18) | ((input[1] & 0x3F) << 12) | ((input[2] & 0x3F) << 6) | (input[3] & 0x3F));
                    addEvent(e);
                    break;

                case SDL_MOUSEMOTION:
                    mouseX = event.motion.x;
                    mouseY = event.motion.y;
                    mouseRelX = event.motion.xrel;
                    mouseRelY = event.motion.yrel;
                    break;

                case SDL_MOUSEBUTTONDOWN:
                    mouseButtonPressed[event.button.button] = true;
                    mouseButtonDown[event.button.button] = true;
                    toReset.insertBack(&mouseButtonDown[event.button.button]);

                    e = Event(EventType.MouseButtonDown);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEBUTTONUP:
                    mouseButtonPressed[event.button.button] = false;
                    mouseButtonUp[event.button.button] = true;
                    toReset.insertBack(&mouseButtonUp[event.button.button]);

                    e = Event(EventType.MouseButtonUp);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEWHEEL:
                    e = Event(EventType.MouseWheel);
                    e.mouseWheelX = event.wheel.x;
                    e.mouseWheelY = event.wheel.y;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONDOWN:
                    if(joystick is null) break;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        joystickButtonPressed[event.jbutton.button] = true;
                        joystickButtonDown[event.jbutton.button] = true;
                        toReset.insertBack(&joystickButtonDown[event.jbutton.button]);
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        joystickButtonPressed[event.jbutton.button] = false;
                        joystickButtonUp[event.jbutton.button] = true;
                        toReset.insertBack(&joystickButtonUp[event.jbutton.button]);
                    }
                    e.joystickButton = event.jbutton.button;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONUP:
                    if(joystick is null) break;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        joystickButtonPressed[event.jbutton.button] = true;
                        joystickButtonDown[event.jbutton.button] = true;
                        toReset.insertBack(&joystickButtonDown[event.jbutton.button]);
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        joystickButtonPressed[event.jbutton.button] = false;
                        joystickButtonUp[event.jbutton.button] = true;
                        toReset.insertBack(&joystickButtonUp[event.jbutton.button]);
                    }
                    e.joystickButton = event.jbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONDOWN:
                    controllerButtonPressed[event.cbutton.button] = true;
                    controllerButtonDown[event.cbutton.button] = true;
                    toReset.insertBack(&controllerButtonDown[event.cbutton.button]);

                    e = Event(EventType.ControllerButtonDown);
                    e.controllerButton = event.cbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONUP:
                    controllerButtonPressed[event.cbutton.button] = false;
                    controllerButtonUp[event.cbutton.button] = true;
                    toReset.insertBack(&controllerButtonUp[event.cbutton.button]);

                    e = Event(EventType.ControllerButtonUp);
                    e.controllerButton = event.cbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERAXISMOTION:
                    // TODO: add state modification
                    e = Event(EventType.ControllerAxisMotion);
                    e.controllerAxis = event.caxis.axis;
                    int axisValue = event.caxis.value;
                    if (controller)
                    {
                        if (e.controllerAxis == 0)
                            axisValue = SDL_GameControllerGetAxis(controller, SDL_CONTROLLER_AXIS_LEFTY);
                        if (e.controllerAxis == 1)
                            axisValue = SDL_GameControllerGetAxis(controller, SDL_CONTROLLER_AXIS_LEFTX);
                    }
                    e.controllerAxisValue =
                        cast(float)clamp(axisValue, -controllerAxisThreshold, controllerAxisThreshold) / 
                        cast(float)controllerAxisThreshold;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEADDED:
                    e = Event(EventType.ControllerAdd);
                    e.controllerDeviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                        gameControllerOpen(event.cdevice.which);
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEREMOVED:
                    e = Event(EventType.ControllerRemove);
                    e.controllerDeviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                        gameControllerClose(event.cdevice.which);
                    addEvent(e);
                    break;

                case SDL_WINDOWEVENT:
                    if (event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)
                    {
                        windowWidth = event.window.data1;
                        windowHeight = event.window.data2;
                        e = Event(EventType.Resize);
                        e.width = windowWidth;
                        e.height = windowHeight;
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED)
                    {
                        e = Event(EventType.FocusGain);
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_LOST)
                    {
                        e = Event(EventType.FocusLoss);
                        addEvent(e);
                    }
                    break;

                case SDL_DROPFILE:
                    e = Event(EventType.DropFile);
                    e.filename = to!string(event.drop.file);
                    addEvent(e);
                    break;

                case SDL_QUIT:
                    exit();
                    e = Event(EventType.Quit);
                    addEvent(e);
                    break;

                default:
                    break;
            }
        }
    }

    protected int lastTime = 0;

    /// Updates the internal timer and computes delta time.
    void updateTimer()
    {
        int currentTime = SDL_GetTicks();
        auto elapsedTime = currentTime - lastTime;
        lastTime = currentTime;
        deltaTimeMs = elapsedTime;
        deltaTime = cast(double)(elapsedTime) * 0.001;
    }

    /**
     * Sets the mouse cursor position.
     *
     * Params:
     *   x = X coordinate.
     *   y = Y coordinate.
     */
    void setMouse(int x, int y)
    {
        SDL_WarpMouseInWindow(window, x, y);
        mouseX = x;
        mouseY = y;
    }

    /// Centers the mouse cursor in the window.
    void setMouseToCenter()
    {
        float x = (cast(float)windowWidth) / 2;
        float y = (cast(float)windowHeight) / 2;
        setMouse(cast(int)x, cast(int)y);
    }

    /**
     * Shows or hides the mouse cursor.
     *
     * Params:
     *   mode = true to show, false to hide.
     * Returns:
     *   SDL result code.
     */
    int showCursor(bool mode)
    {
        return SDL_ShowCursor(mode);
    }

    /**
     * Enables or disables relative mouse mode.
     *
     * Params:
     *   mode = true to enable, false to disable.
     * Returns:
     *   SDL result code.
     */
    int setRelativeMouseMode(bool mode)
    {
        return SDL_SetRelativeMouseMode(cast(SDL_bool)mode);
    }

     /// Returns the current window aspect ratio.
    float aspectRatio()
    {
        return cast(float)windowWidth / cast(float)windowHeight;
    }

    /// Resets all UP and DOWN input event states.
    void resetUpDown()
    {
        // reset all UP and DOWN events
        foreach(key; toReset)
        {
            *key = false;
        }
        toReset.removeBack(cast(uint)toReset.length);
    }
}

/**
 * Base class for objects that listen to and handle events.
 *
 * Description:
 * Inherit from `EventListener` and override the relevant event handler methods.
 * Call `processEvents` each frame to dispatch events to your handlers.
 */
abstract class EventListener: Owner
{
    /// The event manager used for polling events.
    EventManager eventManager;

    /// The input manager for input state queries.
    InputManager inputManager;

    /// If false, disables event processing.
    bool enabled = true;

    /**
     * Constructs an EventListener.
     *
     * Params:
     *   emngr = The event manager to use.
     *   owner = The owner object for memory management.
     */
    this(EventManager emngr, Owner owner)
    {
        super(owner);
        eventManager = emngr;
        if(emngr !is null)
            inputManager = emngr.inputManager;
    }

    /**
     * Generates a user event with the given code.
     *
     * Params:
     *   code = User event code.
     */
    protected void generateUserEvent(int code)
    {
        eventManager.generateUserEvent(code);
    }

    /**
     * Processes all pending events, dispatching them to handler methods.
     *
     * Params:
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvents(bool enableInputEvents = true)
    {
        if (!enabled)
            return;

        for (uint i = 0; i < eventManager.numEvents; i++)
        {
            Event* e = &eventManager.eventQueue[i];
            processEvent(e, enableInputEvents);
        }
    }

    /**
     * Processes a single event, dispatching it to the appropriate handler.
     *
     * Params:
     *   e = The event to process.
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvent(Event* e, bool enableInputEvents = true)
    {
        switch(e.type)
        {
            case EventType.KeyDown:
                if (enableInputEvents) onKeyDown(e.key);
                break;
            case EventType.KeyUp:
                if (enableInputEvents) onKeyUp(e.key);
                break;
            case EventType.TextInput:
                if (enableInputEvents) onTextInput(e.unicode);
                break;
            case EventType.MouseButtonDown:
                if (enableInputEvents) onMouseButtonDown(e.button);
                break;
            case EventType.MouseButtonUp:
                if (enableInputEvents) onMouseButtonUp(e.button);
                break;
            case EventType.MouseWheel:
                if (enableInputEvents) onMouseWheel(e.mouseWheelX, e.mouseWheelY);
                break;
            case EventType.JoystickButtonDown:
                if (enableInputEvents) onJoystickButtonDown(e.joystickButton);
                break;
            case EventType.JoystickButtonUp:
                if (enableInputEvents) onJoystickButtonUp(e.joystickButton);
                break;
            case EventType.ControllerButtonDown:
                if (enableInputEvents) onControllerButtonDown(e.controllerButton);
                break;
            case EventType.ControllerButtonUp:
                if (enableInputEvents) onControllerButtonUp(e.controllerButton);
                break;
            case EventType.ControllerAxisMotion:
                if (enableInputEvents) onControllerAxisMotion(e.controllerAxis, e.controllerAxisValue);
                break;
            case EventType.ControllerAdd:
                if (enableInputEvents) onControllerAdd(e.controllerDeviceIndex);
                break;
            case EventType.ControllerRemove:
                if (enableInputEvents) onControllerRemove(e.controllerDeviceIndex);
                break;
            case EventType.Resize:
                onResize(e.width, e.height);
                break;
            case EventType.FocusLoss:
                onFocusLoss();
                break;
            case EventType.FocusGain:
                onFocusGain();
                break;
            case EventType.Quit:
                onQuit();
                break;
            case EventType.FileChange:
                onFileChange(e.filename);
                break;
            case EventType.DropFile:
                if (enableInputEvents) onDropFile(e.filename);
                break;
            case EventType.UserEvent:
                onUserEvent(e.userCode);
                break;
            default:
                break;
        }
    }

    /// Called when a key is pressed.
    void onKeyDown(int key) {}

    /// Called when a key is released.
    void onKeyUp(int key) {}

    /// Called when text input is received.
    void onTextInput(dchar code) {}

    /// Called when a mouse button is pressed.
    void onMouseButtonDown(int button) {}

    /// Called when a mouse button is released.
    void onMouseButtonUp(int button) {}

    /// Called when the mouse wheel is scrolled.
    void onMouseWheel(int x, int y) {}

    /// Called when a joystick button is pressed.
    void onJoystickButtonDown(int button) {}

    /// Called when a joystick button is released.
    void onJoystickButtonUp(int button) {}

    /// Called when a controller button is pressed.
    void onControllerButtonDown(int button) {}

    /// Called when a controller button is released.
    void onControllerButtonUp(int button) {}

    /// Called when a controller axis is moved.
    void onControllerAxisMotion(int axis, float value) {}

    /// Called when a controller is added.
    void onControllerAdd(uint deviceIndex) {}

    /// Called when a controller is removed.
    void onControllerRemove(uint deviceIndex) {}

    /// Called when the window is resized.
    void onResize(int width, int height) {}

    /// Called when the window loses focus.
    void onFocusLoss() {}

    /// Called when the window gains focus.
    void onFocusGain() {}

    /// Called when a quit event is received.
    void onQuit() {}

    /// Called when a file change is detected.
    void onFileChange(string filename) {}

    /// Called when a file is dropped onto the window.
    void onDropFile(string filename) {}

    /// Called when a log event is manually triggered.
    void onAsyncLogEvent(LogLevel level, string message) {}

    /// Called when a user event is received.
    void onUserEvent(int code) {}
}
