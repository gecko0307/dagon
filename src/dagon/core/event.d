/*
Copyright (c) 2014-2026 Timur Gafarov, Mateusz Muszyński

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Primitives and tools for event-driven programming.
 *
 * Description:
 * The `dagon.core.event` module defines the `EventType` enumeration, 
 * the `Event` struct, the `EventManager` class for event polling and storing, 
 * and the `EventListener` base class for handling events.
 *
 * `EventManager` is single-threaded. For multi-threaded event/message passing,
 * use `MessageBroker`.
 *
 * Copyright: Timur Gafarov, Mateusz Muszyński 2014-2026
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov, Mateusz Muszyński
 */
module dagon.core.event;

import std.stdio;
import std.ascii;
import std.conv;
import std.file;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.utils;
import dlib.container.array;
import dlib.memory.arena;

import dagon.core.bindings;
import dagon.core.application;
import dagon.core.input;
import dagon.core.logger;
import dagon.core.messaging;
import dagon.core.graphicstablet;

/**
 * Maximum number of supported controllers.
 */
enum MAX_CONTROLLERS = 4;

/// Enumeration of supported game input device types.
enum GameInputDeviceType
{
    Undefined,
    Controller,
    Joystick
}

/// A structure that represents game input device.
struct GameInputDevice
{
    /// SDL device index.
    uint index;
    
    /// Device type.
    GameInputDeviceType type;
    
    /// Opened controller, if any.
    SDL_GameController* controller = null;
    
    /// Opened joystick, if any.
    SDL_Joystick* joystick = null;
    
    /// Opened haptic (force feedback) device, if any.
    SDL_Haptic* haptic = null;
    
    ///
    bool mappingPresent = false;
    
    /// A maximum that controller axis value is clamped to (for normalization in 0..1 range).
    int axisThreshold = 32639;
    
    /// Vibration support.
    bool hasRumble = false;
    
    /// Device name.
    string name;
}

/**
 * All supported event types in Dagon.
 */
enum EventType
{
    Cancelled = 0,
    KeyDown,
    KeyUp,
    TextInput,
    LocaleChange,
    KeyboardLayoutChange,
    MouseMotion,
    MouseButtonDown,
    MouseButtonUp,
    MouseWheel,
    JoystickButtonDown,
    JoystickButtonUp,
    JoystickAxisMotion,
    ControllerButtonDown,
    ControllerButtonUp,
    ControllerAxisMotion,
    ControllerAdd,
    ControllerRemove,
    PenMotion,
    Resize,
    FocusLoss,
    FocusGain,
    Quit,
    FileChange,
    DropFile,
    Log,
    Message,
    Task,
    Timer,
    HardwareSpecific,
    UserEvent
}

/**
 * A delegate that can be used as an asynchronous callback in task events.
 * `executor` parameter is meant to be the object that executes the task.
 * `payload` is user-defined pointer passed with the event.
 */
alias TaskCallback = void delegate(Object executor, void* payload);

/**
 * Represents a single event in the Dagon event system.
 * Contains event type and relevant data for the event.
 */
struct Event
{
    EventType type;
    int key;
    dchar unicode;
    int button;
    int joystickButton;
    int joystickAxis;
    float joystickAxisValue;
    int controllerButton;
    int controllerAxis;
    float controllerAxisValue;
    int deviceIndex = -1;
    GameInputDeviceType deviceType;
    int x;
    int y;
    int width;
    int height;
    int userCode;
    int mouseWheelX;
    int mouseWheelY;
    float pressure;
    LogLevel logLevel;
    int domain;
    int timerID;
    string filename;
    string message;
    string sender;
    string recipient;
    TaskCallback callback;
    void* payload;
}

/**
 * Communication layer `Event` is subject to.
 * Circular - event goes to both message broker and main-thread event listeners;
 * ITC - event goes to the message broker;
 * MainThread - event goes to main-thread event listeners.
 */
enum MessageDomain
{
    Circular = 0,
    ITC = -1,
    MainThread = 1
}

/**
 * Constructs a message event.
 */
Event messageEvent(string sender, string recipient, string message, void* payload, int domain = MessageDomain.ITC)
{
    Event e;
    e.type = EventType.Message;
    e.sender = sender;
    e.recipient = recipient;
    e.message = message;
    e.payload = payload;
    e.domain = domain;
    return e;
}

/**
 * Constructs a task event.
 */
Event taskEvent(string sender, string recipient, TaskCallback callback, void* payload, int domain = MessageDomain.ITC)
{
    Event e;
    e.type = EventType.Task;
    e.sender = sender;
    e.recipient = recipient;
    e.callback = callback;
    e.payload = payload;
    e.domain = domain;
    return e;
}

/**
 * Interface for input event emitters.
 * Implementations of this interface can generate events using `EventManager.addEvent` method.
 */
interface InputDevice
{
    /// Initialize the device. Returns false on failure and true on success.
    bool initialize(EventManager eventManager);
    
    /// Emits next pending event and returns true if there are more events to poll. Otherwise returns false.
    bool pollEvents();
}

/**
 * Manages event polling, event queue and input state.
 *
 * Description:
 * EventManager polls SDL events and aggregates them in a queue. It also tracks
 * keyboard, mouse, joystick and controller state. Provides methods for generating
 * custom events.
 */
class EventManager: Owner
{
    /// Application object that owns this EventManager.
    Application application;
    
    /// A pointer to main application window.
    SDL_Window* window;
    
    /// Maximum number of simultaneous events.
    enum maxNumEvents = 50;
    
    /**
     * Inbox event queue. All synchronous events from SDL (such as user input) go here.
     * Inbox queue is cleared at the beginning of each event loop iteration,
     * so for emitting custom events, outboxEventQueue should be used.
     */
    Event[maxNumEvents] inboxEventQueue;
    alias eventQueue = inboxEventQueue;
    
    /// Number of events in the inbox queue.
    uint numInboxEvents;
    alias numEvents = numInboxEvents;
    
    /**
     * Outbox event queue. All external events (user events, messages, tasks) should go here.
     */
    Event[maxNumEvents] outboxEventQueue;
    
    /// Number of events in the outbox queue.
    uint numOutboxEvents = 0;
    
    /// Used by Application to indicate activity. Set to false to stop the main loop.
    bool running = true;
    
    /// Keyboard key is currently pressed/released.
    bool[512] keyPressed = false;
    
    /// Keyboard key went up this frame (valid only if `trackUpDownState` is true).
    bool[512] keyUp = false;
    
    /// Keyboard key went down this frame (valid only if `trackUpDownState` is true).
    bool[512] keyDown = false;
    
    /// Mouse button is currently pressed/released.
    bool[255] mouseButtonPressed = false;
    
    /// Mouse button went up this frame (valid only if `trackUpDownState` is true).
    bool[255] mouseButtonUp = false;
    
    /// Mouse button went down this frame (valid only if `trackUpDownState` is true).
    bool[255] mouseButtonDown = false;
    
    /// Joystick button is currently pressed/released.
    bool[255][MAX_CONTROLLERS] joystickButtonPressed = false;
    
    /// Joystick button went up this frame (valid only if `trackUpDownState` is true).
    bool[255][MAX_CONTROLLERS] joystickButtonUp = false;
    
    /// Joystick button went down this frame (valid only if `trackUpDownState` is true).
    bool[255][MAX_CONTROLLERS] joystickButtonDown = false;
    
    /// Controller button is currently pressed/released.
    bool[255][MAX_CONTROLLERS] controllerButtonPressed = false;
    
    /// Controller button went up this frame (valid only if `trackUpDownState` is true).
    bool[255][MAX_CONTROLLERS] controllerButtonUp = false;
    
    /// Controller button went down this frame (valid only if `trackUpDownState` is true).
    bool[255][MAX_CONTROLLERS] controllerButtonDown = false;
    
    /// Whether to update up/down states for keys and buttons.
    bool trackUpDownState = false;
    
    protected
    {
        bool needToResetKeyUp = false;
        bool needToResetKeyDown = false;
        bool needToResetMouseUp = false;
        bool needToResetMouseDown = false;
        bool[MAX_CONTROLLERS] needToResetJoystickUp = false;
        bool[MAX_CONTROLLERS] needToResetJoystickDown = false;
        bool[MAX_CONTROLLERS] needToResetControllerUp = false;
        bool[MAX_CONTROLLERS] needToResetControllerDown = false;
    }
    
    /// Mouse pointer's X-coordinate relative to the window.
    int mouseX = 0;
    
    /// Mouse pointer's Y-coordinate relative to the window.
    int mouseY = 0;
    
    /// Relative change of the X-coordinate of the mouse pointer's position.
    int mouseRelX = 0;
    
    /// Relative change of the Y-coordinate of the mouse pointer's position.
    int mouseRelY = 0;
    
    /// Switch key repeat.
    bool enableKeyRepeat = false;
    
    /// Time in seconds since the last `updateTimer` call.
    double deltaTime = 0.0;
    
    /// Time in milliseconds since the last `updateTimer` call.
    ulong deltaTimeMs = 0;
    
    /// Width of the screen.
    uint displayWidth;
    
    /// Height of the screen.
    uint displayHeight;
    
    /// Application's main window width.
    int windowWidth;
    
    /// Application's main window height.
    int windowHeight;
    
    /// Application's main window drawable width.
    int drawableWidth;
    
    /// Application's main window drawable height.
    int drawableHeight;
    
    /// Application's main window's X-coordinate.
    int windowX = 0;
    
    /// Application's main window's Y-coordinate.
    int windowY = 0;
    
    /// Application's main window focus state.
    bool windowFocused = true;
    
    /// Window manager info obtained from SDL.
    SDL_SysWMinfo wmInfo;
    
    /// Opened controllers/joysticks.
    GameInputDevice[MAX_CONTROLLERS] gameInputDevices;
    
    /// Number of recognized controllers/joysticks.
    uint numGameInputDevices = 0;
    
    /// Get currently opened SDL controller by device index.
    SDL_GameController* controller(uint deviceIndex)
    {
        if (deviceIndex < gameInputDevices.length)
            return gameInputDevices[deviceIndex].controller;
        else
            return null;
    }
    
    /// Get currently opened SDL joystick by device index.
    SDL_Joystick* joystick(uint deviceIndex)
    {
        if (deviceIndex < gameInputDevices.length)
            return gameInputDevices[deviceIndex].joystick;
        else
            return null;
    }
    
    /// A maximum that controller axis value is clamped to (for normalization in 0..1 range).
    int controllerAxisThreshold = 32639;
    
    /// Controller vibration support.
    bool controllerHasRumble(uint deviceIndex)
    {
        if (deviceIndex < gameInputDevices.length)
            return gameInputDevices[deviceIndex].hasRumble;
        else
            return false;
    }
    
    /// Get controller name.
    string controllerName(uint deviceIndex)
    {
        if (deviceIndex < gameInputDevices.length)
            return gameInputDevices[deviceIndex].name;
        else
            return "";
    }
    
    /// Get joystick name.
    alias joystickName = controllerName;
    
    /// Configurable input manager.
    InputManager inputManager;
    
    /// Message broker for distributing messages and scheduling tasks.
    MessageBroker messageBroker;
    
    /**
     * Temporary heap allocator to create short-living objects for custom events.
     * tmpHeap is invalidated each step when there are no more pending outbox events.
     * It is mostly used to create payload data which should be immediately byte-copied 
     * when event is dispatched.
     */
    Arena tmpHeap;
    
    protected Array!InputDevice inputDevices;
    
    /// `PenMotion` events emitter.
    GraphicsTablet graphicsTablet;
    
    /// Event dispatching hook. Provide your delegate to receive SDL events directly.
    void delegate(SDL_Event* event) onProcessEvent;
    
    protected ulong lastTime = 0;

    /**
     * Constructs an EventManager for the given `Application`.
     *
     * Params:
     *   app = application object.
     */
    this(Application app)
    {
        super(app);
        
        application = app;
        
        window = app.window;
        
        windowWidth = app.windowWidth;
        windowHeight = app.windowHeight;
        
        drawableWidth = app.drawableWidth;
        drawableHeight = app.drawableHeight;
        
        SDL_GetWindowPosition(window, &windowX, &windowY);
        
        displayWidth = app.displayWidth;
        displayHeight = app.displayHeight;
        
        SDL_VERSION(&wmInfo.version_);
        SDL_GetWindowWMInfo(window, &wmInfo);
        
        if (exists("gamecontrollerdb.txt"))
            SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt");
        
        numGameInputDevices = SDL_NumJoysticks();
        
        inputManager = New!InputManager(this);
        
        messageBroker = New!MessageBroker(this);
        
        graphicsTablet = New!GraphicsTablet(this);
        if (graphicsTablet.initialize(this))
            addInputDevice(graphicsTablet);
        else
            logWarning("Graphics tablet is not available");
        
        tmpHeap = New!Arena(4 * 1024, this);
        
        lastTime = SDL_GetTicks64();
    }

    /// Destructor. Cleans up resources.
    ~this()
    {
        Delete(inputManager);
        inputDevices.free();
    }

    /// Signals the Application to stop running.
    void exit()
    {
        running = false;
    }

    /// Adds an input device to the event emitters list.
    void addInputDevice(InputDevice device)
    {
        inputDevices.append(device);
    }

    /**
     * Adds a new event to the inbox queue.
     *
     * Params:
     *   e = The event to add.
     */
    void addEvent(Event e) nothrow
    {
        if (numEvents < maxNumEvents)
        {
            eventQueue[numEvents] = e;
            numEvents++;
        }
    }
    
    /**
     * Adds a new event to the outbox queue.
     *
     * Params:
     *   e = The event to add.
     */
    void queueEvent(Event e) nothrow
    {
        if (numOutboxEvents < maxNumEvents)
        {
            outboxEventQueue[numOutboxEvents] = e;
            numOutboxEvents++;
        }
    }

    /**
     * Generates a file change event for the given filename.
     *
     * Params:
     *   filename = The changed file's name.
     */
    void queueFileChangeEvent(string filename) nothrow
    {
        Event e = Event(EventType.FileChange);
        e.filename = filename;
        queueEvent(e);
    }

    /**
     * Generates a user event with the given code.
     *
     * Params:
     *   code = User event code.
     *   payload = Pointer to arbitrary data, can be null.
     */
    void queueUserEvent(int code, void* payload = null) nothrow
    {
        Event e = Event(EventType.UserEvent);
        e.userCode = code;
        e.payload = payload;
        queueEvent(e);
    }

    /**
     * Prints to the logger asynchronically using the event queue.
     * This method is also useful to log from nothrow functions,
     * because the logger itself is not nothrow.
     *
     * Params:
     *   level   = Log level.
     *   message = Log message.
     */
    void queueLogEvent(LogLevel level, string message) nothrow
    {
        Event e = Event(EventType.Log);
        e.logLevel = level;
        e.message = message;
        queueEvent(e);
    }
    
    /**
     * Opens a game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to open.
     */
    GameInputDevice* gameInputDeviceOpen(uint deviceIndex)
    {
        gameInputDeviceClose(deviceIndex);
        GameInputDevice* device = &gameInputDevices[deviceIndex];
        device.index = deviceIndex;
        
        if (SDL_IsGameController(deviceIndex))
        {
            device.type = GameInputDeviceType.Controller;
            device.controller = SDL_GameControllerOpen(deviceIndex);
            auto name = SDL_GameControllerName(device.controller);
            if (name)
            {
                device.name = name.to!string;
                logInfo("Game controller: ", device.name);
            }
            
            if (SDL_GameControllerMapping(device.controller))
                device.mappingPresent = true;
            else
            {
                device.mappingPresent = false;
                logWarning("No mapping found for controller!");
            }
            
            SDL_GameControllerEventState(SDL_ENABLE);
            device.joystick = SDL_GameControllerGetJoystick(device.controller);
            device.axisThreshold = controllerAxisThreshold;
            device.hasRumble = cast(bool)SDL_GameControllerHasRumble(device.controller);
            device.haptic = SDL_HapticOpenFromJoystick(device.joystick);
        }
        else
        {
            device.type = GameInputDeviceType.Joystick;
            device.joystick = SDL_JoystickOpen(deviceIndex);
            auto name = SDL_JoystickName(device.joystick);
            if (name)
            {
                device.name = name.to!string;
                logInfo("Joystick: ", device.name);
            }
            device.controller = null;
            device.axisThreshold = controllerAxisThreshold;
            device.mappingPresent = false;
            device.haptic = SDL_HapticOpenFromJoystick(device.joystick);
            if (device.haptic)
                device.hasRumble = (SDL_HapticRumbleInit(device.haptic) != 0);
            else
                device.hasRumble = false;
        }
        
        return device;
    }
    
    /**
     * Closes the game controller or joystick.
     */
    void gameInputDeviceClose(uint deviceIndex)
    {
        GameInputDevice* device = &gameInputDevices[deviceIndex];
        
        if (device.type == GameInputDeviceType.Joystick)
        {
            if (device.joystick)
                SDL_JoystickClose(device.joystick);
        }
        else if (device.type == GameInputDeviceType.Controller)
        {
            if (device.controller)
                SDL_GameControllerClose(device.controller);
        }
    }

    /// Returns true if a game controller is available.
    bool gameControllerAvailable()
    {
        foreach(ref device; gameInputDevices)
            if (device.controller !is null)
                return true;
        return false;
    }

    /// Returns true if a joystick is available.
    bool joystickAvailable()
    {
        foreach(ref device; gameInputDevices)
            if (device.joystick !is null)
                return true;
        return false;
    }

    /**
     * Gets the normalized value of a game controller axis.
     *
     * Params:
     *   deviceIndex = Game input device index.
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float gameControllerAxis(uint deviceIndex, int axis)
    {
        if (deviceIndex >= gameInputDevices.length)
            return 0.0f;

        auto contr = gameInputDevices[deviceIndex].controller;
        if (contr is null)
            return 0.0f;
        
        int axisVal = SDL_GameControllerGetAxis(contr, cast(SDL_GameControllerAxis)axis);
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }

    /**
     * Gets the normalized value of a joystick axis.
     *
     * Params:
     *   deviceIndex = Game input device index.
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float joystickAxis(uint deviceIndex, int axis)
    {
        if (deviceIndex >= gameInputDevices.length)
            return 0.0f;
        auto device = gameInputDevices[deviceIndex];
        int axisVal = 0;
        auto joy = device.joystick;
        auto contr = device.controller;
        if (joy)
            axisVal = SDL_JoystickGetAxis(joy, axis);
        else if (contr)
            axisVal = SDL_GameControllerGetAxis(contr, cast(SDL_GameControllerAxis)axis);
        
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }
    
    /**
     * Triggers controller rumble (vibration) if supported.
     *
     * Params:
     *   deviceIndex = Game input device index.
     *   lowFreq = Low frequency rumble intensity.
     *   hiFreg = High frequency rumble intensity.
     *   duration = Duration in seconds.
     */
    void gameControllerRumble(uint deviceIndex, uint lowFreq, uint hiFreg, float duration)
    {
        if (deviceIndex >= gameInputDevices.length)
            return;
        auto device = gameInputDevices[deviceIndex];
        if (device.controller && device.hasRumble)
        {
            SDL_GameControllerRumble(device.controller,
                cast(ushort)clamp(lowFreq, 0, ushort.max),
                cast(ushort)clamp(hiFreg, 0, ushort.max),
                cast(uint)(duration * 1000.0f));
        }
    }

    /// Polls and processes all pending events.
    void update()
    {
        numEvents = 0;

        if (numOutboxEvents == 0)
            tmpHeap.reset();

        mouseRelX = 0;
        mouseRelY = 0;
        
        SDL_GetWindowPosition(window, &windowX, &windowY);
        
        // Aggregate user-emitted events
        for (uint i = 0; i < numOutboxEvents; i++)
        {
            Event e = outboxEventQueue[i];
            if (e.type == EventType.Log)
                log(e.logLevel, e.message);
            else if (e.type == EventType.Task && !messageBroker.canRunTasks)
                e.callback(null, e.payload);
            else
                addEvent(e);
        }
        
        numOutboxEvents = 0;
        
        if (trackUpDownState)
            resetUpDown();

        SDL_Event event;

        while(SDL_PollEvent(&event))
        {
            if (onProcessEvent) onProcessEvent(&event);
            Event e;
            switch (event.type)
            {
                case SDL_KEYDOWN:
                    if (event.key.repeat && !enableKeyRepeat)
                        break;

                    keyPressed[event.key.keysym.scancode] = true;
                    
                    if (trackUpDownState)
                    {
                        keyDown[event.key.keysym.scancode] = true;
                        needToResetKeyDown = true;
                    }

                    e = Event(EventType.KeyDown);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_KEYUP:
                    keyPressed[event.key.keysym.scancode] = false;
                    
                    if (trackUpDownState)
                    {
                        keyUp[event.key.keysym.scancode] = true;
                        needToResetKeyUp = true;
                    }

                    e = Event(EventType.KeyUp);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_TEXTINPUT:
                    e = Event(EventType.TextInput);
                    char[] input = event.text.text;
                    if ((input[0] & 0x80) == 0)
                        e.unicode = input[0];
                    else if ((input[0] & 0xE0) == 0xC0)
                        e.unicode = ((input[0] & 0x1F) << 6) | (input[1] & 0x3F);
                    else if ((input[0] & 0xF0) == 0xE0)
                        e.unicode = ((input[0] & 0x0F) << 12) | ((input[1] & 0x3F) << 6) | (input[2] & 0x3F);
                    else if ((input[0] & 0xF8) == 0xF0)
                        e.unicode = (((input[0] & 0x0F) << 18) | ((input[1] & 0x3F) << 12) | ((input[2] & 0x3F) << 6) | (input[3] & 0x3F));
                    addEvent(e);
                    break;

                case SDL_LOCALECHANGED:
                    e = Event(EventType.LocaleChange);
                    //application.locale = systemLocale(); // do we need this?
                    addEvent(e);
                    break;

                case SDL_MOUSEMOTION:
                    mouseX = event.motion.x;
                    mouseY = event.motion.y;
                    mouseRelX = event.motion.xrel;
                    mouseRelY = event.motion.yrel;
                    break;

                case SDL_MOUSEBUTTONDOWN:
                    mouseButtonPressed[event.button.button] = true;
                    
                    if (trackUpDownState)
                    {
                        mouseButtonDown[event.button.button] = true;
                        needToResetMouseDown = true;
                    }
                    
                    e = Event(EventType.MouseButtonDown);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEBUTTONUP:
                    mouseButtonPressed[event.button.button] = false;
                    
                    if (trackUpDownState)
                    {
                        mouseButtonUp[event.button.button] = true;
                        needToResetMouseUp = true;
                    }
                    
                    e = Event(EventType.MouseButtonUp);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEWHEEL:
                    e = Event(EventType.MouseWheel);
                    e.mouseWheelX = event.wheel.x;
                    e.mouseWheelY = event.wheel.y;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONDOWN:
                    uint deviceIndex = event.cdevice.which;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        if (deviceIndex < MAX_CONTROLLERS)
                        {
                            joystickButtonPressed[deviceIndex][event.jbutton.button] = true;
                            if (trackUpDownState)
                            {
                                joystickButtonDown[deviceIndex][event.jbutton.button] = true;
                                needToResetJoystickDown[deviceIndex] = true;
                            }
                        }
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        if (deviceIndex < MAX_CONTROLLERS)
                        {
                            joystickButtonPressed[deviceIndex][event.jbutton.button] = false;
                            if (trackUpDownState)
                            {
                                joystickButtonUp[deviceIndex][event.jbutton.button] = true;
                                needToResetJoystickUp[deviceIndex] = true;
                            }
                        }
                    }
                    e.joystickButton = event.jbutton.button;
                    e.deviceIndex = deviceIndex;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONUP:
                    uint deviceIndex = event.cdevice.which;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        if (deviceIndex < MAX_CONTROLLERS)
                        {
                            joystickButtonPressed[deviceIndex][event.jbutton.button] = true;
                            if (trackUpDownState)
                            {
                                joystickButtonDown[deviceIndex][event.jbutton.button] = true;
                                needToResetJoystickDown[deviceIndex] = true;
                            }
                        }
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        if (deviceIndex < MAX_CONTROLLERS)
                        {
                            joystickButtonPressed[deviceIndex][event.jbutton.button] = false;
                            if (trackUpDownState)
                            {
                                joystickButtonUp[deviceIndex][event.jbutton.button] = true;
                                needToResetJoystickUp[deviceIndex] = true;
                            }
                        }
                    }
                    e.joystickButton = event.jbutton.button;
                    e.deviceIndex = deviceIndex;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONDOWN:
                    uint deviceIndex = event.cdevice.which;
                    if (deviceIndex < MAX_CONTROLLERS)
                    {
                        controllerButtonPressed[deviceIndex][event.cbutton.button] = true;
                        if (trackUpDownState)
                        {
                            controllerButtonDown[deviceIndex][event.cbutton.button] = true;
                            needToResetControllerDown[deviceIndex] = true;
                        }
                    }
                    
                    e = Event(EventType.ControllerButtonDown);
                    e.controllerButton = event.cbutton.button;
                    e.deviceIndex = deviceIndex;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONUP:
                    uint deviceIndex = event.cdevice.which;
                    if (deviceIndex < MAX_CONTROLLERS)
                    {
                        controllerButtonPressed[deviceIndex][event.cbutton.button] = false;
                        if (trackUpDownState)
                        {
                            controllerButtonUp[deviceIndex][event.cbutton.button] = true;
                            needToResetControllerUp[deviceIndex] = true;
                        }
                    }
                    
                    e = Event(EventType.ControllerButtonUp);
                    e.controllerButton = event.cbutton.button;
                    e.deviceIndex = deviceIndex;
                    addEvent(e);
                    break;

                case SDL_JOYAXISMOTION:
                    // TODO: add state modification
                    e = Event(EventType.JoystickAxisMotion);
                    e.joystickAxis = event.caxis.axis;
                    int axisValue = event.caxis.value;
                    auto joy = joystick(event.cdevice.which);
                    if (joy)
                    {
                        axisValue = SDL_JoystickGetAxis(joy, e.joystickAxis);
                    }
                    e.joystickAxisValue =
                        cast(float)clamp(axisValue, -controllerAxisThreshold, controllerAxisThreshold) / 
                        cast(float)controllerAxisThreshold;
                    e.deviceIndex = event.cdevice.which;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERAXISMOTION:
                    // TODO: add state modification
                    e = Event(EventType.ControllerAxisMotion);
                    e.controllerAxis = event.caxis.axis;
                    int axisValue = event.caxis.value;
                    auto contr = controller(event.cdevice.which);
                    if (contr)
                    {
                        if (e.controllerAxis == 0)
                            axisValue = SDL_GameControllerGetAxis(contr, SDL_CONTROLLER_AXIS_LEFTY);
                        if (e.controllerAxis == 1)
                            axisValue = SDL_GameControllerGetAxis(contr, SDL_CONTROLLER_AXIS_LEFTX);
                    }
                    e.controllerAxisValue =
                        cast(float)clamp(axisValue, -controllerAxisThreshold, controllerAxisThreshold) / 
                        cast(float)controllerAxisThreshold;
                    e.deviceIndex = event.cdevice.which;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEADDED:
                    e = Event(EventType.ControllerAdd);
                    e.deviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                    {
                        auto device = gameInputDeviceOpen(event.cdevice.which);
                        e.deviceType = device.type;
                    }
                    addEvent(e);
                    numGameInputDevices = SDL_NumJoysticks();
                    break;

                case SDL_CONTROLLERDEVICEREMOVED:
                    e = Event(EventType.ControllerRemove);
                    e.deviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                    {
                        gameInputDeviceClose(event.cdevice.which);
                    }
                    addEvent(e);
                    numGameInputDevices = SDL_NumJoysticks();
                    break;

                case SDL_WINDOWEVENT:
                    if (event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)
                    {
                        windowWidth = event.window.data1;
                        windowHeight = event.window.data2;
                        application.windowWidth = windowWidth;
                        application.windowHeight = windowHeight;
                        if (!application.stereoRendering)
                        {
                            SDL_GL_GetDrawableSize(window, &drawableWidth, &drawableHeight);
                            application.drawableWidth = drawableWidth;
                            application.drawableHeight = drawableHeight;
                        }
                        e = Event(EventType.Resize);
                        e.width = windowWidth;
                        e.height = windowHeight;
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED)
                    {
                        e = Event(EventType.FocusGain);
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_LOST)
                    {
                        e = Event(EventType.FocusLoss);
                        addEvent(e);
                    }
                    break;

                case SDL_DROPFILE:
                    e = Event(EventType.DropFile);
                    e.filename = to!string(event.drop.file);
                    addEvent(e);
                    break;

                case SDL_KEYMAPCHANGED:
                    e = Event(EventType.KeyboardLayoutChange);
                    addEvent(e);
                    break;

                case SDL_QUIT:
                    exit();
                    e = Event(EventType.Quit);
                    addEvent(e);
                    break;

                default:
                    break;
            }
        }
        
        foreach(device; inputDevices)
        {
            while(device.pollEvents())
            {
                //
            }
        }
        
        messageBroker.update();
    }

    /// Updates the internal timer and computes delta time.
    void updateTimer()
    {
        ulong currentTime = SDL_GetTicks64();
        deltaTimeMs = currentTime - lastTime;
        lastTime = currentTime;
        deltaTime = cast(double)(deltaTimeMs) * 0.001;
    }

    /**
     * Sets the mouse cursor position.
     *
     * Params:
     *   x = X coordinate.
     *   y = Y coordinate.
     */
    void setMouse(int x, int y)
    {
        SDL_WarpMouseInWindow(window, x, y);
        mouseX = x;
        mouseY = y;
    }

    /// Centers the mouse cursor in the window.
    void setMouseToCenter()
    {
        float x = (cast(float)windowWidth) / 2;
        float y = (cast(float)windowHeight) / 2;
        setMouse(cast(int)x, cast(int)y);
    }

    /**
     * Shows or hides the mouse cursor.
     *
     * Params:
     *   mode = true to show, false to hide.
     * Returns:
     *   SDL result code.
     */
    int showCursor(bool mode)
    {
        return SDL_ShowCursor(mode);
    }

    /**
     * Enables or disables relative mouse mode.
     *
     * Params:
     *   mode = true to enable, false to disable.
     * Returns:
     *   SDL result code.
     */
    int setRelativeMouseMode(bool mode)
    {
        return SDL_SetRelativeMouseMode(cast(SDL_bool)mode);
    }

    /// Returns the current window aspect ratio.
    float aspectRatio()
    {
        return cast(float)windowWidth / cast(float)windowHeight;
    }

    /// Resets all up and down input event states.
    void resetUpDown()
    {
        if (needToResetKeyUp)
        {
            keyUp[] = false;
            needToResetKeyUp = false;
        }
        
        if (needToResetKeyDown)
        {
            keyDown[] = false;
            needToResetKeyDown = false;
        }
        
        if (needToResetMouseUp)
        {
            mouseButtonUp[] = false;
            needToResetMouseUp = false;
        }
        
        if (needToResetMouseDown)
        {
            mouseButtonDown[] = false;
            needToResetMouseDown = false;
        }
        
        for (uint i = 0; i < MAX_CONTROLLERS; i++)
        {
            if (needToResetJoystickUp[i])
            {
                joystickButtonUp[i][] = false;
                needToResetJoystickUp[i] = false;
            }
            
            if (needToResetJoystickDown[i])
            {
                joystickButtonDown[i][] = false;
                needToResetJoystickDown[i] = false;
            }
            
            if (needToResetControllerUp[i])
            {
                controllerButtonUp[i][] = false;
                needToResetControllerUp[i] = false;
            }
            
            if (needToResetControllerDown[i])
            {
                controllerButtonDown[i][] = false;
                needToResetControllerDown[i] = false;
            }
        }
    }
}

/**
 * Base class for event dispatchers.
 *
 * Description:
 * Inherit from `EventDispatcher` and override the relevant event handler methods.
 * Call `processEvents` to dispatch an event to your handlers.
 */
abstract class EventDispatcher: Owner
{
    /// Addressing domain of this dispatcher.
    protected int domain = MessageDomain.MainThread;
    
    /// Address of this dispatcher.
    string address = "";
    
    /**
     * Constructs an EventDispatcher.
     *
     * Params:
     *   owner = owner object.
     */
    this(Owner owner)
    {
        super(owner);
    }
    
    /**
     * Processes a single event, dispatching it to the appropriate handler.
     *
     * Params:
     *   e = The event to process.
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvent(Event* e, bool enableInputEvents = true)
    {
        switch(e.type)
        {
            case EventType.KeyDown:
                if (enableInputEvents) onKeyDown(e.key);
                break;
            case EventType.KeyUp:
                if (enableInputEvents) onKeyUp(e.key);
                break;
            case EventType.TextInput:
                if (enableInputEvents) onTextInput(e.unicode);
                break;
            case EventType.MouseButtonDown:
                if (enableInputEvents) onMouseButtonDown(e.button);
                break;
            case EventType.MouseButtonUp:
                if (enableInputEvents) onMouseButtonUp(e.button);
                break;
            case EventType.MouseWheel:
                if (enableInputEvents) onMouseWheel(e.mouseWheelX, e.mouseWheelY);
                break;
            case EventType.JoystickButtonDown:
                if (enableInputEvents) onJoystickButtonDown(e.deviceIndex, e.joystickButton);
                break;
            case EventType.JoystickButtonUp:
                if (enableInputEvents) onJoystickButtonUp(e.deviceIndex, e.joystickButton);
                break;
            case EventType.JoystickAxisMotion:
                if (enableInputEvents) onJoystickAxisMotion(e.deviceIndex, e.joystickAxis, e.joystickAxisValue);
                break;
            case EventType.ControllerButtonDown:
                if (enableInputEvents) onControllerButtonDown(e.deviceIndex, e.controllerButton);
                break;
            case EventType.ControllerButtonUp:
                if (enableInputEvents) onControllerButtonUp(e.deviceIndex, e.controllerButton);
                break;
            case EventType.ControllerAxisMotion:
                if (enableInputEvents) onControllerAxisMotion(e.deviceIndex, e.controllerAxis, e.controllerAxisValue);
                break;
            case EventType.ControllerAdd:
                onControllerAdd(e.deviceIndex, e.deviceType);
                break;
            case EventType.ControllerRemove:
                onControllerRemove(e.deviceIndex);
                break;
            case EventType.PenMotion:
                if (enableInputEvents) onPenMotion(e.x, e.y, e.pressure);
                break;
            case EventType.Resize:
                onResize(e.width, e.height);
                break;
            case EventType.FocusLoss:
                onFocusLoss();
                break;
            case EventType.FocusGain:
                onFocusGain();
                break;
            case EventType.Quit:
                onQuit();
                break;
            case EventType.LocaleChange:
                onLocaleChange();
                break;
            case EventType.FileChange:
                onFileChange(e.filename);
                break;
            case EventType.DropFile:
                if (enableInputEvents) onDropFile(e.filename);
                break;
            case EventType.KeyboardLayoutChange:
                if (enableInputEvents) onKeyboardLayoutChange();
                break;
            case EventType.Message:
                if (e.domain * domain >= 0) // if domains are same
                    if (e.recipient.length == 0 || e.recipient == address)
                        onMessage(e.domain, e.sender, e.message, e.payload);
                break;
            case EventType.Task:
                if (e.domain * domain >= 0) // if domains are same
                    if (e.recipient.length == 0 || e.recipient == address)
                        onTask(e.domain, e.sender, e.callback, e.payload);
                break;
            case EventType.Timer:
                onTimerEvent(e.timerID, e.userCode);
                break;
            case EventType.HardwareSpecific:
                onHardwareSpecificEvent(e.deviceIndex, e.userCode, e.payload);
                break;
            case EventType.UserEvent:
                onUserEvent(e.userCode, e.payload);
                break;
            default:
                break;
        }
    }

    /// Called when a key is pressed.
    void onKeyDown(int key) {}

    /// Called when a key is released.
    void onKeyUp(int key) {}

    /// Called when text input is received.
    void onTextInput(dchar code) {}

    /// Called when a mouse button is pressed.
    void onMouseButtonDown(int button) {}

    /// Called when a mouse button is released.
    void onMouseButtonUp(int button) {}

    /// Called when the mouse wheel is scrolled.
    void onMouseWheel(int x, int y) {}

    /// Called when a joystick button is pressed.
    void onJoystickButtonDown(uint deviceIndex, int button) {}

    /// Called when a joystick button is released.
    void onJoystickButtonUp(uint deviceIndex, int button) {}
    
    /// Called when a joystick axis is moved.
    void onJoystickAxisMotion(uint deviceIndex, int axis, float value) {}

    /// Called when a controller button is pressed.
    void onControllerButtonDown(uint deviceIndex, int button) {}

    /// Called when a controller button is released.
    void onControllerButtonUp(uint deviceIndex, int button) {}

    /// Called when a controller axis is moved.
    void onControllerAxisMotion(uint deviceIndex, int axis, float value) {}

    /// Called when a controller is added.
    void onControllerAdd(uint deviceIndex, GameInputDeviceType deviceType) {}

    /// Called when a controller is removed.
    void onControllerRemove(uint deviceIndex) {}
    
    /// Called when a pen (stilus) is moved over a graphics tablet.
    void onPenMotion(int x, int y, float pressure) {}

    /// Called when the window is resized.
    void onResize(int width, int height) {}

    /// Called when the window loses focus.
    void onFocusLoss() {}

    /// Called when the window gains focus.
    void onFocusGain() {}

    /// Called when a quit event is received.
    void onQuit() {}

    /// Called when a user locale preferences have changed.
    void onLocaleChange() {}

    /// Called when a file change is detected.
    void onFileChange(string filename) {}

    /// Called when a file is dropped onto the window.
    void onDropFile(string filename) {}

    /// Called when the user switches system keyboard layout.
    void onKeyboardLayoutChange() {}

    /// Called when a message event is received.
    void onMessage(int domain, string sender, string message, void* payload) {}
    
    /// Called when a task event is received.
    void onTask(int domain, string sender, TaskCallback callback, void* payload) {}
    
    /// Called when a timer event is received.
    void onTimerEvent(int timerID, int userCode) {}
    
    /// Called when a hardware specific event is received from a custom InputDevice.
    void onHardwareSpecificEvent(uint deviceIndex, int code, void* payload) {}

    /// Called when a user event is received.
    void onUserEvent(int code, void* payload) {}
}

/**
 * Base class for single-threaded event listeners.
 */
abstract class EventListener: EventDispatcher
{
    /// The event manager used for polling events.
    EventManager eventManager;
    
    /// The input manager for input state queries.
    InputManager inputManager;
    
    /// If false, disables event processing.
    bool enabled = true;
    
    /**
     * Constructs an EventListener.
     *
     * Params:
     *   emngr = The event manager to use.
     *   owner = The owner object for memory management.
     */
    this(EventManager emngr, Owner owner)
    {
        super(owner);
        domain = MessageDomain.MainThread;
        eventManager = emngr;
        if(emngr !is null)
            inputManager = emngr.inputManager;
    }

    /**
     * Queues a user event with the given code and payload pointer.
     *
     * Params:
     *   code = User event code.
     *   payload = Optional pointer to arbitrary data to be passed with the event.
     */
    protected void generateUserEvent(int code, void* payload = null)
    {
        eventManager.queueUserEvent(code, payload);
    }
    
    /**
     * Queues a message event.
     *
     * Params:
     *   recipient = Recipient object's address. Leave empty for broadcast.
     *   message = Message string.
     *   payload = Optional pointer to be passed with the event.
     *   domain = Message domain/communication layer (ITC or main-thread).
     */
    protected void queueMessage(string recipient, string message, void* payload = null, int domain = MessageDomain.ITC)
    {
        Event task = messageEvent(address, recipient, message, payload, domain);
        eventManager.queueEvent(task);
    }
    
    alias send = queueMessage;
    
    /**
     * Queues a task event.
     *
     * Params:
     *   callback = A delegate that should be executed.
     *   payload = Optional pointer to be passed with the event.
     *   domain = Message domain/communication layer (ITC or main-thread).
     */
    protected void queueTask(scope TaskCallback callback, void* payload = null, int domain = MessageDomain.ITC)
    {
        Event task = taskEvent(address, "", callback, payload, domain);
        eventManager.queueEvent(task);
    }
    
    /**
     * Queues a log event.
     *
     * Params:
     *   level = Log level.
     *   message = Log message.
     */
    protected void queueLog(LogLevel level, string message)
    {
        Event e = Event(EventType.Log);
        e.logLevel = level;
        e.message = message;
        eventManager.queueEvent(e);
    }

    /**
     * Processes all pending events, dispatching them to handler methods.
     *
     * Params:
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvents(bool enableInputEvents = true)
    {
        if (!enabled)
            return;

        for (uint i = 0; i < eventManager.numEvents; i++)
        {
            Event* e = &eventManager.eventQueue[i];
            processEvent(e, enableInputEvents);
        }
    }
}
