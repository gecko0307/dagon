/*
Copyright (c) 2014-2025 Timur Gafarov, Mateusz Muszyński

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides an event manager for input, window, and user-defined events.
 *
 * Description:
 * The `dagon.core.event` module defines the `EventType` enumeration, 
 * the `Event` struct, the `EventManager` class for event polling and dispatch, 
 * and the `EventListener` base class for handling events.
 *
 * Copyright: Timur Gafarov, Mateusz Muszyński 2014-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov, Mateusz Muszyński
 */
module dagon.core.event;

import std.stdio;
import std.ascii;
import std.conv;
import std.file;
import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.utils;
import dlib.container.array;
import dagon.core.bindings;
import dagon.core.application;
import dagon.core.input;
import dagon.core.logger;
import dagon.core.messaging;

/**
 * All supported event types in Dagon.
 */
enum EventType
{
    KeyDown,
    KeyUp,
    TextInput,
    MouseMotion,
    MouseButtonDown,
    MouseButtonUp,
    MouseWheel,
    JoystickButtonDown,
    JoystickButtonUp,
    ControllerButtonDown,
    ControllerButtonUp,
    ControllerAxisMotion,
    ControllerAdd,
    ControllerRemove,
    Resize,
    FocusLoss,
    FocusGain,
    Quit,
    FileChange,
    DropFile,
    Log,
    Message,
    Task,
    UserEvent
}

alias TaskCallback = void delegate(Object, void*);

/**
 * Represents a single event in the Dagon event system.
 * Contains event type and relevant data for the event.
 */
struct Event
{
    EventType type;
    int key;
    dchar unicode;
    int button;
    int joystickButton;
    int controllerButton;
    int controllerAxis;
    float controllerAxisValue;
    int controllerDeviceIndex = -1;
    int width;
    int height;
    int userCode;
    int mouseWheelX;
    int mouseWheelY;
    LogLevel logLevel;
    int domain;
    string filename;
    string message;
    string sender;
    string recipient;
    TaskCallback callback;
    void* payload;
}

enum MessageDomain
{
    ITC = -1,
    MainThread = 1
}

Event messageEvent(string sender, string recipient, string message, void* payload, int domain = MessageDomain.ITC)
{
    Event e;
    e.type = EventType.Message;
    e.sender = sender;
    e.recipient = recipient;
    e.message = message;
    e.payload = payload;
    e.domain = domain;
    return e;
}

Event taskEvent(string sender, string recipient, TaskCallback callback, void* payload, int domain = MessageDomain.ITC)
{
    Event e;
    e.type = EventType.Task;
    e.sender = sender;
    e.recipient = recipient;
    e.callback = callback;
    e.payload = payload;
    e.domain = domain;
    return e;
}

/**
 * Maximum number of supported controllers.
 */
enum MAX_CONTROLLERS = 1;

/**
 * Manages event polling, state, and dispatch.
 *
 * Description:
 * Handles input events, window events, controller/joystick events, and user-defined events.
 * Provides methods for polling SDL events, generating custom events, and querying input state.
 */
class EventManager: Owner
{
    Application application;
    
    SDL_Window* window;

    enum maxNumEvents = 50;
    
    /// Inbox event queue. All synchronic events (such as user input) go here.
    Event[maxNumEvents] eventQueue;
    
    /// Number of events in the inbox queue.
    uint numEvents;

    /// Outbox event queue. All asynchronic events (such as messages and tasks) go here.
    Event[maxNumEvents] outboxEventQueue;
    
    /// Number of events in the outbox queue.
    uint numOutboxEvents;

    bool running = true;

    bool[512] keyPressed = false;
    bool[512] keyUp = false;
    bool[512] keyDown = false;

    bool[255] mouseButtonPressed = false;
    bool[255] mouseButtonUp = false;
    bool[255] mouseButtonDown = false;
    
    bool[255] joystickButtonPressed = false;
    bool[255] joystickButtonUp = false;
    bool[255] joystickButtonDown = false;

    bool[255] controllerButtonPressed = false;
    bool[255] controllerButtonUp = false;
    bool[255] controllerButtonDown = false;
    
    bool trackUpDownState = false;
    
    protected
    {
        bool needToResetKeyUp = false;
        bool needToResetKeyDown = false;
        bool needToResetMouseUp = false;
        bool needToResetMouseDown = false;
        bool needToResetJoystickUp = false;
        bool needToResetJoystickDown = false;
        bool needToResetControllerUp = false;
        bool needToResetControllerDown = false;
    }

    int mouseX = 0;
    int mouseY = 0;
    int mouseRelX = 0;
    int mouseRelY = 0;
    bool enableKeyRepeat = false;

    double deltaTime = 0.0;
    uint deltaTimeMs = 0;

    uint windowWidth;
    uint windowHeight;
    bool windowFocused = true;

    // TODO: support multiple controllers up to MAX_CONTROLLERS
    SDL_GameController* controller = null;
    SDL_Joystick* joystick = null;
    int controllerAxisThreshold = 32639;
    deprecated("use controllerAxisThreshold instead")
    alias joystickAxisThreshold = controllerAxisThreshold;
    bool controllerHasRumble = false;
    string controllerName;
    string joystickName;
    
    InputManager inputManager;
    
    MessageBroker messageBroker;
    
    void delegate(SDL_Event* event) onProcessEvent;

    /**
     * Constructs an EventManager for the given SDL window and dimensions.
     *
     * Params:
     *   win = SDL window pointer.
     *   winWidth = Window width.
     *   winHeight = Window height.
     */
    this(Application app)
    {
        super(app);
        
        application = app;
        
        window = app.window;

        windowWidth = app.width;
        windowHeight = app.height;
        
        if (exists("gamecontrollerdb.txt"))
            SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt");

        if (SDL_NumJoysticks() > 0)
        {
            gameControllerOpen(0);
        }

        inputManager = New!InputManager(this);
        
        messageBroker = New!MessageBroker(this);
    }

    /// Destructor. Cleans up resources.
    ~this()
    {
        Delete(inputManager);
    }

    /// Signals the event manager to stop running (application exit).
    void exit()
    {
        running = false;
    }

    /**
     * Adds a new event to the inbox queue.
     *
     * Params:
     *   e = The event to add.
     */
    void addEvent(Event e) nothrow
    {
        if (numEvents < maxNumEvents)
        {
            eventQueue[numEvents] = e;
            numEvents++;
        }
    }
    
    /**
     * Adds a new event to the outbox queue.
     *
     * Params:
     *   e = The event to add.
     */
    void queueEvent(Event e) nothrow
    {
        if (numOutboxEvents < maxNumEvents)
        {
            outboxEventQueue[numOutboxEvents] = e;
            numOutboxEvents++;
        }
    }

    deprecated("use queueEvent instead") alias addUserEvent = queueEvent;

    /**
     * Generates a file change event for the given filename.
     *
     * Params:
     *   filename = The changed file's name.
     */
    void queueFileChangeEvent(string filename) nothrow
    {
        Event e = Event(EventType.FileChange);
        e.filename = filename;
        queueEvent(e);
    }
    
    deprecated("use queueFileChangeEvent instead") alias generateFileChangeEvent = queueFileChangeEvent;

    /**
     * Generates a user event with the given code.
     *
     * Params:
     *   code = User event code.
     */
    void queueUserEvent(int code) nothrow
    {
        Event e = Event(EventType.UserEvent);
        e.userCode = code;
        queueEvent(e);
    }
    
    deprecated("use queueUserEvent instead") alias generateUserEvent = queueUserEvent;
    
    /**
     * Prints to the logger asynchronically using the event queue.
     * This method is also useful to log from nothrow functions,
     * because the logger itself is not nothrow.
     *
     * Params:
     *   code = User event code.
     */
    void queueLogEvent(LogLevel level, string message) nothrow
    {
        Event e = Event(EventType.Log);
        e.logLevel = level;
        e.message = message;
        queueEvent(e);
    }
    
    deprecated("use queueLogEvent instead") alias asyncLog = queueLogEvent;
    
    /**
     * Opens a game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to open.
     */
    void gameControllerOpen(uint deviceIndex)
    {
        if (SDL_IsGameController(deviceIndex))
        {
            if (joystick)
                SDL_JoystickClose(joystick);
            
            if (controller)
                SDL_GameControllerClose(controller);
            
            controller = SDL_GameControllerOpen(deviceIndex);
            
            auto name = SDL_GameControllerName(controller);
            if (name)
            {
                controllerName = name.to!string;
                logInfo("Game controller: ", controllerName);
            }
            
            if (SDL_GameControllerMapping(controller) is null)
                logWarning("No mapping found for controller!");

            SDL_GameControllerEventState(SDL_ENABLE);
            
            joystick = SDL_GameControllerGetJoystick(controller);
            
            controllerHasRumble = cast(bool)SDL_GameControllerHasRumble(controller);
        }
        else
        {
            if (joystick)
                SDL_JoystickClose(joystick);
            
            joystick = SDL_JoystickOpen(deviceIndex);
            
            auto name = SDL_JoystickName(joystick);
            if (name)
            {
                joystickName = name.to!string;
                logInfo("Joystick: ", joystickName);
            }
        }
    }
    
    /**
     * Closes the game controller or joystick at the specified device index.
     *
     * Params:
     *   deviceIndex = The device index to close.
     */
    void gameControllerClose(uint deviceIndex)
    {
        if (joystick)
        {
            SDL_JoystickClose(joystick);
            joystickName = "";
        }
        
        if (controller)
        {
            SDL_GameControllerClose(controller);
            controllerName = "";
            controllerHasRumble = false;
        }
    }

    /// Returns true if a game controller is available.
    bool gameControllerAvailable()
    {
        return (controller !is null);
    }

    /// Returns true if a joystick is available.
    bool joystickAvailable()
    {
        return (joystick !is null);
    }

    /**
     * Gets the normalized value of a game controller axis.
     *
     * Params:
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float gameControllerAxis(int axis)
    {
        int axisVal = SDL_GameControllerGetAxis(controller, cast(SDL_GameControllerAxis)axis);
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }

    /**
     * Gets the normalized value of a joystick axis.
     *
     * Params:
     *   axis = Axis index.
     * Returns:
     *   Normalized axis value in [-1, 1].
     */
    float joystickAxis(int axis)
    {
        int axisVal = 0;
        if (joystick)
            axisVal = SDL_JoystickGetAxis(joystick, axis);
        else if (controller)
            axisVal = SDL_GameControllerGetAxis(controller, cast(SDL_GameControllerAxis)axis);
        else
            return 0.0f;
        
        return cast(float)clamp(axisVal, -controllerAxisThreshold, controllerAxisThreshold) / 
               cast(float)controllerAxisThreshold;
    }
    
    /**
     * Triggers controller rumble (vibration) if supported.
     *
     * Params:
     *   lowFreq = Low frequency rumble intensity.
     *   hiFreg = High frequency rumble intensity.
     *   duration = Duration in seconds.
     */
    void gameControllerRumble(uint lowFreq, uint hiFreg, float duration)
    {
        if (controllerHasRumble)
            SDL_GameControllerRumble(controller,
                cast(ushort)clamp(lowFreq, 0, ushort.max),
                cast(ushort)clamp(hiFreg, 0, ushort.max),
                cast(uint)(duration * 1000.0f));
    }

    /// Polls and processes all pending events.
    void update()
    {
        numEvents = 0;

        mouseRelX = 0;
        mouseRelY = 0;
        
        for (uint i = 0; i < numOutboxEvents; i++)
        {
            Event e = outboxEventQueue[i];
            if (e.type == EventType.Log)
                log(e.logLevel, e.message);
            else
                addEvent(e);
        }
        
        numOutboxEvents = 0;
        
        if (trackUpDownState)
            resetUpDown();

        SDL_Event event;

        while(SDL_PollEvent(&event))
        {
            if (onProcessEvent) onProcessEvent(&event);
            Event e;
            switch (event.type)
            {
                case SDL_KEYDOWN:
                    if (event.key.repeat && !enableKeyRepeat)
                        break;

                    keyPressed[event.key.keysym.scancode] = true;
                    
                    if (trackUpDownState)
                    {
                        keyDown[event.key.keysym.scancode] = true;
                        needToResetKeyDown = true;
                    }

                    e = Event(EventType.KeyDown);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_KEYUP:
                    keyPressed[event.key.keysym.scancode] = false;
                    
                    if (trackUpDownState)
                    {
                        keyUp[event.key.keysym.scancode] = true;
                        needToResetKeyUp = true;
                    }

                    e = Event(EventType.KeyUp);
                    e.key = event.key.keysym.scancode;
                    addEvent(e);
                    break;

                case SDL_TEXTINPUT:
                    e = Event(EventType.TextInput);
                    char[] input = event.text.text;
                    if ((input[0] & 0x80) == 0)
                        e.unicode = input[0];
                    else if ((input[0] & 0xE0) == 0xC0)
                        e.unicode = ((input[0] & 0x1F) << 6) | (input[1] & 0x3F);
                    else if ((input[0] & 0xF0) == 0xE0)
                        e.unicode = ((input[0] & 0x0F) << 12) | ((input[1] & 0x3F) << 6) | (input[2] & 0x3F);
                    else if ((input[0] & 0xF8) == 0xF0)
                        e.unicode = (((input[0] & 0x0F) << 18) | ((input[1] & 0x3F) << 12) | ((input[2] & 0x3F) << 6) | (input[3] & 0x3F));
                    addEvent(e);
                    break;

                case SDL_MOUSEMOTION:
                    mouseX = event.motion.x;
                    mouseY = event.motion.y;
                    mouseRelX = event.motion.xrel;
                    mouseRelY = event.motion.yrel;
                    break;

                case SDL_MOUSEBUTTONDOWN:
                    mouseButtonPressed[event.button.button] = true;
                    
                    if (trackUpDownState)
                    {
                        mouseButtonDown[event.button.button] = true;
                        needToResetMouseDown = true;
                    }
                    
                    e = Event(EventType.MouseButtonDown);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEBUTTONUP:
                    mouseButtonPressed[event.button.button] = false;
                    
                    if (trackUpDownState)
                    {
                        mouseButtonUp[event.button.button] = true;
                        needToResetMouseUp = true;
                    }
                    
                    e = Event(EventType.MouseButtonUp);
                    e.button = event.button.button;
                    addEvent(e);
                    break;

                case SDL_MOUSEWHEEL:
                    e = Event(EventType.MouseWheel);
                    e.mouseWheelX = event.wheel.x;
                    e.mouseWheelY = event.wheel.y;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONDOWN:
                    if(joystick is null) break;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        joystickButtonPressed[event.jbutton.button] = true;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonDown[event.jbutton.button] = true;
                            needToResetJoystickDown = true;
                        }
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        joystickButtonPressed[event.jbutton.button] = false;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonUp[event.jbutton.button] = true;
                            needToResetJoystickUp = true;
                        }
                    }
                    e.joystickButton = event.jbutton.button;
                    addEvent(e);
                    break;

                case SDL_JOYBUTTONUP:
                    if(joystick is null) break;
                    if (event.jbutton.state == SDL_PRESSED)
                    {
                        e = Event(EventType.JoystickButtonDown);
                        joystickButtonPressed[event.jbutton.button] = true;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonDown[event.jbutton.button] = true;
                            needToResetJoystickDown = true;
                        }
                    }
                    else if (event.jbutton.state == SDL_RELEASED)
                    {
                        e = Event(EventType.JoystickButtonUp);
                        joystickButtonPressed[event.jbutton.button] = false;
                        
                        if (trackUpDownState)
                        {
                            joystickButtonUp[event.jbutton.button] = true;
                            needToResetJoystickUp = true;
                        }
                    }
                    e.joystickButton = event.jbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONDOWN:
                    controllerButtonPressed[event.cbutton.button] = true;
                    
                    if (trackUpDownState)
                    {
                        controllerButtonDown[event.cbutton.button] = true;
                        needToResetControllerDown = true;
                    }

                    e = Event(EventType.ControllerButtonDown);
                    e.controllerButton = event.cbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERBUTTONUP:
                    controllerButtonPressed[event.cbutton.button] = false;
                    
                    if (trackUpDownState)
                    {
                        controllerButtonUp[event.cbutton.button] = true;
                        needToResetControllerUp = true;
                    }

                    e = Event(EventType.ControllerButtonUp);
                    e.controllerButton = event.cbutton.button;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERAXISMOTION:
                    // TODO: add state modification
                    e = Event(EventType.ControllerAxisMotion);
                    e.controllerAxis = event.caxis.axis;
                    int axisValue = event.caxis.value;
                    if (controller)
                    {
                        if (e.controllerAxis == 0)
                            axisValue = SDL_GameControllerGetAxis(controller, SDL_CONTROLLER_AXIS_LEFTY);
                        if (e.controllerAxis == 1)
                            axisValue = SDL_GameControllerGetAxis(controller, SDL_CONTROLLER_AXIS_LEFTX);
                    }
                    e.controllerAxisValue =
                        cast(float)clamp(axisValue, -controllerAxisThreshold, controllerAxisThreshold) / 
                        cast(float)controllerAxisThreshold;
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEADDED:
                    e = Event(EventType.ControllerAdd);
                    e.controllerDeviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                        gameControllerOpen(event.cdevice.which);
                    addEvent(e);
                    break;

                case SDL_CONTROLLERDEVICEREMOVED:
                    e = Event(EventType.ControllerRemove);
                    e.controllerDeviceIndex = event.cdevice.which;
                    if (event.cdevice.which < MAX_CONTROLLERS)
                        gameControllerClose(event.cdevice.which);
                    addEvent(e);
                    break;

                case SDL_WINDOWEVENT:
                    if (event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)
                    {
                        windowWidth = event.window.data1;
                        windowHeight = event.window.data2;
                        e = Event(EventType.Resize);
                        e.width = windowWidth;
                        e.height = windowHeight;
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED)
                    {
                        e = Event(EventType.FocusGain);
                        addEvent(e);
                    }
                    else if (event.window.event == SDL_WINDOWEVENT_FOCUS_LOST)
                    {
                        e = Event(EventType.FocusLoss);
                        addEvent(e);
                    }
                    break;

                case SDL_DROPFILE:
                    e = Event(EventType.DropFile);
                    e.filename = to!string(event.drop.file);
                    addEvent(e);
                    break;

                case SDL_QUIT:
                    exit();
                    e = Event(EventType.Quit);
                    addEvent(e);
                    break;

                default:
                    break;
            }
        }
        
        messageBroker.update();
    }

    protected int lastTime = 0;

    /// Updates the internal timer and computes delta time.
    void updateTimer()
    {
        int currentTime = SDL_GetTicks();
        auto elapsedTime = currentTime - lastTime;
        lastTime = currentTime;
        deltaTimeMs = elapsedTime;
        deltaTime = cast(double)(elapsedTime) * 0.001;
    }

    /**
     * Sets the mouse cursor position.
     *
     * Params:
     *   x = X coordinate.
     *   y = Y coordinate.
     */
    void setMouse(int x, int y)
    {
        SDL_WarpMouseInWindow(window, x, y);
        mouseX = x;
        mouseY = y;
    }

    /// Centers the mouse cursor in the window.
    void setMouseToCenter()
    {
        float x = (cast(float)windowWidth) / 2;
        float y = (cast(float)windowHeight) / 2;
        setMouse(cast(int)x, cast(int)y);
    }

    /**
     * Shows or hides the mouse cursor.
     *
     * Params:
     *   mode = true to show, false to hide.
     * Returns:
     *   SDL result code.
     */
    int showCursor(bool mode)
    {
        return SDL_ShowCursor(mode);
    }

    /**
     * Enables or disables relative mouse mode.
     *
     * Params:
     *   mode = true to enable, false to disable.
     * Returns:
     *   SDL result code.
     */
    int setRelativeMouseMode(bool mode)
    {
        return SDL_SetRelativeMouseMode(cast(SDL_bool)mode);
    }

     /// Returns the current window aspect ratio.
    float aspectRatio()
    {
        return cast(float)windowWidth / cast(float)windowHeight;
    }

    /// Resets all UP and DOWN input event states.
    void resetUpDown()
    {
        if (needToResetKeyUp)
        {
            keyUp[] = false;
            needToResetKeyUp = false;
        }
        
        if (needToResetKeyDown)
        {
            keyDown[] = false;
            needToResetKeyDown = false;
        }
        
        if (needToResetMouseUp)
        {
            mouseButtonUp[] = false;
            needToResetMouseUp = false;
        }
        
        if (needToResetMouseDown)
        {
            mouseButtonDown[] = false;
            needToResetMouseDown = false;
        }
        
        if (needToResetJoystickUp)
        {
            joystickButtonUp[] = false;
            needToResetJoystickUp = false;
        }
        
        if (needToResetJoystickDown)
        {
            joystickButtonDown[] = false;
            needToResetJoystickDown = false;
        }
        
        if (needToResetControllerUp)
        {
            controllerButtonUp[] = false;
            needToResetControllerUp = false;
        }
        
        if (needToResetControllerDown)
        {
            controllerButtonDown[] = false;
            needToResetControllerDown = false;
        }
    }
}

/**
 * Base class for event dispatchers.
 *
 * Description:
 * Inherit from `EventDispatcher` and override the relevant event handler methods.
 * Call `processEvents` to dispatch an event to your handlers.
 */
abstract class EventDispatcher: Owner
{
    int domain = MessageDomain.MainThread;
    string address = "";
    
    this(Owner owner)
    {
        super(owner);
    }
    
    /**
     * Processes a single event, dispatching it to the appropriate handler.
     *
     * Params:
     *   e = The event to process.
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvent(Event* e, bool enableInputEvents = true)
    {
        switch(e.type)
        {
            case EventType.KeyDown:
                if (enableInputEvents) onKeyDown(e.key);
                break;
            case EventType.KeyUp:
                if (enableInputEvents) onKeyUp(e.key);
                break;
            case EventType.TextInput:
                if (enableInputEvents) onTextInput(e.unicode);
                break;
            case EventType.MouseButtonDown:
                if (enableInputEvents) onMouseButtonDown(e.button);
                break;
            case EventType.MouseButtonUp:
                if (enableInputEvents) onMouseButtonUp(e.button);
                break;
            case EventType.MouseWheel:
                if (enableInputEvents) onMouseWheel(e.mouseWheelX, e.mouseWheelY);
                break;
            case EventType.JoystickButtonDown:
                if (enableInputEvents) onJoystickButtonDown(e.joystickButton);
                break;
            case EventType.JoystickButtonUp:
                if (enableInputEvents) onJoystickButtonUp(e.joystickButton);
                break;
            case EventType.ControllerButtonDown:
                if (enableInputEvents) onControllerButtonDown(e.controllerButton);
                break;
            case EventType.ControllerButtonUp:
                if (enableInputEvents) onControllerButtonUp(e.controllerButton);
                break;
            case EventType.ControllerAxisMotion:
                if (enableInputEvents) onControllerAxisMotion(e.controllerAxis, e.controllerAxisValue);
                break;
            case EventType.ControllerAdd:
                if (enableInputEvents) onControllerAdd(e.controllerDeviceIndex);
                break;
            case EventType.ControllerRemove:
                if (enableInputEvents) onControllerRemove(e.controllerDeviceIndex);
                break;
            case EventType.Resize:
                onResize(e.width, e.height);
                break;
            case EventType.FocusLoss:
                onFocusLoss();
                break;
            case EventType.FocusGain:
                onFocusGain();
                break;
            case EventType.Quit:
                onQuit();
                break;
            case EventType.FileChange:
                onFileChange(e.filename);
                break;
            case EventType.DropFile:
                if (enableInputEvents) onDropFile(e.filename);
                break;
            case EventType.Message:
                if (e.domain * domain > 0)
                    if (e.recipient.length == 0 || e.recipient == address)
                        onMessage(e.domain, e.sender, e.message, e.payload);
                break;
            case EventType.Task:
                if (e.domain * domain > 0)
                    if (e.recipient.length == 0 || e.recipient == address)
                        onTask(e.domain, e.sender, e.callback, e.payload);
                break;
            case EventType.UserEvent:
                onUserEvent(e.userCode);
                break;
            default:
                break;
        }
    }

    /// Called when a key is pressed.
    void onKeyDown(int key) {}

    /// Called when a key is released.
    void onKeyUp(int key) {}

    /// Called when text input is received.
    void onTextInput(dchar code) {}

    /// Called when a mouse button is pressed.
    void onMouseButtonDown(int button) {}

    /// Called when a mouse button is released.
    void onMouseButtonUp(int button) {}

    /// Called when the mouse wheel is scrolled.
    void onMouseWheel(int x, int y) {}

    /// Called when a joystick button is pressed.
    void onJoystickButtonDown(int button) {}

    /// Called when a joystick button is released.
    void onJoystickButtonUp(int button) {}

    /// Called when a controller button is pressed.
    void onControllerButtonDown(int button) {}

    /// Called when a controller button is released.
    void onControllerButtonUp(int button) {}

    /// Called when a controller axis is moved.
    void onControllerAxisMotion(int axis, float value) {}

    /// Called when a controller is added.
    void onControllerAdd(uint deviceIndex) {}

    /// Called when a controller is removed.
    void onControllerRemove(uint deviceIndex) {}

    /// Called when the window is resized.
    void onResize(int width, int height) {}

    /// Called when the window loses focus.
    void onFocusLoss() {}

    /// Called when the window gains focus.
    void onFocusGain() {}

    /// Called when a quit event is received.
    void onQuit() {}

    /// Called when a file change is detected.
    void onFileChange(string filename) {}

    /// Called when a file is dropped onto the window.
    void onDropFile(string filename) {}

    /// Called when a message event is received.
    void onMessage(int domain, string sender, string message, void* payload) {}
    
    /// Called when a task event is received.
    void onTask(int domain, string sender, TaskCallback callback, void* payload) {}

    /// Called when a user event is received.
    void onUserEvent(int code) {}
}

/**
 * Base class for single-threaded event listeners.
 */
abstract class EventListener: EventDispatcher
{
    /// The event manager used for polling events.
    EventManager eventManager;
    
    /// The input manager for input state queries.
    InputManager inputManager;
    
    /// If false, disables event processing.
    bool enabled = true;
    
    /**
     * Constructs an EventListener.
     *
     * Params:
     *   emngr = The event manager to use.
     *   owner = The owner object for memory management.
     */
    this(EventManager emngr, Owner owner)
    {
        super(owner);
        domain = MessageDomain.MainThread;
        eventManager = emngr;
        if(emngr !is null)
            inputManager = emngr.inputManager;
    }

    /**
     * Generates a user event with the given code.
     *
     * Params:
     *   code = User event code.
     */
    protected void generateUserEvent(int code)
    {
        eventManager.queueUserEvent(code);
    }
    
    protected void send(string recipient, string message, void* payload = null, int domain = MessageDomain.ITC)
    {
        Event task = messageEvent(address, recipient, message, payload, domain);
        eventManager.queueEvent(task);
    }
    
    protected void queueTask(scope TaskCallback callback, void* payload = null)
    {
        Event task = taskEvent(address, "", callback, payload, MessageDomain.ITC);
        eventManager.queueEvent(task);
    }

    /**
     * Processes all pending events, dispatching them to handler methods.
     *
     * Params:
     *   enableInputEvents = If false, disables input event handlers.
     */
    void processEvents(bool enableInputEvents = true)
    {
        if (!enabled)
            return;

        for (uint i = 0; i < eventManager.numEvents; i++)
        {
            Event* e = &eventManager.eventQueue[i];
            processEvent(e, enableInputEvents);
        }
    }
}
