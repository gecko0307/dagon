/*
Copyright (c) 2017-2026 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Generic applicaton class and corresponding utility functions
 *
 * Description:
 * The `dagon.core.application` module provides the base `Application` class
 * and related functionality for creating and managing a Dagon-based application.
 * This includes SDL window and OpenGL context management, event handling,
 * functions for error handling, taking screenshots and others.
 *
 * Copyright: Timur Gafarov 2017-2026.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.core.application;

import std.stdio;
import std.conv;
import std.getopt;
import std.string;
import std.file;
import std.path;
import std.algorithm: canFind;
import std.process;
import core.stdc.stdlib;
import core.stdc.string;

import dlib.core.memory;
import dlib.core.stream;
import dlib.image;
import dlib.filesystem;
import dlib.text.str;
import dlib.math.utils;

public import dagon.core.crashhandler;
import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;
import dagon.core.logger;
import dagon.core.vfs;
import dagon.core.props;
import dagon.core.config;
import dagon.core.sysinfo;
import dagon.core.locale;
import dagon.core.i18n;

import dagon.graphics.updateable;
import dagon.graphics.font;
import dagon.graphics.shader;
import dagon.graphics.texture;

version(Windows)
{
    pragma(lib, "user32");
    
    import core.sys.windows.windows;
    import dagon.core.wintab;
    
    enum CP_UTF8 = 65001;
    
    static this()
    {
        // Set console code page to UTF-8
        SetConsoleCP(CP_UTF8);
        SetConsoleOutputCP(CP_UTF8);
    }
}

/// Structure that represents Dagon version number.
struct DagonVersion
{
    uint major;
    uint minor;
    uint patch;
}

/// Engine version number as a read-only structure.
immutable DagonVersion dagonVersion = DagonVersion(0, 38, 0);

/// Engine version number as a read-only string.
immutable string dagonVersionString = "0.38.0";

/**
 * Reserved event codes for Dagon applications.
 */
enum DagonEvent
{
    Exit = -1
}

/**
 * Supported image formats
 */
enum ImageFileFormat
{
    Unknown,
    PNG,
    JPEG,
    BMP,
    TGA,
    WebP,
    TIFF,
    JPEG_XL,
    AVIF,
    HDR,
    DDS,
    KTX,
    SVG,
    GIF,
    QOI,
    PNM,
    XCF,
    XPM,
    PCX,
    LBM,
    JPG = JPEG,
    WEBP = WebP,
    KTX2 = KTX,
    TIF = TIFF,
    PPM = PNM,
    PGM = PNM,
    PBM = PNM
}

enum string[GLenum] GLErrorStrings = [
    GL_NO_ERROR: "GL_NO_ERROR",
    GL_INVALID_ENUM: "GL_INVALID_ENUM",
    GL_INVALID_VALUE: "GL_INVALID_VALUE",
    GL_INVALID_OPERATION: "GL_INVALID_OPERATION",
    GL_INVALID_FRAMEBUFFER_OPERATION: "GL_INVALID_FRAMEBUFFER_OPERATION",
    GL_OUT_OF_MEMORY: "GL_OUT_OF_MEMORY"
];

enum string[GLenum] GLDebugSourceStrings = [
    GL_DEBUG_SOURCE_API: "GL_DEBUG_SOURCE_API",
    GL_DEBUG_SOURCE_WINDOW_SYSTEM: "GL_DEBUG_SOURCE_WINDOW_SYSTEM",
    GL_DEBUG_SOURCE_SHADER_COMPILER: "GL_DEBUG_SOURCE_SHADER_COMPILER",
    GL_DEBUG_SOURCE_THIRD_PARTY: "GL_DEBUG_SOURCE_THIRD_PARTY",
    GL_DEBUG_SOURCE_APPLICATION: "GL_DEBUG_SOURCE_APPLICATION",
    GL_DEBUG_SOURCE_OTHER: "GL_DEBUG_SOURCE_OTHER"
];

enum string[GLenum] GLDebugTypeStrings = [
    GL_DEBUG_TYPE_ERROR: "GL_DEBUG_TYPE_ERROR",
    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR",
    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR",
    GL_DEBUG_TYPE_PORTABILITY: "GL_DEBUG_TYPE_PORTABILITY",
    GL_DEBUG_TYPE_PERFORMANCE: "GL_DEBUG_TYPE_PERFORMANCE",
    GL_DEBUG_TYPE_MARKER: "GL_DEBUG_TYPE_MARKER",
    GL_DEBUG_TYPE_PUSH_GROUP: "GL_DEBUG_TYPE_PUSH_GROUP",
    GL_DEBUG_TYPE_POP_GROUP: "GL_DEBUG_TYPE_POP_GROUP",
    GL_DEBUG_TYPE_OTHER: "GL_DEBUG_TYPE_OTHER"
];

enum string[GLenum] GLDebugSeverityStrings = [
    GL_DEBUG_SEVERITY_HIGH: "GL_DEBUG_SEVERITY_HIGH",
    GL_DEBUG_SEVERITY_MEDIUM: "GL_DEBUG_SEVERITY_MEDIUM",
    GL_DEBUG_SEVERITY_LOW: "GL_DEBUG_SEVERITY_LOW",
    GL_DEBUG_SEVERITY_NOTIFICATION: "GL_DEBUG_SEVERITY_NOTIFICATION"
];

extern(System) void messageCallback(
    GLenum source,
    GLenum type,
    GLuint id,
    GLenum severity,
    GLsizei length,
    const GLchar* message,
    const GLvoid* userParam) nothrow
{
    string msg = "%ssource = %s, type = %s, severity = %s, message = %s\n";
    string err = "OpenGL error: ";
    string empty = "";
    if (severity != GL_DEBUG_SEVERITY_NOTIFICATION)
    {
        string sourceStr = GLDebugSourceStrings[source];
        string typeStr = GLDebugTypeStrings[type];
        string severityStr = GLDebugSeverityStrings[severity];
        
        if (userParam)
        {
            Application app = cast(Application)userParam;
            if (app)
            {
                // Instead of calling logDebug directly (which is not nothrow), use the event loop
                app.eventManager.queueLogEvent(LogLevel.Debug, cast(string)message[0..length]);
            }
        }
        
        if (severity == GL_DEBUG_SEVERITY_HIGH)
            core.stdc.stdlib.exit(1);
    }
}

private
{
    __gshared int[] compressedTextureFormats;

    void enumerateCompressedTextureFormats()
    {
        int numCompressedFormats = 0;
        glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS, &numCompressedFormats);
        if (numCompressedFormats)
        {
            compressedTextureFormats = New!(int[])(numCompressedFormats);
            glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS, compressedTextureFormats.ptr);
        }
    }

    void releaseCompressedTextureFormats()
    {
        if (compressedTextureFormats.length)
            Delete(compressedTextureFormats);
    }
}

/**
 * Checks if a compressed texture format is supported.
 *
 * Params:
 *   format = The OpenGL enum value for the texture format.
 * Returns:
 *   `true` if the format is supported, `false` otherwise.
 */
bool compressedTextureFormatSupported(GLenum format)
{
    if (compressedTextureFormats.length)
        return compressedTextureFormats.canFind(format);
    else
        return false;
}

__gshared private
{
    bool[ImageFileFormat] _imageFileFormatSupported;
    GLint _maxTextureUnits;
    GLint _maxTextureSize;
    string[] _extensions;
    
    VirtualFileSystem _vfs;
    ShaderCache _globalShaderCache;
}

/**
 * Checks if a given image file format is supported.
 *
 * Params:
 *   ffmt = The image file format to check.
 * Returns:
 *   `true` if supported, `false` otherwise.
 */
bool isImageFileFormatSupported(ImageFileFormat ffmt)
{
    if (ffmt in _imageFileFormatSupported)
        return _imageFileFormatSupported[ffmt];
    else
        return false;
}

/**
 * Returns the maximum number of texture units supported by the hardware.
 */
int maxTextureUnits()
{
    return _maxTextureUnits;
}

/**
 * Returns the maximum supported texture size.
 */
int maxTextureSize()
{
    return _maxTextureSize;
}

/**
 * Checks if a given OpenGL extension is supported.
 *
 * Params:
 *   extName = The name of the extension.
 * Returns:
 *   `true` if supported, `false` otherwise.
 */
bool isExtensionSupported(string extName)
{
    return _extensions.canFind(extName);
}

/// Structure that represents FreeType version number.
struct FTVersion
{
    int major, minor, patch;
}

/// Supported cursor types.
enum Cursor: uint
{
    Default = 0,
    IBeam = 1,
    Wait = 2,
    Crosshair = 3,
    WaitArrow = 4,
    SizeNWSE = 5,
    SizeNESW = 6,
    SizeWE = 7,
    SizeNS = 8,
    SizeAll = 9,
    No = 10,
    Hand = 11
}

/// Returns VFS used by the Application.
VirtualFileSystem globalVFS()
{
    return _vfs;
}

/// Returns global `ShaderCache` object.
ShaderCache globalShaderCache()
{
    return _globalShaderCache;
}

private
{
    struct TimerData
    {
        Application application;
        size_t index;
        int id;
        int userEventCode;
        bool periodic;
        bool active;
    }

    extern(C) uint sdlTimerCallback(uint interval, void* param) nothrow
    {
        TimerData* td = cast(TimerData*)param;
        td.application.completeTimer(td.index);
        if (td.periodic)
            return interval;
        else
            return 0;
    }
}

/**
 * Base class to inherit application object from.
 *
 * Description:
 * This class wraps dynamic library binding, SDL window creation, OpenGL context initialization and
 * information querying, event management, and the main game loop. It also handles configuration
 * via `settings.conf` file and provides a number of helper methods (taking screenshots, querying display
 * refresh rate, switching console window, etc.).
 * By itself, `Application` doesn't render anything and doesn't contain game logic. To make a game,
 * inherit from `Application` and override `onUpdate` and `onRender`.
 * All `Application` properties are meant to be read-only! Modify at your own risk.
 */
class Application: EventListener, Updateable
{
    protected string configFilename = "settings.conf";
    
    /// Initial log level.
    LogLevel logLevel = LogLevel.Info;
    
    /// Command line arguments.
    string[] args;
    
    /// Full path of the executable (not CWD!).
    string path;
    
    /// Absolute directory containing the executable.
    string directory;
    
    /// The application folder name (used under the HOME or APPDATA directory).
    string appDataFolderName;
    
    /// Additional VFS mount paths defined in settings.conf.
    string customMountPaths;
    
    /// Path to the SDL2 library.
    string sdlLibraryPath = "auto";
    
    /// Path to the SDL2_Image library.
    string sdlImageLibraryPath = "auto";
    
    /// Path to the FreeType library.
    string freetypeLibraryPath = "auto";
    
    /// Path to the folder containing translation files.
    string localePath = "locale";
    
    /// Global VFS that all resource loaders should use.
    VirtualFileSystem vfs;
    
    /// The configuration object for storing user-defined settings.
    Configuration config;
    
    /**
     * Loaded SDL API support version. This is not an actual SDL library version!
     * Dagon assumes SDLSupport.v2_30, but this is not a strict requirement,
     * the engine will continue running even if 2.30 fails to load.
     * To check actually loaded library version, use `sdlVersion`.
     */
    SDLSupport loadedSDLSupport;
    
    /**
     * Loaded SDL_Image API support version. This is not an actual SDL_Image library version!
     * Dagon assumes SDLImageSupport.v2_8, but this is not a strict requirement,
     * the engine will continue running even if 2.8 fails to load.
     * To check actually loaded library version, use `sdlImageVersion`.
     */
    SDLImageSupport loadedSDLImageSupport;
    
    /**
     * Loaded OpenGL API support version.
     * Dagon requires at least GLSupport.gl43 and will not run on a lower version.
     */
    GLSupport loadedGLSupport;
    
    /**
     * Loaded FreeType API support version. This is not an actual FreeType library version!
     * Dagon assumes FTSupport.v2_8, but this is not a strict requirement,
     * the engine will continue running even if 2.8 fails to load.
     * To check actually loaded library version, use `ftVersion`.
     */
    FTSupport loadedFTSupport;
    
    /// SDL_Image available or not.
    bool sdlImagePresent = true;
    
    /// FreeType available or not.
    bool freetypePresent = true;
    
    /// Wintab available or not.
    bool wintabPresent = false;
    
    /// Actually used SDL library version.
    SDL_version sdlVersion;
    
    /// Actually used SDL_Image library version.
    SDL_version sdlImageVersion;
    
    /// Actually used FreeType library version.
    FTVersion ftVersion;
    
    /// System information.
    SysInfo systemInfo;
    
    /// Application window width.
    uint windowWidth;
    
    /// Application window height.
    uint windowHeight;
    
    /// Application window X-coordinate.
    int windowX = SDL_WINDOWPOS_CENTERED;
    
    /// Application window Y-coordinate.
    int windowY = SDL_WINDOWPOS_CENTERED;
    
    /// Is the window initially maximized.
    bool windowMaximized = false;
    
    /// Is the window initially minimizied.
    bool windowMinimized = false;
    
    /// Can the user resize the window.
    bool windowResizable = true;
    
    /// Is the window borderless.
    bool windowBorderless = false;
    
    /// Is the window HiDPI-aware.
    bool windowHiDPI = false;
    
    /// Application window title.
    string windowTitle;
    
    /// Actual drawable area width of the window.
    int drawableWidth;
    
    /// Actual drawable area height of the window.
    int drawableHeight;
    
    /// Ratio of the resolution in physical pixels to the resolution in logical pixels.
    float pixelRatio = 1.0f;
    
    /// Fullscreen or windowed.
    bool fullscreen = false;
    
    /// VR headset mode.
    bool stereoRendering = false;
    
    /// Vertical synchronization mode.
    int vsync = 1;
    
    /// Update frequency in Hz.
    uint stepFrequency = 60;
    
    /// Maximum simultaneous timers.
    uint maxTimersCount = 1024;
    
    /// Is OpenGL debug output enabled.
    bool enableDebugOutput = false;
    
    /// Is shader binary cache enabled.
    bool enableShaderCache = false;
    
    /// Path to the default sans font (for the built-in font manager).
    string defaultFontSans = "data/__internal/fonts/LiberationSans-Regular.ttf";
    
    /// Path to the default monospace font (for the built-in font manager).
    string defaultFontMonospace = "data/__internal/fonts/LiberationMono-Regular.ttf";
    
    /// Default font size (for the built-in font manager).
    uint defaultFontSize = 10;
    
    /// Pointer to the main SDL window created by the Application.
    SDL_Window* window = null;
    
    /// OpenGL context.
    SDL_GLContext glcontext;
    
    /// Main loop runner. Calls `Application.update` with a given fixed frequency (60 Hz by default).
    Cadencer cadencer;
    
    /// OpenGL version string obtained from the graphics driver.
    String glVersion;
    
    /// OpenGL vendor string obtained from the graphics driver.
    String glVendor;
    
    /// OpenGL renderer string (graphics card model) obtained from the graphics driver.
    String glRenderer;
    
    /**
     * Is anisotropic filtering enabled by default for textures.
     * If anisotropic filtering is not supported, this is set to false.
     */
    bool useAnisotropicFiltering = false;
    
    /**
     * Maximum supported level of anisotropic texture filtering.
     * If anisotropic filtering is not supported, this is set to 1.0.
     */
    float maxTextureAnisotropy = 16.0f;
    
    /// Default level of anisotropic filtering for textures.
    float defaultTextureAnisotropy = 1.0f;
    
    /// Maximum number of workgroups per compute dispatch.
    int[3] maxWorkGroups;
    
    /// Maximum size of a single workgorup in a compute shader.
    int[3] maxWorkGroupSize;
    
    /// System locale (ISO 639 language + ISO 3166 region)
    string locale = "en_US";
    
    /// User-defined locale (ISO 639 language + ISO 3166 region). Overrides system locale.
    string userLocale = "en_US";
    
    /// Loaded translation (from locale/*.lang file) based on selected locale.
    Translation translation;
    
    /// Handle to a FreeType library instance.
    FT_Library ftLibrary;
    
    /// Object that loads and registers fonts.
    FontManager fontManager;
    
    /// Shader cache.
    ShaderCache shaderCache;
    
    /// Shader cache path.
    string shaderCachePath = "data/__internal/shader_cache";
    
    protected
    {
        EventManager _eventManager;
        SDL_Cursor*[12] cursor;
        
        uint screenNum = 0;
        
        bool warnedAboutWindowWidth = false;
        bool warnedAboutWindowHeight = false;
        bool warnedAboutWindowTitle = false;
        
        TimerData[] timers;
        size_t _numTimers = 0;
    }

    /**
     * Constructs the application, initializes SDL, OpenGL, and related core subsystems.
     *
     * Params:
     *   winWidth = Window width in pixels.
     *   winHeight = Window height in pixels.
     *   fullscreen = If true, the application will run in fullscreen mode.
     *   windowTitle = The window title.
     *   args = Command line arguments.
     *   appDataFolderName = The application folder name (used under the HOME or APPDATA directory).
     */
    this(uint winWidth, uint winHeight, bool fullscreen, string windowTitle, string[] args, string appDataFolderName = ".dagon")
    {
        // Initialize with hardcoded parameters
        this.windowWidth = winWidth;
        this.windowHeight = winHeight;
        this.fullscreen = fullscreen;
        this.windowTitle = windowTitle;
        this.args = args;
        
        debug
        {
            logOutputOptions.enabled = true;
            this.logLevel = LogLevel.Debug;
        }
        
        dagon.core.logger.logLevel = this.logLevel;
        
        // Important paths
        this.path = thisExePath();
        this.directory = dirName(path);
        this.appDataFolderName = appDataFolderName;
        
        // Set default locale
        locale = systemLocale();
        userLocale = locale;
        
        // Create VFS
        vfs = New!VirtualFileSystem();
        
        // Create main config
        config = New!Configuration(this);
        bool configFileFound = false;
        
        // Load initial config from executable directory
        String initConfigPath = String(directory);
        initConfigPath ~= dirSeparator;
        initConfigPath ~= configFilename;
        FileStat stat;
        if (vfs.stdfs.stat(configFilename, stat))
        {
            auto istrm = vfs.stdfs.openForInput(initConfigPath);
            auto initConfig = readText(istrm);
            Delete(istrm);
            if (config.fromString(initConfig))
            {
                updateSettings();
                configFileFound = true;
            }
            Delete(initConfig);
        }
        initConfigPath.free();
        
        // Get system info
        sysInfo(&systemInfo);
        
        logInfo("Dagon ", dagonVersionString);
        logInfo("CPU architecture: ", systemInfo.architecture);
        logInfo("CPU cores: ", systemInfo.numProcessors);
        logInfo("OS: ", systemInfo.osName, " ", systemInfo.osVersion);
        logInfo("System locale: ", locale);
        logInfo("Selected locale: ", userLocale);
        
        // Mount directories to the VFS
        mount(this.directory);
        if (this.appDataFolderName.length > 0)
        {
            vfs.mountAppDataDirectory(this.appDataFolderName);
            logInfo("VFS: mount ", vfs.appDataPath);
        }
        if (customMountPaths.length > 0)
        {
            foreach(i, path; customMountPaths.split(';'))
                mount(path);
        }
        _vfs = vfs;
        
        // Load overrifing configs from additional VFS directories
        if (vfs.mounted.length > 1)
        {
            foreach(fs; vfs.mounted.data[1..$])
            {
                if (config.fromFile(fs, configFilename))
                {
                    updateSettings();
                    configFileFound = true;
                }
            }
        }
        
        if (!configFileFound)
            logWarning("No \"", configFilename, "\" found");
        
        // Load selected translation
        translation = New!Translation(this, this);
        translation.load("en_US");
        if (userLocale != "en_US")
            translation.load(userLocale);
        
        // Load shared libraries
        version(linux)
        {
            if (sdlLibraryPath == "auto")
                sdlLibraryPath = "libSDL2-2.0.so.0";
            
            if (sdlImageLibraryPath == "auto")
                sdlImageLibraryPath = "libSDL2_image-2.0.so";
            
            if (freetypeLibraryPath == "auto")
                freetypeLibraryPath = "";
        }
        else version(Windows)
        {
            if (sdlLibraryPath == "auto")
                sdlLibraryPath = "SDL2.dll";
            
            if (sdlImageLibraryPath == "auto")
                sdlImageLibraryPath = "SDL2_image.dll";
            
            if (freetypeLibraryPath == "auto")
                freetypeLibraryPath = "";
        }
        
        if (sdlLibraryPath.length)
            loadedSDLSupport = loadSDL(sdlLibraryPath.toStringz);
        else
            loadedSDLSupport = loadSDL();
        
        if (loadedSDLSupport != sdlSupport)
        {
            if (loadedSDLSupport == SDLSupport.badLibrary)
                logWarning("Failed to load some SDL functions. It seems that you have an old version of SDL. Dagon will try to use it, but it is recommended to install SDL 2.30 or higher");
            else
                exitWithError("Error: SDL library is not found. Please, install SDL 2.30 or higher");
        }
        
        SDL_GetVersion(&sdlVersion);
        logInfo("SDL version: ", sdlVersion.major, ".", sdlVersion.minor, ".", sdlVersion.patch);
        
        if (sdlImageLibraryPath.length)
            loadedSDLImageSupport = loadSDLImage(sdlImageLibraryPath.toStringz);
        else
            loadedSDLImageSupport = loadSDLImage();
        
        if (loadedSDLImageSupport != sdlImageSupport)
        {
            if (loadedSDLImageSupport == SDLImageSupport.badLibrary)
            {
                logWarning("Failed to load some SDL2_Image functions. It seems that you have an old version of SDL2_Image. Dagon will try to use it, but it is recommended to install SDL2_Image 2.8 or higher");
            }
            else
            {
                logWarning("SDL2_Image library is not found. Please, install SDL2_Image 2.8 or higher");
                sdlImagePresent = false;
            }
        }
        
        if (freetypeLibraryPath.length)
            loadedFTSupport = loadFreeType(freetypeLibraryPath.toStringz);
        else
            loadedFTSupport = loadFreeType();
        
        if (loadedFTSupport != ftSupport)
        {
            if (loadedFTSupport == FTSupport.badLibrary)
            {
                logWarning("Failed to load some Freetype functions. It seems that you have an old version of Freetype. Dagon will try to use it, but it is recommended to install Freetype 2.8.1 or higher");
            }
            else
            {
                logError("Freetype library is not found. Please, install Freetype 2.8.1");
                freetypePresent = false;
            }
        }
        
        // Init Wintab
        version(Windows)
        {
            // TODO: wintabLibraryPath
            WintabSupport loadedWintabSupport = loadWintab();
            if (loadedWintabSupport != WintabSupport.v140)
            {
                if (loadedWintabSupport == WintabSupport.badLibrary)
                {
                    logWarning("Failed to load some Wintab functions");
                    wintabPresent = true;
                }
                else
                    logWarning("Wintab library is not found");
            }
        }
        
        const(SDL_version)* pSdlImageVer = IMG_Linked_Version();
        sdlImageVersion = *pSdlImageVer;
        logInfo("SDL_Image version: ", sdlImageVersion.major, ".", sdlImageVersion.minor, ".", sdlImageVersion.patch);

        // Init SDL
        if (windowHiDPI)
            SDL_SetHint(SDL_HINT_WINDOWS_DPI_SCALING, "1");
        
        if (SDL_Init(SDL_INIT_EVERYTHING) == -1)
            exitWithError("Failed to init SDL: " ~ to!string(SDL_GetError()));

        if (fullscreen)
        {
            SDL_DisplayMode displayMode;
            SDL_GetCurrentDisplayMode(0, &displayMode);
            
            if (windowWidth == 0)
                windowWidth = displayMode.w;
            if (windowHeight == 0)
                windowHeight = displayMode.h;
        }
        else
        {
            SDL_Rect desktopBounds;
            SDL_GetDisplayBounds(0, &desktopBounds);
            
            if (windowWidth == 0)
                windowWidth = desktopBounds.w;
            if (windowHeight == 0)
                windowHeight = desktopBounds.h;
        }
        
        // Init SDL_Image
        _imageFileFormatSupported[ImageFileFormat.PNG] = true;
        _imageFileFormatSupported[ImageFileFormat.JPEG] = true;
        _imageFileFormatSupported[ImageFileFormat.BMP] = true;
        _imageFileFormatSupported[ImageFileFormat.TGA] = true;
        _imageFileFormatSupported[ImageFileFormat.HDR] = true;
        _imageFileFormatSupported[ImageFileFormat.DDS] = true;
        
        if (sdlImagePresent)
        {
            int desiredFormatFlags = 
                IMG_INIT_JPG | IMG_INIT_PNG | IMG_INIT_TIF |
                IMG_INIT_WEBP | IMG_INIT_JXL | IMG_INIT_AVIF;
            int supportedFormatFlags = IMG_Init(desiredFormatFlags);
            if (supportedFormatFlags == 0)
            {
                logWarning("Failed to init SDL2_Image");
                sdlImagePresent = false;
            }
            
            _imageFileFormatSupported[ImageFileFormat.SVG] = true;
            _imageFileFormatSupported[ImageFileFormat.TIFF] = (supportedFormatFlags & IMG_INIT_TIF) > 0;
            _imageFileFormatSupported[ImageFileFormat.WebP] = (supportedFormatFlags & IMG_INIT_WEBP) > 0;
            _imageFileFormatSupported[ImageFileFormat.JPEG_XL] = (supportedFormatFlags & IMG_INIT_JXL) > 0;
            _imageFileFormatSupported[ImageFileFormat.AVIF] = (supportedFormatFlags & IMG_INIT_AVIF) > 0;
            _imageFileFormatSupported[ImageFileFormat.GIF] = true;
            _imageFileFormatSupported[ImageFileFormat.QOI] = true;
            _imageFileFormatSupported[ImageFileFormat.PNM] = true;
            _imageFileFormatSupported[ImageFileFormat.XCF] = true;
            _imageFileFormatSupported[ImageFileFormat.XPM] = true;
            _imageFileFormatSupported[ImageFileFormat.PCX] = true;
            _imageFileFormatSupported[ImageFileFormat.LBM] = true;
        }

        // Set OpenGL context attributes
        SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
        SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
        SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
        
        // Create SDL window
        uint windowFlags = SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL;
        if (windowResizable)
            windowFlags |= SDL_WINDOW_RESIZABLE;
        if (windowMaximized)
            windowFlags |= SDL_WINDOW_MAXIMIZED;
        if (windowMinimized)
            windowFlags |= SDL_WINDOW_MINIMIZED;
        if (windowBorderless)
            windowFlags |= SDL_WINDOW_BORDERLESS;
        if (windowHiDPI)
            windowFlags |= SDL_WINDOW_ALLOW_HIGHDPI;
        
        window = SDL_CreateWindow(toStringz(windowTitle), windowX, windowY, windowWidth, windowHeight, windowFlags);
        if (window is null)
            exitWithError("Failed to create window: " ~ to!string(SDL_GetError()));
        
        int createdWindowWidth, createdWindowHeight;
        SDL_GetWindowSize(window, &createdWindowWidth, &createdWindowHeight);
        windowWidth = createdWindowWidth;
        windowHeight = createdWindowHeight;
        logInfo("Window size: ", windowWidth, "x", windowHeight);
        
        if (stereoRendering)
        {
            // TODO: make configurable
            drawableWidth = 1080;
            drawableHeight = 1080;
        }
        else
            SDL_GL_GetDrawableSize(window, &drawableWidth, &drawableHeight);
        logInfo("Window drawable size: ", drawableWidth, "x", drawableHeight);
        
        pixelRatio = cast(float)drawableHeight / cast(float)windowHeight;
        logInfo("Pixel ratio: ", pixelRatio);

        // Create OpenGL context
        glcontext = SDL_GL_CreateContext(window);
        if (glcontext is null)
            exitWithError("Failed to create OpenGL context: " ~ to!string(SDL_GetError()));
        SDL_GL_MakeCurrent(window, glcontext);
        SDL_GL_SetSwapInterval(vsync);
        
        // Load OpenGL functions
        loadedGLSupport = loadOpenGL();
        if (isOpenGLLoaded())
        {
            if (loadedGLSupport < GLSupport.gl43)
                exitWithError("Dagon requires OpenGL 4.3, but it seems that your graphics card does not support it");
        }
        else
            exitWithError("Failed to load OpenGL functions. Please, update graphics card driver and make sure it supports OpenGL 4.3");
        
        setFullscreen(fullscreen);

        // Create event manager
        _eventManager = New!EventManager(this);
        super(_eventManager, null);
        if ("events.keyRepeat" in config.props)
            _eventManager.enableKeyRepeat = cast(bool)config.props["events.keyRepeat"].toUInt;
        if ("events.controllerAxisThreshold" in config.props)
            _eventManager.controllerAxisThreshold = config.props["events.controllerAxisThreshold"].toUInt;
        if ("events.graphicsTablet.enabled" in config.props)
            _eventManager.graphicsTablet.enabled = cast(bool)config.props["events.graphicsTablet.enabled"].toUInt;

        // Get OpenGL info strings
        glVersion = String(glGetString(GL_VERSION));
        glVendor = String(glGetString(GL_VENDOR));
        glRenderer = String(glGetString(GL_RENDERER));
        logInfo("OpenGL version: ", glVersion);
        logInfo("OpenGL vendor: ", glVendor);
        logInfo("OpenGL renderer: ", glRenderer);
        
        // Get OpenGL limits
        glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &_maxTextureUnits);
        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &_maxTextureSize);
        logInfo("GL_MAX_TEXTURE_IMAGE_UNITS: ", _maxTextureUnits);
        logInfo("GL_MAX_TEXTURE_SIZE: ", _maxTextureSize);
        
        // Get OpenGL extensions list
        GLint numExtensions;
        glGetIntegerv(GL_NUM_EXTENSIONS, &numExtensions);
        _extensions = New!(string[])(numExtensions);
        for (GLint i = 0; i < numExtensions; i++)
        {
            _extensions[i] = glGetStringi(GL_EXTENSIONS, i).to!string;
        }
        logInfo("GL_ARB_texture_compression_bptc: ", isExtensionSupported("GL_ARB_texture_compression_bptc"));
        
        // Initial OpenGL state settings
        glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClearDepth(1.0);
        glEnable(GL_SCISSOR_TEST);
        glDepthFunc(GL_LESS);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_POLYGON_OFFSET_FILL);
        glCullFace(GL_BACK);
        glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
        glEnable(GL_LINE_SMOOTH);
        
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        SDL_GL_SwapWindow(window);
        
        enumerateCompressedTextureFormats();
        
        bool anisotropicFilteringSupported = isExtensionSupported("GL_EXT_texture_filter_anisotropic");
        logInfo("GL_EXT_texture_filter_anisotropic: ", anisotropicFilteringSupported);
        
        if (anisotropicFilteringSupported)
        {
            float queriedMaxAnisotropy = maxTextureAnisotropy;
            glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &queriedMaxAnisotropy);
            logInfo("GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: ", queriedMaxAnisotropy);
            if (queriedMaxAnisotropy < maxTextureAnisotropy)
                maxTextureAnisotropy = queriedMaxAnisotropy;
            
            if ("gl.anisotropicFiltering" in config.props)
                useAnisotropicFiltering = cast(bool)config.props["gl.anisotropicFiltering"].toUInt;
            
            if ("gl.defaultTextureAnisotropy" in config.props)
                defaultTextureAnisotropy = clamp(config.props["gl.defaultTextureAnisotropy"].toFloat, 1.0f, maxTextureAnisotropy);
            else
                defaultTextureAnisotropy = 1.0f;
        }
        else
        {
            useAnisotropicFiltering = false;
            maxTextureAnisotropy = 1.0f;
            defaultTextureAnisotropy = 1.0f;
        }
        
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 0, &maxWorkGroups[0]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 1, &maxWorkGroups[1]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 2, &maxWorkGroups[2]);
        logInfo("GL_MAX_COMPUTE_WORK_GROUP_COUNT: ", maxWorkGroups);
        
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 0, &maxWorkGroups[0]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 1, &maxWorkGroups[1]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 2, &maxWorkGroups[2]);
        logInfo("GL_MAX_COMPUTE_WORK_GROUP_SIZE: ", maxWorkGroups);
        
        // Debug output
        if ("gl.debugOutput" in config.props)
            enableDebugOutput = cast(bool)config.props["gl.debugOutput"].toUInt;
        if (enableDebugOutput)
        {
            if (hasKHRDebug)
            {
                glEnable(GL_DEBUG_OUTPUT);
                glDebugMessageCallback(&messageCallback, cast(void*)this);
            }
            else
                logWarning("GL_KHR_debug is not supported, debug output is not available");
        }
        
        // Create cadencer and timers pool
        if (stepFrequency == 0)
            stepFrequency = displayRefreshRate(60);
        logInfo("Step frequency: ", stepFrequency, " Hz");
        cadencer = New!Cadencer(this, stepFrequency, this);
        logInfo("Maximum timers count: ", maxTimersCount);
        timers = New!(TimerData[])(maxTimersCount);
        
        // Init FreeType and create a font manager
        if (freetypePresent)
        {
            if (FT_Init_FreeType(&ftLibrary))
            {
                logError("FT_Init_FreeType failed");
                freetypePresent = false;
            }
            else
            {
                FT_Library_Version(ftLibrary, &ftVersion.major, &ftVersion.minor, &ftVersion.patch);
                logInfo("FreeType version: ", ftVersion.major, ".", ftVersion.minor, ".", ftVersion.patch);
            }
        }
        fontManager = New!FontManager(this);
        
        // Init shader cache
        if ("gl.shaderCache.enabled" in config.props)
            enableShaderCache = cast(bool)(config.props["gl.shaderCache.enabled"].toUInt);
        if ("gl.shaderCache.path" in config.props)
            shaderCachePath = config.props["gl.shaderCache.path"].toString;
        version(Windows)
        {
            if ("gl.shaderCache.path.windows" in config.props)
                shaderCachePath = config.props["gl.shaderCache.path.windows"].toString;
        }
        else version(linux)
        {
            if ("gl.shaderCache.path.linux" in config.props)
                shaderCachePath = config.props["gl.shaderCache.path.linux"].toString;
        }
        shaderCache = New!ShaderCache(vfs, shaderCachePath, this);
        shaderCache.enabled = enableShaderCache;
        _globalShaderCache = shaderCache;
        logInfo("Shader cache enabled: ", shaderCache.enabled);
        if (shaderCache.enabled)
            logInfo("Shader cache path: ", shaderCachePath);
        
        // Get cursors (TODO: support custom cursors)
        cursor[Cursor.Default] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        cursor[Cursor.IBeam] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_IBEAM);
        cursor[Cursor.Wait] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAIT);
        cursor[Cursor.Crosshair] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
        cursor[Cursor.WaitArrow] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAITARROW);
        cursor[Cursor.SizeNWSE] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE);
        cursor[Cursor.SizeNESW] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENESW);
        cursor[Cursor.SizeWE] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEWE);
        cursor[Cursor.SizeNS] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENS);
        cursor[Cursor.SizeAll] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
        cursor[Cursor.No] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_NO);
        cursor[Cursor.Hand] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    }
    
    protected void updateSettings()
    {
        // Logger settings
        if ("log.enabled" in config.props)
            logOutputOptions.enabled = cast(bool)config.props["log.enabled"].toUInt;
        
        if ("log.level" in config.props)
        {
            string logLevelStr = config.props["log.level"].toString;
            if (logLevelStr == "debug")
                this.logLevel = LogLevel.Debug;
            else if (logLevelStr == "info")
                this.logLevel = LogLevel.Info;
            else if (logLevelStr == "warning")
                this.logLevel = LogLevel.Warning;
            else if (logLevelStr == "error")
                this.logLevel = LogLevel.Error;
            dagon.core.logger.logLevel = this.logLevel;
        }
        
        if ("log.toStdout" in config.props)
            logOutputOptions.printToStdout = cast(bool)config.props["log.toStdout"].toUInt;
        if ("log.file" in config.props)
            if (config.props["log.file"].type == DPropType.String)
                setLogFilename(config.props["log.file"].toString);
        if ("log.timestampTags" in config.props)
            logOutputOptions.printTimestamp = cast(bool)config.props["log.timestampTags"].toUInt;
        if ("log.levelTags" in config.props)
            logOutputOptions.printLogLevel = cast(bool)config.props["log.levelTags"].toUInt;
        
        // VFS settings
        if ("vfs.appDataFolder" in config.props)
            appDataFolderName = config.props["vfs.appDataFolder"].toString;
        if ("vfs.mount" in config.props)
            customMountPaths = config.props["vfs.mount"].toString;
        version(Windows)
        {
            if ("vfs.appDataFolder.windows" in config.props)
                appDataFolderName = config.props["vfs.appDataFolder.windows"].toString;
            if ("vfs.mount.windows" in config.props)
                customMountPaths = config.props["vfs.mount.windows"].toString;
        }
        else version(linux)
        {
            if ("vfs.appDataFolder.linux" in config.props)
                appDataFolderName = config.props["vfs.appDataFolder.linux"].toString;
            if ("vfs.mount.linux" in config.props)
                customMountPaths = config.props["vfs.mount.linux"].toString;
        }
        
        // Library settings
        if ("SDL2.path" in config.props)
            sdlLibraryPath = config.props["SDL2.path"].toString;
        if ("SDL2Image.path" in config.props)
            sdlLibraryPath = config.props["SDL2Image.path"].toString;
        if ("FreeType.path" in config.props)
            freetypeLibraryPath = config.props["FreeType.path"].toString;
        version(Windows)
        {
            if ("SDL2.path.windows" in config.props)
                sdlLibraryPath = config.props["SDL2.path.windows"].toString;
            if ("SDL2Image.path.windows" in config.props)
                sdlImageLibraryPath = config.props["SDL2Image.path.windows"].toString;
            if ("FreeType.path.windows" in config.props)
                freetypeLibraryPath = config.props["FreeType.path.windows"].toString;
        }
        else version(linux)
        {
            if ("SDL2.path.linux" in config.props)
                sdlLibraryPath = config.props["SDL2.path.linux"].toString;
            if ("SDL2Image.path.linux" in config.props)
                sdlImageLibraryPath = config.props["SDL2Image.path.linux"].toString;
            if ("FreeType.path.linux" in config.props)
                freetypeLibraryPath = config.props["FreeType.path.linux"].toString;
        }
        
        // Window settings
        if ("window.width" in config.props)
            windowWidth = config.props["window.width"].toUInt;
        if ("window.height" in config.props)
            windowHeight = config.props["window.height"].toUInt;
        
        if ("window.x" in config.props)
        {
            if (config.props["window.x"].type == DPropType.Number)
                windowX = config.props["window.x"].toInt;
            else
                windowX = SDL_WINDOWPOS_CENTERED;
        }
        if ("window.y" in config.props)
        {
            if (config.props["window.y"].type == DPropType.Number)
                windowY = config.props["window.y"].toInt;
            else
                windowY = SDL_WINDOWPOS_CENTERED;
        }
        
        if ("window.maximized" in config.props)
            windowMaximized = cast(bool)(config.props["window.maximized"].toUInt);
        
        if ("window.minimized" in config.props)
            windowMinimized = cast(bool)(config.props["window.minimized"].toUInt);
        
        if ("window.resizable" in config.props)
            windowResizable = cast(bool)config.props["window.resizable"].toUInt;
        
        if ("window.borderless" in config.props)
            windowBorderless = cast(bool)(config.props["window.borderless"].toUInt);
        
        if ("window.hiDPI" in config.props)
            windowHiDPI = cast(bool)config.props["window.hiDPI"].toUInt;
        
        if ("window.title" in config.props)
            windowTitle = config.props["window.title"].toString;
        
        if ("fullscreen" in config.props)
            fullscreen = cast(bool)(config.props["fullscreen"].toUInt);
        
        if ("fullscreenWindowed" in config.props)
        {
            if (config.props["fullscreenWindowed"].toUInt)
            {
                fullscreen = false;
                windowWidth = 0;
                windowHeight = 0;
                windowBorderless = true;
            }
        }
        
        if ("stereoRendering" in config.props)
            stereoRendering = cast(bool)config.props["stereoRendering"].toUInt;
        
        if ("vsync" in config.props)
            vsync = config.props["vsync"].toInt;
        if ("stepFrequency" in config.props)
        {
            if (config.props["stepFrequency"].type == DPropType.Number)
                stepFrequency = config.props["stepFrequency"].toUInt;
            else if (config.props["stepFrequency"].type == DPropType.String)
            {
                if (config.props["stepFrequency"].toString == "auto")
                    stepFrequency = 0; // same as display refresh rate
            }
        }
        if ("maxTimersCount" in config.props)
        {
            if (config.props["maxTimersCount"].type == DPropType.Number)
            {
                maxTimersCount = config.props["maxTimersCount"].toUInt;
                if (maxTimersCount == 0)
                    maxTimersCount = 1024;
            }
        }
        
        version(Windows)
        {
            if ("hideConsole" in config.props)
                if (config.props["hideConsole"].toUInt)
                    showConsoleWindow(false);
        }
        
        // Locale settings
        if ("localePath" in config.props)
            localePath = config.props["localePath"].toString;
        if ("locale" in config.props)
            userLocale = config.props["locale"].toString;
        
        // Font manager settings
        if ("font.sans" in config.props)
            defaultFontSans = config.props["font.sans"].toString;
        if ("font.monospace" in config.props)
            defaultFontMonospace = config.props["font.monospace"].toString;
        version(Windows)
        {
            if ("font.sans.windows" in config.props)
                defaultFontSans = config.props["font.sans.windows"].toString;
            if ("font.sans.monospace" in config.props)
                defaultFontMonospace = config.props["font.sans.monospace"].toString;
        }
        else version(linux)
        {
            if ("font.sans.linux" in config.props)
                defaultFontSans = config.props["font.sans.linux"].toString;
            if ("font.sans.linux" in config.props)
                defaultFontMonospace = config.props["font.sans.linux"].toString;
        }
        if ("font.size" in config.props)
            defaultFontSize = config.props["font.size"].toUInt;
    }

    /// Destructor. Cleans up resources and shuts down SDL.
    ~this()
    {
        releaseCompressedTextureFormats();

        SDL_GL_DeleteContext(glcontext);
        
        foreach(i, cur; cursor)
        {
            if (cur)
            {
                SDL_FreeCursor(cur);
                cursor[i] = null;
            }
        }
        
        SDL_DestroyWindow(window);
        SDL_Quit();
        Delete(_extensions);
        
        if (freetypePresent && ftLibrary)
            FT_Done_FreeType(ftLibrary);
        
        freeLogBuffer();
        
        if (vfs)
            Delete(vfs);
        
        if (timers.length)
            Delete(timers);
        
        logInfo("Exit Dagon application");
    }
    
    /**
     * Sets the window size.
     *
     * Params:
     *   w = New window width.
     *   h = New window height.
     */
    void setWindowSize(uint w, uint h)
    {
        SDL_SetWindowSize(window, w, h);
    }
    
    /// Centers the window on the screen.
    void centerWindow()
    {
        SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);
    }
    
    /// Maximizes the window.
    void maximizeWindow()
    {
        SDL_MaximizeWindow(window);
    }
    
    /// Set mouse cursor
    void setCursor(Cursor cur)
    {
        if (cur < cursor.length)
        {
            if (cursor[cur])
                SDL_SetCursor(cursor[cur]);
        }
    }
    
    /**
     * Switches fullscreen mode.
     *
     * Params:
     *   mode = If true, enables fullscreen; otherwise disables it.
     */
    void setFullscreen(bool mode)
    {
        if (mode)
            SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN);
        else
            SDL_SetWindowFullscreen(window, 0);
    }

    /// User event handler.
    override void onUserEvent(int code, void* payload)
    {
        if (code == DagonEvent.Exit)
        {
            exit();
        }
    }

    /**
     * Called every frame to update application logic.
     *
     * Params:
     *   t = Time information for the frame.
     */
    void onUpdate(Time t)
    {
        // Override me
    }

    /// Called every frame to render the scene.
    void onRender()
    {
        // Override me
    }

    /**
     * Called on each animation frame (cadencer tick).
     *
     * Params:
     *   t = Time information for the frame.
     */
    void update(Time t)
    {
        eventManager.update();
        processEvents();
        onUpdate(t);
        onRender();
        debug checkGLError();
        SDL_GL_SwapWindow(window);
    }

    /// Checks for OpenGL errors and logs them.
    void checkGLError()
    {
        GLenum error = GL_NO_ERROR;
        error = glGetError();
        if (error != GL_NO_ERROR)
        {
            logDebug("OpenGL error ", error, ": ", GLErrorStrings[error]);
        }
    }

    /**
     * Runs the main loop.
     * This will block the thread until the application terminates.
     */
    void run()
    {
        Time t = Time(0.0, 0.0);
        while(eventManager.running)
        {
            eventManager.updateTimer();
            t.delta = eventManager.deltaTime;
            cadencer.update(t);
            t.elapsed += t.delta;
        }
    }

    /// Terminates the application.
    void exit()
    {
        eventManager.exit();
    }
    
    /// Copies the current framebuffer to a texture. Texture must be the same size as the framebuffer.
    void takeScreenshot(Texture texture)
    {
        glBindTexture(GL_TEXTURE_2D, texture.texture);
        glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, drawableWidth, drawableHeight);
        glBindTexture(GL_TEXTURE_2D, 0);
    }
    
    /**
     * Takes a screenshot of the current framebuffer and returns it as an unmanaged SuperImage.
     *
     * Returns:
     *   The screenshot image.
     */
    SuperImage takeScreenshot()
    {
        ubyte[] data = New!(ubyte[])(drawableWidth * drawableHeight * 3);
        glReadPixels(0, 0, drawableWidth, drawableHeight, GL_RGB, GL_UNSIGNED_BYTE, data.ptr);
        SuperImage img = unmanagedImage(drawableWidth, drawableHeight, 3, 8);
        auto outputData = img.data;
        for (uint y = 0; y < drawableHeight; y++)
        {
            memcpy(
                &outputData[(drawableHeight - 1 - y) * drawableWidth * 3], 
                &data[y * drawableWidth * 3],
                drawableWidth * 3);
        }
        return img;
    }
    
    /**
     * Takes a screenshot and saves it to the specified path (auto-incrementing filename).
     *
     * Params:
     *   path = Base path for the screenshot file.
     */
    void takeScreenshot(string path)
    {
        // TODO: use vfs to save the file
        auto img = takeScreenshot();
        
        bool saved = false;
        while (!saved)
        {
            string filePath = path ~ screenNum.to!string ~ ".png";
            if (!fileExists(filePath))
            {
                img.savePNG(filePath);
                saved = true;
            }
            else screenNum++;
        }
        
        Delete(img);
    }
    
    /**
     * Returns the display's refresh rate, or `fallbackRefreshRate` if query fails.
     *
     * Params:
     *   fallbackRefreshRate = Fallback value in case of a query error.
     *
     * Returns:
     *   The refresh rate in Hz.
     */
    int displayRefreshRate(int fallbackRefreshRate = 60)
    {
        SDL_DisplayMode mode;
        int displayIndex = SDL_GetWindowDisplayIndex(window);
        if (SDL_GetDesktopDisplayMode(displayIndex, &mode) != 0)
            return fallbackRefreshRate;
        if (mode.refresh_rate == 0)
            return fallbackRefreshRate;
        return mode.refresh_rate;
    }
    
    /**
     * Sets the cadencer frequency to the display's refresh rate.
     *
     * Params:
     *   fallbackRefreshRate = Fallback value in case of a query error.
     *
     * Returns:
     *   The refresh rate in Hz.
     */
    int frequencyToRefreshRate(int fallbackRefreshRate = 60)
    {
        int refreshRate = displayRefreshRate(fallbackRefreshRate);
        cadencer.setFrequency(refreshRate);
        return refreshRate;
    }
    
    /// Mounts the specified ReadOnlyFileSystem to the virtual file system.
    void mount(ReadOnlyFileSystem fs)
    {
        vfs.mount(fs);
        logInfo("VFS: mount a filesystem");
    }
    
    /// Mounts the specified directory to the virtual file system.
    void mount(string dirName)
    {
        // TODO: create folder if needed
        vfs.mount(dirName);
        if (dirName == ".")
            logInfo("VFS: mount working directory");
        else
            logInfo("VFS: mount ", dirName);
    }
    
    /// Opens file stream for reading from the virtual file system.
    InputStream openFile(string filename)
    {
        FileStat stat;
        if (vfs.stat(filename, stat))
            return vfs.openForInput(filename);
        else
        {
            logError(filename, " is not found");
            return null;
        }
    }
    
    /**
     * Checks if a file exists in the VFS.
     *
     * Params:
     *   filename = Path to the file.
     * Returns:
     *   `true` if the file exists, `false` otherwise.
     */
    bool fileExists(string filename)
    {
        return vfs.exists(filename);
    }
    
    /**
     * Returns file status.
     *
     * Params:
     *   filename = Path to the file.
     * Returns:
     *   FileStat struct for the file.
     */
    FileStat fileStatus(string filename)
    {
        FileStat stat;
        vfs.stat(filename, stat);
        return stat;
    }
    
    /**
     * Switches console window visibility under Windows.
     * Under other OSes does nothing.
     *
     * Params:
     *   mode = show or hide the console window.
     */
    void showConsoleWindow(bool mode)
    {
        version(Windows)
        {
            if (mode)
                ShowWindow(GetConsoleWindow(), SW_SHOW);
            else
                ShowWindow(GetConsoleWindow(), SW_HIDE);
        }
    }
    
    version(Windows)
    {
        /**
         * Windows-only: returns HWND of the application window.
         */
        HWND hwnd()
        {
            return eventManager.wmInfo.info.win.window;
        }
    }
    
    /// Creates a new timer and returns it's ID.
    int setTimer(double duration, int userCode, bool periodic = false)
    {
        if (_numTimers == timers.length)
        {
            logError("Maximum timers count reached");
            return 0;
        }
        
        size_t index = timers.length;
        for (size_t i = 0; i < timers.length; i++)
        {
            if (!timers[i].active)
                index = i;
        }
        
        if (index >= timers.length)
        {
            logError("Maximum timers count reached");
            return 0;
        }
        
        TimerData* td = &timers[index];
        uint interval = cast(uint)(duration * 1000);
        *td = TimerData(this, index, 0, userCode, periodic, true);
        td.id = SDL_AddTimer(interval, &sdlTimerCallback, td);
        if (td.id > 0)
            _numTimers++;
        else
            td.active = false;
        logInfo("Timer ID: ", td.id);
        return td.id;
    }
    
    /// Cancels a timer.
    bool cancelTimer(int id)
    {
        if (id)
            return cast(bool)SDL_RemoveTimer(id);
        else
            return false;
    }
    
    /// Returns the number of currently active timers.
    size_t numActiveTimers()
    {
        return _numTimers;
    }
    
    /// 
    void completeTimer(size_t index) nothrow
    {
        TimerData* td = &timers[index];
        Event e;
        e.type = EventType.Timer;
        e.userCode = td.userEventCode;
        e.timerID = td.id;
        eventManager.queueEvent(e);
        if (!td.periodic)
        {
            SDL_RemoveTimer(td.id);
            td.active = false;
            _numTimers--;
        }
    }
}
