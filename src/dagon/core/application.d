/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Generic applicaton class and corresponding utility functions
 *
 * Description:
 * The `dagon.core.application` module provides the base `Application` class and related utilities
 * for creating and managing a Dagon engine application. This includes SDL window and OpenGL context 
 * management, event handling, functions for error handling and taking screenshots.
 *
 * Copyright: Timur Gafarov 2017-2025.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.core.application;

import std.stdio;
import std.conv;
import std.getopt;
import std.string;
import std.file;
import std.algorithm: canFind;
import std.process;
import core.stdc.stdlib;
import core.stdc.string;

import dlib.core.memory;
import dlib.core.stream;
import dlib.image;
import dlib.filesystem;
import dlib.text.str;

import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;
import dagon.core.logger;
import dagon.core.vfs;

import dagon.graphics.font;

version(Windows)
{ 
    import core.sys.windows.windows: SetConsoleCP, SetConsoleOutputCP;
    static this()
    { 
        SetConsoleCP(65001);
        SetConsoleOutputCP(65001);
    } 
}

/**
 * Immediately terminates the application,
 * printing an optional fatal error to the logger.
 *
 * Params:
 *   message = Optional error message to log before exiting.
 */
void exitWithError(string message = "")
{
    if (message.length)
    {
        logFatalError(message);
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Fatal error", message.toStringz, null);
    }
    core.stdc.stdlib.exit(1);
}

/**
 * Reserved event codes for Dagon applications.
 */
enum DagonEvent
{
    Exit = -1
}

/**
 * Supported image formats
 */
enum ImageFileFormat
{
    Unknown,
    PNG,
    JPEG,
    BMP,
    TGA,
    WebP,
    TIFF,
    JPEG_XL,
    AVIF,
    HDR,
    DDS,
    KTX,
    JPG = JPEG,
    WEBP = WebP
}

enum GL_FRAMEBUFFER_SRGB = 0x8DB9;

enum string[GLenum] GLErrorStrings = [
    GL_NO_ERROR: "GL_NO_ERROR",
    GL_INVALID_ENUM: "GL_INVALID_ENUM",
    GL_INVALID_VALUE: "GL_INVALID_VALUE",
    GL_INVALID_OPERATION: "GL_INVALID_OPERATION",
    GL_INVALID_FRAMEBUFFER_OPERATION: "GL_INVALID_FRAMEBUFFER_OPERATION",
    GL_OUT_OF_MEMORY: "GL_OUT_OF_MEMORY"
];

enum string[GLenum] GLDebugSourceStrings = [
    GL_DEBUG_SOURCE_API: "GL_DEBUG_SOURCE_API",
    GL_DEBUG_SOURCE_WINDOW_SYSTEM: "GL_DEBUG_SOURCE_WINDOW_SYSTEM",
    GL_DEBUG_SOURCE_SHADER_COMPILER: "GL_DEBUG_SOURCE_SHADER_COMPILER",
    GL_DEBUG_SOURCE_THIRD_PARTY: "GL_DEBUG_SOURCE_THIRD_PARTY",
    GL_DEBUG_SOURCE_APPLICATION: "GL_DEBUG_SOURCE_APPLICATION",
    GL_DEBUG_SOURCE_OTHER: "GL_DEBUG_SOURCE_OTHER"
];

enum string[GLenum] GLDebugTypeStrings = [
    GL_DEBUG_TYPE_ERROR: "GL_DEBUG_TYPE_ERROR",
    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR",
    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR",
    GL_DEBUG_TYPE_PORTABILITY: "GL_DEBUG_TYPE_PORTABILITY",
    GL_DEBUG_TYPE_PERFORMANCE: "GL_DEBUG_TYPE_PERFORMANCE",
    GL_DEBUG_TYPE_MARKER: "GL_DEBUG_TYPE_MARKER",
    GL_DEBUG_TYPE_PUSH_GROUP: "GL_DEBUG_TYPE_PUSH_GROUP",
    GL_DEBUG_TYPE_POP_GROUP: "GL_DEBUG_TYPE_POP_GROUP",
    GL_DEBUG_TYPE_OTHER: "GL_DEBUG_TYPE_OTHER"
];

enum string[GLenum] GLDebugSeverityStrings = [
    GL_DEBUG_SEVERITY_HIGH: "GL_DEBUG_SEVERITY_HIGH",
    GL_DEBUG_SEVERITY_MEDIUM: "GL_DEBUG_SEVERITY_MEDIUM",
    GL_DEBUG_SEVERITY_LOW: "GL_DEBUG_SEVERITY_LOW",
    GL_DEBUG_SEVERITY_NOTIFICATION: "GL_DEBUG_SEVERITY_NOTIFICATION"
];

extern(System) void messageCallback(
    GLenum source,
    GLenum type,
    GLuint id,
    GLenum severity,
    GLsizei length,
    const GLchar* message,
    const GLvoid* userParam) nothrow
{
    string msg = "%ssource = %s, type = %s, severity = %s, message = %s\n";
    string err = "OpenGL error: ";
    string empty = "";
    if (severity != GL_DEBUG_SEVERITY_NOTIFICATION)
    {
        string sourceStr = GLDebugSourceStrings[source];
        string typeStr = GLDebugTypeStrings[type];
        string severityStr = GLDebugSeverityStrings[severity];
        
        if (userParam)
        {
            Application app = cast(Application)userParam;
            if (app)
            {
                // Instead of calling logDebug directly (which is not nothrow), use the event loop
                app.eventManager.asyncLog(LogLevel.Debug, cast(string)message[0..length]);
            }
        }
        
        if (severity == GL_DEBUG_SEVERITY_HIGH)
            core.stdc.stdlib.exit(1);
    }
}

private
{
    __gshared int[] compressedTextureFormats;

    void enumerateCompressedTextureFormats()
    {
        int numCompressedFormats = 0;
        glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS, &numCompressedFormats);
        if (numCompressedFormats)
        {
            compressedTextureFormats = New!(int[])(numCompressedFormats);
            glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS, compressedTextureFormats.ptr);
        }
    }

    void releaseCompressedTextureFormats()
    {
        if (compressedTextureFormats.length)
            Delete(compressedTextureFormats);
    }
}

/**
 * Checks if a compressed texture format is supported.
 *
 * Params:
 *   format = The OpenGL enum value for the texture format.
 * Returns:
 *   `true` if the format is supported, `false` otherwise.
 */
bool compressedTextureFormatSupported(GLenum format)
{
    if (compressedTextureFormats.length)
        return compressedTextureFormats.canFind(format);
    else
        return false;
}

__gshared private
{
    bool[ImageFileFormat] _imageFileFormatSupported;
    GLint _maxTextureUnits;
    GLint _maxTextureSize;
    string[] _extensions;
}

/**
 * Checks if a given image file format is supported.
 *
 * Params:
 *   ffmt = The image file format to check.
 * Returns:
 *   `true` if supported, `false` otherwise.
 */
bool isImageFileFormatSupported(ImageFileFormat ffmt)
{
    if (ffmt in _imageFileFormatSupported)
        return _imageFileFormatSupported[ffmt];
    else
        return false;
}

/**
 * Returns the maximum number of texture units supported by the hardware.
 */
int maxTextureUnits()
{
    return _maxTextureUnits;
}

/**
 * Returns the maximum supported texture size.
 */
int maxTextureSize()
{
    return _maxTextureSize;
}

/**
 * Checks if a given OpenGL extension is supported.
 *
 * Params:
 *   extName = The name of the extension.
 * Returns:
 *   `true` if supported, `false` otherwise.
 */
bool isExtensionSupported(string extName)
{
    return _extensions.canFind(extName);
}

struct FTVersion
{
    int major, minor, patch;
}

enum Cursor: uint
{
    Default = 0,
    IBeam = 1,
    Wait = 2,
    Crosshair = 3,
    WaitArrow = 4,
    SizeNWSE = 5,
    SizeNESW = 6,
    SizeWE = 7,
    SizeNS = 8,
    SizeAll = 9,
    No = 10,
    Hand = 11
}

/**
 * Base class to inherit Dagon applications from.
 *
 * Description:
 * This class wraps SDL2 window creation, OpenGL context initialization,
 * event management, and provides the main game loop.
 * To use, inherit from `Application` and override `onUpdate` and `onRender`.
 */
class Application: EventListener
{
    VirtualFileSystem vfs;
    
    SDLSupport loadedSDLSupport;
    SDLImageSupport loadedSDLImageSupport;
    GLSupport loadedGLSupport;
    FTSupport loadedFTSupport;
    
    bool sdlImagePresent = true;
    bool freetypePresent = true;
    
    SDL_version sdlVersion;
    SDL_version sdlImageVersion;
    FTVersion ftVersion;
    
    uint width;
    uint height;
    bool fullscreen = false;
    
    SDL_Window* window = null;
    SDL_GLContext glcontext;
    
    private EventManager _eventManager;
    
    Cadencer cadencer;
    
    String glVersion;
    String glVendor;
    String glRenderer;
    
    FT_Library ftLibrary;
    FontManager fontManager;
    
    SDL_Cursor*[12] cursor;

    /**
     * Constructs the application, initializes SDL, OpenGL, and related subsystems.
     *
     * Params:
     *   winWidth = Window width in pixels.
     *   winHeight = Window height in pixels.
     *   fullscreen = If true, the application will run in fullscreen mode.
     *   windowTitle = The window title.
     *   args = Command line arguments.
     */
    this(uint winWidth, uint winHeight, bool fullscreen, string windowTitle, string[] args)
    {
        createVFS();
        
        version(linux)
            loadedSDLSupport = loadSDL("libSDL2-2.0.so.0");
        else
            loadedSDLSupport = loadSDL();
        
        if (loadedSDLSupport != sdlSupport)
        {
            if (loadedSDLSupport == SDLSupport.badLibrary)
                logWarning("Failed to load some SDL functions. It seems that you have an old version of SDL. Dagon will try to use it, but it is recommended to install SDL 2.30 or higher");
            else
                exitWithError("Error: SDL library is not found. Please, install SDL 2.30 or higher");
        }
        
        SDL_GetVersion(&sdlVersion);
        logInfo("SDL version: ", sdlVersion.major, ".", sdlVersion.minor, ".", sdlVersion.patch);
        
        loadedSDLImageSupport = loadSDLImage();
        
        if (loadedSDLImageSupport != sdlImageSupport)
        {
            if (loadedSDLImageSupport == SDLImageSupport.badLibrary)
            {
                logWarning("Failed to load some SDL2_Image functions. It seems that you have an old version of SDL2_Image. Dagon will try to use it, but it is recommended to install SDL2_Image 2.8 or higher");
            }
            else
            {
                logWarning("SDL2_Image library is not found. Please, install SDL2_Image 2.8 or higher");
                sdlImagePresent = false;
            }
        }
        
        loadedFTSupport = loadFreeType();
        
        if (loadedFTSupport != ftSupport)
        {
            if (loadedFTSupport == FTSupport.badLibrary)
            {
                logWarning("Failed to load some Freetype functions. It seems that you have an old version of Freetype. Dagon will try to use it, but it is recommended to install Freetype 2.8.1 or higher");
            }
            else
            {
                logError("Freetype library is not found. Please, install Freetype 2.8.1");
                freetypePresent = false;
            }
        }
        
        const(SDL_version)* pSdlImageVer = IMG_Linked_Version();
        sdlImageVersion = *pSdlImageVer;
        logInfo("SDL_Image version: ", sdlImageVersion.major, ".", sdlImageVersion.minor, ".", sdlImageVersion.patch);

        if (SDL_Init(SDL_INIT_EVERYTHING) == -1)
            exitWithError("Failed to init SDL: " ~ to!string(SDL_GetError()));

        width = winWidth;
        height = winHeight;
        this.fullscreen = fullscreen;
        
        _imageFileFormatSupported[ImageFileFormat.PNG] = true;
        _imageFileFormatSupported[ImageFileFormat.JPEG] = true;
        _imageFileFormatSupported[ImageFileFormat.BMP] = true;
        _imageFileFormatSupported[ImageFileFormat.TGA] = true;
        _imageFileFormatSupported[ImageFileFormat.HDR] = true;
        _imageFileFormatSupported[ImageFileFormat.DDS] = true;
        
        if (sdlImagePresent)
        {
            int desiredFormatFlags = IMG_INIT_JPG | IMG_INIT_PNG | IMG_INIT_TIF | IMG_INIT_WEBP | IMG_INIT_JXL | IMG_INIT_AVIF;
            int supportedFormatFlags = IMG_Init(desiredFormatFlags);
            if (supportedFormatFlags == 0)
            {
                logWarning("Failed to init SDL2_Image");
                sdlImagePresent = false;
            }
            
            _imageFileFormatSupported[ImageFileFormat.TIFF] = (supportedFormatFlags & IMG_INIT_TIF) > 0;
            _imageFileFormatSupported[ImageFileFormat.WebP] = (supportedFormatFlags & IMG_INIT_WEBP) > 0;
            _imageFileFormatSupported[ImageFileFormat.JPEG_XL] = (supportedFormatFlags & IMG_INIT_JXL) > 0;
            _imageFileFormatSupported[ImageFileFormat.AVIF] = (supportedFormatFlags & IMG_INIT_AVIF) > 0;
        }

        SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
        SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
        SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

        window = SDL_CreateWindow(toStringz(windowTitle),
            SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);
        if (window is null)
            exitWithError("Failed to create window: " ~ to!string(SDL_GetError()));

        glcontext = SDL_GL_CreateContext(window);
        if (glcontext is null)
            exitWithError("Failed to create OpenGL context: " ~ to!string(SDL_GetError()));
        SDL_GL_MakeCurrent(window, glcontext);
        SDL_GL_SetSwapInterval(1);
        
        loadedGLSupport = loadOpenGL();
        
        if (isOpenGLLoaded())
        {
            if (loadedGLSupport < GLSupport.gl40)
            {
                exitWithError("Dagon requires OpenGL 4.0, but it seems that your graphics card does not support it");
            }
        }
        else
        {
            exitWithError("Failed to load OpenGL functions. Please, update graphics card driver and make sure it supports OpenGL 4.0");
        }
        
        setFullscreen(fullscreen);

        _eventManager = New!EventManager(this);
        super(_eventManager, null);

        // Initialize OpenGL
        glVersion = String(glGetString(GL_VERSION));
        glVendor = String(glGetString(GL_VENDOR));
        glRenderer = String(glGetString(GL_RENDERER));
        logInfo("OpenGL version: ", glVersion);
        logInfo("OpenGL vendor: ", glVendor);
        logInfo("OpenGL renderer: ", glRenderer);
        
        // Get limits
        glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &_maxTextureUnits);
        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &_maxTextureSize);
        
        logInfo("GL_MAX_TEXTURE_IMAGE_UNITS: ", _maxTextureUnits);
        logInfo("GL_MAX_TEXTURE_SIZE: ", _maxTextureSize);
        
        // Get extensions list
        GLint numExtensions;
        glGetIntegerv(GL_NUM_EXTENSIONS, &numExtensions);
        _extensions = New!(string[])(numExtensions);
        for (GLint i = 0; i < numExtensions; i++) {
            _extensions[i] = glGetStringi(GL_EXTENSIONS, i).to!string;
        }
        
        logInfo("GL_ARB_texture_compression_bptc: ", isExtensionSupported("GL_ARB_texture_compression_bptc"));
        
        glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClearDepth(1.0);
        glEnable(GL_SCISSOR_TEST);
        glDepthFunc(GL_LESS);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_POLYGON_OFFSET_FILL);
        glCullFace(GL_BACK);
        glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        SDL_GL_SwapWindow(window);

        enumerateCompressedTextureFormats();

        // Debug output
        debug
        {
            if (hasKHRDebug)
            {
                glEnable(GL_DEBUG_OUTPUT);
                glDebugMessageCallback(&messageCallback, cast(void*)this);
            }
            else
            {
                logWarning("GL_KHR_debug is not supported, debug output is not available");
            }
        }
        
        cadencer = New!Cadencer(&onAnimationFrame, 60, this);
        
        if (freetypePresent)
        {
            if (FT_Init_FreeType(&ftLibrary))
            {
                logError("FT_Init_FreeType failed");
                freetypePresent = false;
            }
            else
            {
                FT_Library_Version(ftLibrary, &ftVersion.major, &ftVersion.minor, &ftVersion.patch);
                logInfo("Freetype version: ", ftVersion.major, ".", ftVersion.minor, ".", ftVersion.patch);
            }
        }
        
        fontManager = New!FontManager(this);
        
        cursor[Cursor.Default] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        cursor[Cursor.IBeam] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_IBEAM);
        cursor[Cursor.Wait] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAIT);
        cursor[Cursor.Crosshair] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
        cursor[Cursor.WaitArrow] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAITARROW);
        cursor[Cursor.SizeNWSE] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE);
        cursor[Cursor.SizeNESW] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENESW);
        cursor[Cursor.SizeWE] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEWE);
        cursor[Cursor.SizeNS] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENS);
        cursor[Cursor.SizeAll] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
        cursor[Cursor.No] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_NO);
        cursor[Cursor.Hand] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    }
    
    protected void createVFS()
    {
        if (vfs is null)
        {
            vfs = New!VirtualFileSystem();
            vfs.mount(".");
        }
    }

    /// Destructor. Cleans up resources and shuts down SDL.
    ~this()
    {
        releaseCompressedTextureFormats();

        SDL_GL_DeleteContext(glcontext);
        
        foreach(i, cur; cursor)
        {
            if (cur)
            {
                SDL_FreeCursor(cur);
                cursor[i] = null;
            }
        }
        
        SDL_DestroyWindow(window);
        SDL_Quit();
        Delete(_eventManager);
        Delete(_extensions);
        
        if (freetypePresent && ftLibrary)
            FT_Done_FreeType(ftLibrary);
        
        freeLogBuffer();
        
        if (vfs)
            Delete(vfs);
    }
    
    /**
     * Sets the window size.
     *
     * Params:
     *   w = New window width.
     *   h = New window height.
     */
    void setWindowSize(uint w, uint h)
    {
        SDL_SetWindowSize(window, w, h);
    }
    
    /// Centers the window on the screen.
    void centerWindow()
    {
        SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);
    }
    
    /// Maximizes the window.
    void maximizeWindow()
    {
        SDL_MaximizeWindow(window);
    }
    
    /// Set mouse cursor
    void setCursor(Cursor cur)
    {
        if (cur < cursor.length)
        {
            if (cursor[cur])
                SDL_SetCursor(cursor[cur]);
        }
    }
    
    /**
     * Switches fullscreen mode.
     *
     * Params:
     *   mode = If true, enables fullscreen; otherwise disables it.
     */
    void setFullscreen(bool mode)
    {
        if (mode)
            SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN);
        else
            SDL_SetWindowFullscreen(window, 0);
    }

    override void onUserEvent(int code)
    {
        if (code == DagonEvent.Exit)
        {
            exit();
        }
    }
    
    override void onResize(int width, int height)
    {
        this.width = width;
        this.height = height;
    }

    /**
     * Called every frame to update application logic.
     *
     * Params:
     *   t = Time information for the frame.
     */
    void onUpdate(Time t)
    {
        // Override me
    }

    /// Called every frame to render the scene.
    void onRender()
    {
        // Override me
    }

    /**
     * Called on each animation frame (cadencer tick).
     *
     * Params:
     *   t = Time information for the frame.
     */
    void onAnimationFrame(Time t)
    {
        eventManager.update();
        processEvents();
        onUpdate(t);
        onRender();
        debug checkGLError();
        SDL_GL_SwapWindow(window);
    }

    /// Checks for OpenGL errors and logs them.
    void checkGLError()
    {
        GLenum error = GL_NO_ERROR;
        error = glGetError();
        if (error != GL_NO_ERROR)
        {
            logDebug("OpenGL error %s: %s", error, GLErrorStrings[error]);
        }
    }

    /// Runs the main application loop.
    void run()
    {
        Time t = Time(0.0, 0.0);
        while(eventManager.running)
        {
            eventManager.updateTimer();
            t.delta = eventManager.deltaTime;
            cadencer.update(t);
            t.elapsed += t.delta;
        }
    }

    /// Exits the application.
    void exit()
    {
        eventManager.exit();
    }
    
    uint screenNum = 0;
    
    /**
     * Takes a screenshot of the current framebuffer and returns it as a SuperImage.
     *
     * Returns:
     *   The screenshot image.
     */
    SuperImage takeScreenshot()
    {
        ubyte[] data = New!(ubyte[])(width * height * 3);
        glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, data.ptr);
        SuperImage img = unmanagedImage(width, height, 3, 8);
        auto outputData = img.data;
        for (uint y = 0; y < height; y++)
        {
            memcpy(&outputData[(height - 1 - y) * width * 3], &data[y * width * 3], width * 3);
        }
        return img;
    }
    
    /**
     * Takes a screenshot and saves it to the specified path (auto-incrementing filename).
     *
     * Params:
     *   path = Base path for the screenshot file.
     */
    void takeScreenshot(string path)
    {
        // TODO: use vfs to save the file
        auto img = takeScreenshot();
        
        bool saved = false;
        while (!saved)
        {
            string filePath = path ~ screenNum.to!string ~ ".png";
            if (!fileExists(filePath))
            {
                img.savePNG(filePath);
                saved = true;
            }
            else screenNum++;
        }
        
        Delete(img);
    }
    
    /**
     * Returns the display's refresh rate.
     *
     * Returns:
     *   The refresh rate in Hz.
     */
    int displayRefreshRate()
    {
        SDL_DisplayMode mode;
        int displayIndex = SDL_GetWindowDisplayIndex(window);
        int defaultRefreshRate = 60;
        if (SDL_GetDesktopDisplayMode(displayIndex, &mode) != 0)
            return defaultRefreshRate;
        if (mode.refresh_rate == 0)
            return defaultRefreshRate;
        return mode.refresh_rate;
    }
    
    /**
     * Sets the cadencer frequency to the display's refresh rate.
     *
     * Returns:
     *   The refresh rate in Hz.
     */
    int frequencyToRefreshRate()
    {
        int refreshRate = displayRefreshRate();
        cadencer.setFrequency(refreshRate);
        return refreshRate;
    }
    
    /// Mounts the specified ReadOnlyFileSystem to the virtual file system.
    void mount(ReadOnlyFileSystem fs)
    {
        vfs.mount(fs);
        logInfo("VFS: mounted a filesystem");
    }
    
    /// Mounts the specified directory to the virtual file system.
    void mount(string dirName)
    {
        vfs.mount(dirName);
        logInfo("VFS: mounted ", dirName);
    }
    
    /**
     * Mounts the game folder in application data directory
     * to the virtual file system.
     */
    void mountAppDataFolder(string gameID)
    {
        string homeDirVar = "";
        version(Windows) homeDirVar = "APPDATA";
        version(Posix) homeDirVar = "HOME";
        auto homeDir = environment.get(homeDirVar, "");
        if (homeDir.length)
        {
            string dirSeparator;
            version(Windows) dirSeparator = "\\";
            version(Posix) dirSeparator = "/";
            string appdataDir = format("%s%s.%s", homeDir, dirSeparator, gameID);
            vfs.mount(appdataDir);
            logInfo("VFS: mounted ", appdataDir);
        }
    }
    
    /// Opens file stream for reading from the virtual file system.
    InputStream openFile(string filename)
    {
        FileStat stat;
        if (vfs.stat(filename, stat))
            return vfs.openForInput(filename);
        else
        {
            logError(filename, " is not found");
            return null;
        }
    }
    
    /**
     * Checks if a file exists in the VFS.
     *
     * Params:
     *   filename = Path to the file.
     * Returns:
     *   `true` if the file exists, `false` otherwise.
     */
    bool fileExists(string filename)
    {
        FileStat stat;
        return vfs.stat(filename, stat);
    }
    
    /**
     * Returns file status.
     *
     * Params:
     *   filename = Path to the file.
     * Returns:
     *   FileStat struct for the file.
     */
    FileStat fileStatus(string filename)
    {
        FileStat stat;
        vfs.stat(filename, stat);
        return stat;
    }
}
