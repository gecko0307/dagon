/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Generic applicaton class and corresponding utility functions
 *
 * Description:
 * The `dagon.core.application` module provides the base `Application` class and related functionality
 * for creating and managing a Dagon-based application. This includes SDL window and OpenGL context 
 * management, event handling, functions for error handling, taking screenshots and others.
 *
 * Copyright: Timur Gafarov 2017-2025.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.core.application;

import std.stdio;
import std.conv;
import std.getopt;
import std.string;
import std.file;
import std.path;
import std.algorithm: canFind;
import std.process;
import core.stdc.stdlib;
import core.stdc.string;

import dlib.core.memory;
import dlib.core.stream;
import dlib.image;
import dlib.filesystem;
import dlib.text.str;

import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;
import dagon.core.logger;
import dagon.core.vfs;
import dagon.core.props;
import dagon.core.config;
import dagon.core.locale;
import dagon.core.i18n;

import dagon.graphics.updateable;
import dagon.graphics.font;
import dagon.graphics.shader;

version(Windows)
{
    pragma(lib, "user32");
    
    import core.sys.windows.windows;
    import dagon.core.wintab;
    
    static this()
    { 
        SetConsoleCP(65001);
        SetConsoleOutputCP(65001);
    }
}

/**
 * Immediately terminates the application,
 * printing an optional fatal error to the logger.
 *
 * Params:
 *   message = Optional error message to log before exiting.
 */
void exitWithError(string message = "")
{
    if (message.length)
    {
        logFatalError(message);
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Fatal error", message.toStringz, null);
    }
    core.stdc.stdlib.exit(1);
}

/**
 * Reserved event codes for Dagon applications.
 */
enum DagonEvent
{
    Exit = -1
}

/**
 * Supported image formats
 */
enum ImageFileFormat
{
    Unknown,
    PNG,
    JPEG,
    BMP,
    TGA,
    WebP,
    TIFF,
    JPEG_XL,
    AVIF,
    HDR,
    DDS,
    KTX,
    JPG = JPEG,
    WEBP = WebP
}

enum GL_FRAMEBUFFER_SRGB = 0x8DB9;

enum string[GLenum] GLErrorStrings = [
    GL_NO_ERROR: "GL_NO_ERROR",
    GL_INVALID_ENUM: "GL_INVALID_ENUM",
    GL_INVALID_VALUE: "GL_INVALID_VALUE",
    GL_INVALID_OPERATION: "GL_INVALID_OPERATION",
    GL_INVALID_FRAMEBUFFER_OPERATION: "GL_INVALID_FRAMEBUFFER_OPERATION",
    GL_OUT_OF_MEMORY: "GL_OUT_OF_MEMORY"
];

enum string[GLenum] GLDebugSourceStrings = [
    GL_DEBUG_SOURCE_API: "GL_DEBUG_SOURCE_API",
    GL_DEBUG_SOURCE_WINDOW_SYSTEM: "GL_DEBUG_SOURCE_WINDOW_SYSTEM",
    GL_DEBUG_SOURCE_SHADER_COMPILER: "GL_DEBUG_SOURCE_SHADER_COMPILER",
    GL_DEBUG_SOURCE_THIRD_PARTY: "GL_DEBUG_SOURCE_THIRD_PARTY",
    GL_DEBUG_SOURCE_APPLICATION: "GL_DEBUG_SOURCE_APPLICATION",
    GL_DEBUG_SOURCE_OTHER: "GL_DEBUG_SOURCE_OTHER"
];

enum string[GLenum] GLDebugTypeStrings = [
    GL_DEBUG_TYPE_ERROR: "GL_DEBUG_TYPE_ERROR",
    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR",
    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR",
    GL_DEBUG_TYPE_PORTABILITY: "GL_DEBUG_TYPE_PORTABILITY",
    GL_DEBUG_TYPE_PERFORMANCE: "GL_DEBUG_TYPE_PERFORMANCE",
    GL_DEBUG_TYPE_MARKER: "GL_DEBUG_TYPE_MARKER",
    GL_DEBUG_TYPE_PUSH_GROUP: "GL_DEBUG_TYPE_PUSH_GROUP",
    GL_DEBUG_TYPE_POP_GROUP: "GL_DEBUG_TYPE_POP_GROUP",
    GL_DEBUG_TYPE_OTHER: "GL_DEBUG_TYPE_OTHER"
];

enum string[GLenum] GLDebugSeverityStrings = [
    GL_DEBUG_SEVERITY_HIGH: "GL_DEBUG_SEVERITY_HIGH",
    GL_DEBUG_SEVERITY_MEDIUM: "GL_DEBUG_SEVERITY_MEDIUM",
    GL_DEBUG_SEVERITY_LOW: "GL_DEBUG_SEVERITY_LOW",
    GL_DEBUG_SEVERITY_NOTIFICATION: "GL_DEBUG_SEVERITY_NOTIFICATION"
];

extern(System) void messageCallback(
    GLenum source,
    GLenum type,
    GLuint id,
    GLenum severity,
    GLsizei length,
    const GLchar* message,
    const GLvoid* userParam) nothrow
{
    string msg = "%ssource = %s, type = %s, severity = %s, message = %s\n";
    string err = "OpenGL error: ";
    string empty = "";
    if (severity != GL_DEBUG_SEVERITY_NOTIFICATION)
    {
        string sourceStr = GLDebugSourceStrings[source];
        string typeStr = GLDebugTypeStrings[type];
        string severityStr = GLDebugSeverityStrings[severity];
        
        if (userParam)
        {
            Application app = cast(Application)userParam;
            if (app)
            {
                // Instead of calling logDebug directly (which is not nothrow), use the event loop
                app.eventManager.queueLogEvent(LogLevel.Debug, cast(string)message[0..length]);
            }
        }
        
        if (severity == GL_DEBUG_SEVERITY_HIGH)
            core.stdc.stdlib.exit(1);
    }
}

private
{
    __gshared int[] compressedTextureFormats;

    void enumerateCompressedTextureFormats()
    {
        int numCompressedFormats = 0;
        glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS, &numCompressedFormats);
        if (numCompressedFormats)
        {
            compressedTextureFormats = New!(int[])(numCompressedFormats);
            glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS, compressedTextureFormats.ptr);
        }
    }

    void releaseCompressedTextureFormats()
    {
        if (compressedTextureFormats.length)
            Delete(compressedTextureFormats);
    }
}

/**
 * Checks if a compressed texture format is supported.
 *
 * Params:
 *   format = The OpenGL enum value for the texture format.
 * Returns:
 *   `true` if the format is supported, `false` otherwise.
 */
bool compressedTextureFormatSupported(GLenum format)
{
    if (compressedTextureFormats.length)
        return compressedTextureFormats.canFind(format);
    else
        return false;
}

__gshared private
{
    bool[ImageFileFormat] _imageFileFormatSupported;
    GLint _maxTextureUnits;
    GLint _maxTextureSize;
    string[] _extensions;
    
    VirtualFileSystem _vfs;
    ShaderCache _globalShaderCache;
}

/**
 * Checks if a given image file format is supported.
 *
 * Params:
 *   ffmt = The image file format to check.
 * Returns:
 *   `true` if supported, `false` otherwise.
 */
bool isImageFileFormatSupported(ImageFileFormat ffmt)
{
    if (ffmt in _imageFileFormatSupported)
        return _imageFileFormatSupported[ffmt];
    else
        return false;
}

/**
 * Returns the maximum number of texture units supported by the hardware.
 */
int maxTextureUnits()
{
    return _maxTextureUnits;
}

/**
 * Returns the maximum supported texture size.
 */
int maxTextureSize()
{
    return _maxTextureSize;
}

/**
 * Checks if a given OpenGL extension is supported.
 *
 * Params:
 *   extName = The name of the extension.
 * Returns:
 *   `true` if supported, `false` otherwise.
 */
bool isExtensionSupported(string extName)
{
    return _extensions.canFind(extName);
}

struct FTVersion
{
    int major, minor, patch;
}

/// Supported cursor types.
enum Cursor: uint
{
    Default = 0,
    IBeam = 1,
    Wait = 2,
    Crosshair = 3,
    WaitArrow = 4,
    SizeNWSE = 5,
    SizeNESW = 6,
    SizeWE = 7,
    SizeNS = 8,
    SizeAll = 9,
    No = 10,
    Hand = 11
}

/// Returns VFS used by the Application.
VirtualFileSystem globalVFS()
{
    return _vfs;
}

ShaderCache globalShaderCache()
{
    return _globalShaderCache;
}

/**
 * Base class to inherit application object from.
 *
 * Description:
 * This class wraps dynamic library binding, SDL window creation, OpenGL context initialization and
 * information querying, event management, and the main game loop. It also handles basic configuration
 * via `settings.conf` file and provides a number of helper methods (taking screenshots, querying display
 * refresh rate, switching console window, etc.).
 * By itself, `Application` doesn't render anything and doesn't contain game logic. To make a game,
 * inherit from `Application` and override `onUpdate` and `onRender`.
 */
class Application: EventListener, Updateable
{
    protected string configFilename = "settings.conf";
    
    /// Initial log level.
    LogLevel logLevel = LogLevel.Info;
    
    /// Command line arguments.
    string[] args;
    
    /// Full path of the executable (not CWD!).
    string path;
    
    /// Absolute directory containing the executable.
    string directory;
    
    ///
    string appDataFolderName;
    
    ///
    string sdlLibraryPath = "auto";
    
    ///
    string sdlImageLibraryPath = "auto";
    
    ///
    string freetypeLibraryPath = "auto";
    
    /// Global VFS that all resource loaders should use.
    VirtualFileSystem vfs;
    
    /// The configuration object for storing user-defined settings.
    Configuration config;
    
    /**
     * Loaded SDL API version. This is not an actual SDL library version!
     * Dagon assumes SDLSupport.v2_30, but this is not a strict requirement,
     * the engine will continue running even if 2.30 fails to load.
     * To check actually loaded library version, use `sdlVersion`.
     */
    SDLSupport loadedSDLSupport;
    
    /**
     * Loaded SDL_Image API version. This is not an actual SDL_Image library version!
     * Dagon assumes SDLImageSupport.v2_8, but this is not a strict requirement,
     * the engine will continue running even if 2.8 fails to load.
     * To check actually loaded library version, use `sdlImageVersion`.
     */
    SDLImageSupport loadedSDLImageSupport;
    
    /**
     * Loaded OpenGL API version.
     * Dagon requires at least GLSupport.gl43 and will not run on a lower version.
     */
    GLSupport loadedGLSupport;
    
    /**
     * Loaded FreeType API version. This is not an actual FreeType library version!
     * Dagon assumes FTSupport.v2_8, but this is not a strict requirement,
     * the engine will continue running even if 2.8 fails to load.
     * To check actually loaded library version, use `ftVersion`.
     */
    FTSupport loadedFTSupport;
    
    /// SDL_Image available or not.
    bool sdlImagePresent = true;
    
    /// FreeType available or not.
    bool freetypePresent = true;
    
    /// Wintab available or not.
    bool wintabPresent = false;
    
    /// Actually used SDL library version.
    SDL_version sdlVersion;
    
    /// Actually used SDL_Image library version.
    SDL_version sdlImageVersion;
    
    /// Actually used FreeType library version.
    FTVersion ftVersion;
    
    /// Application window width.
    uint width;
    
    /// Application window height.
    uint height;
    
    /// Application window X-coordinate.
    int windowX = SDL_WINDOWPOS_CENTERED;
    
    /// Application window Y-coordinate.
    int windowY = SDL_WINDOWPOS_CENTERED;
    
    ///
    string windowTitle;
    
    ///
    bool windowResizable = true;
    
    /// Fullscreen or windowed.
    bool fullscreen = false;
    
    ///
    int vsync = 1;
    
    ///
    uint stepFrequency = 60;
    
    ///
    bool enableDebugOutput = false;
    
    ///
    bool enableShaderCache = false;
    
    ///
    string defaultFontSans = "data/__internal/fonts/LiberationSans-Regular.ttf";
    
    ///
    string defaultFontMonospace = "data/__internal/fonts/LiberationMono-Regular.ttf";
    
    ///
    uint defaultFontSize = 10;
    
    /// Pointer to the main SDL window created by the Application.
    SDL_Window* window = null;
    
    /// OpenGL context.
    SDL_GLContext glcontext;
    
    private EventManager _eventManager;
    
    /// Main loop runner. Calls `Application.update` with a given fixed frequency (60 Hz by default).
    Cadencer cadencer;
    
    /// OpenGL version string obtained from the graphics driver.
    String glVersion;
    
    /// OpenGL vendor string obtained from the graphics driver.
    String glVendor;
    
    /// OpenGL renderer string (graphics card model) obtained from the graphics driver.
    String glRenderer;
    
    /**
     * Maximum supported level of anisotropic texture filtering.
     * If anisotropic filtering is not supported, this is set to zero.
     */
    float maxTextureAnisotropy = 8.0f;
    
    /// Maximum number of workgroups per compute dispatch.
    int[3] maxWorkGroups;
    
    /// Maximum size of a single workgorup in a compute shader.
    int[3] maxWorkGroupSize;
    
    /// System locale (ISO 639 language + ISO 3166 region)
    string locale = "en_US";
    
    /// User-defined locale (ISO 639 language + ISO 3166 region). Overrides system locale.
    string userLocale = "en_US";
    
    /// Loaded translation (from locale/*.lang file) based on selected locale.
    Translation translation;
    
    /// Handle to a FreeType library instance.
    FT_Library ftLibrary;
    
    /// Object that loads and registers fonts.
    FontManager fontManager;
    
    /// Shader cache.
    ShaderCache shaderCache;
    
    protected SDL_Cursor*[12] cursor;

    /**
     * Constructs the application, initializes SDL, OpenGL, and related subsystems.
     *
     * Params:
     *   winWidth = Window width in pixels.
     *   winHeight = Window height in pixels.
     *   fullscreen = If true, the application will run in fullscreen mode.
     *   windowTitle = The window title.
     *   args = Command line arguments.
     *   appDataFolderName = The application folder name (used under the HOME or APPDATA directory).
     */
    this(uint winWidth, uint winHeight, bool fullscreen, string windowTitle, string[] args, string appDataFolderName = ".dagon")
    {
        // Initialize with hardcoded parameters
        this.width = winWidth;
        this.height = winHeight;
        this.fullscreen = fullscreen;
        this.windowTitle = windowTitle;
        this.args = args;
        
        debug
        {
            logOutputOptions.enabled = true;
            this.logLevel = LogLevel.Debug;
        }
        
        dagon.core.logger.logLevel = this.logLevel;
        
        // Important paths
        this.path = thisExePath();
        this.directory = dirName(path);
        this.appDataFolderName = appDataFolderName;
        
        // Set default locale
        locale = systemLocale();
        userLocale = locale;
        
        // Create VFS
        vfs = New!VirtualFileSystem();
        
        // Create main config
        config = New!Configuration(this);
        bool configFileFound = false;
        
        // Load initial config from executable directory
        String initConfigPath = String(directory);
        initConfigPath ~= dirSeparator;
        initConfigPath ~= configFilename;
        FileStat stat;
        if (vfs.stdfs.stat(configFilename, stat))
        {
            auto istrm = vfs.stdfs.openForInput(initConfigPath);
            auto initConfig = readText(istrm);
            Delete(istrm);
            if (config.fromString(initConfig))
            {
                updateSettings();
                configFileFound = true;
            }
            Delete(initConfig);
        }
        initConfigPath.free();
        
        logInfo("System locale: ", locale);
        logInfo("Selected locale: ", userLocale);
        
        // Mount additional directories to the VFS
        mount(this.directory);
        if (appDataFolderName.length > 0)
        {
            vfs.mountAppDataDirectory(appDataFolderName);
            logInfo("VFS: mounted ", vfs.appDataPath);
        }
        _vfs = vfs;
        
        // Load overrifing configs from additional VFS directories
        if (vfs.mounted.length > 1)
        {
            foreach(fs; vfs.mounted.data[1..$])
            {
                if (config.fromFile(fs, configFilename))
                {
                    updateSettings();
                    configFileFound = true;
                }
            }
        }
        
        if (!configFileFound)
            logWarning("No \"", configFilename, "\" found");
        
        // Load selected translation
        translation = New!Translation(this, this);
        translation.load("en_US");
        if (userLocale != "en_US")
            translation.load(userLocale);
        
        // Load shared libraries
        version(linux)
        {
            if (sdlLibraryPath == "auto")
                sdlLibraryPath = "libSDL2-2.0.so.0";
            
            if (sdlImageLibraryPath == "auto")
                sdlImageLibraryPath = "libSDL2_image-2.0.so";
            
            if (freetypeLibraryPath == "auto")
                freetypeLibraryPath = "";
        }
        else version(Windows)
        {
            if (sdlLibraryPath == "auto")
                sdlLibraryPath = "SDL2.dll";
            
            if (sdlImageLibraryPath == "auto")
                sdlImageLibraryPath = "SDL2_image.dll";
            
            if (freetypeLibraryPath == "auto")
                freetypeLibraryPath = "";
        }
        
        if (sdlLibraryPath.length)
            loadedSDLSupport = loadSDL(sdlLibraryPath.toStringz);
        else
            loadedSDLSupport = loadSDL();
        
        if (loadedSDLSupport != sdlSupport)
        {
            if (loadedSDLSupport == SDLSupport.badLibrary)
                logWarning("Failed to load some SDL functions. It seems that you have an old version of SDL. Dagon will try to use it, but it is recommended to install SDL 2.30 or higher");
            else
                exitWithError("Error: SDL library is not found. Please, install SDL 2.30 or higher");
        }
        
        SDL_GetVersion(&sdlVersion);
        logInfo("SDL version: ", sdlVersion.major, ".", sdlVersion.minor, ".", sdlVersion.patch);
        
        if (sdlImageLibraryPath.length)
            loadedSDLImageSupport = loadSDLImage(sdlImageLibraryPath.toStringz);
        else
            loadedSDLImageSupport = loadSDLImage();
        
        if (loadedSDLImageSupport != sdlImageSupport)
        {
            if (loadedSDLImageSupport == SDLImageSupport.badLibrary)
            {
                logWarning("Failed to load some SDL2_Image functions. It seems that you have an old version of SDL2_Image. Dagon will try to use it, but it is recommended to install SDL2_Image 2.8 or higher");
            }
            else
            {
                logWarning("SDL2_Image library is not found. Please, install SDL2_Image 2.8 or higher");
                sdlImagePresent = false;
            }
        }
        
        if (freetypeLibraryPath.length)
            loadedFTSupport = loadFreeType(freetypeLibraryPath.toStringz);
        else
            loadedFTSupport = loadFreeType();
        
        if (loadedFTSupport != ftSupport)
        {
            if (loadedFTSupport == FTSupport.badLibrary)
            {
                logWarning("Failed to load some Freetype functions. It seems that you have an old version of Freetype. Dagon will try to use it, but it is recommended to install Freetype 2.8.1 or higher");
            }
            else
            {
                logError("Freetype library is not found. Please, install Freetype 2.8.1");
                freetypePresent = false;
            }
        }
        
        version(Windows)
        {
            // TODO: wintabLibraryPath
            WintabSupport loadedWintabSupport = loadWintab();
            if (loadedWintabSupport != WintabSupport.v140)
            {
                if (loadedWintabSupport == WintabSupport.badLibrary)
                {
                    logWarning("Failed to load some Wintab functions");
                    wintabPresent = true;
                }
                else
                {
                    logError("Wintab library is not found");
                }
            }
        }
        
        const(SDL_version)* pSdlImageVer = IMG_Linked_Version();
        sdlImageVersion = *pSdlImageVer;
        logInfo("SDL_Image version: ", sdlImageVersion.major, ".", sdlImageVersion.minor, ".", sdlImageVersion.patch);

        // Init SDL
        if (SDL_Init(SDL_INIT_EVERYTHING) == -1)
            exitWithError("Failed to init SDL: " ~ to!string(SDL_GetError()));

        SDL_Rect desktopBounds;
        SDL_GetDisplayBounds(0, &desktopBounds);
        
        if (width == 0)
            width = desktopBounds.w;
        if (height == 0)
            height = desktopBounds.h;
        
        _imageFileFormatSupported[ImageFileFormat.PNG] = true;
        _imageFileFormatSupported[ImageFileFormat.JPEG] = true;
        _imageFileFormatSupported[ImageFileFormat.BMP] = true;
        _imageFileFormatSupported[ImageFileFormat.TGA] = true;
        _imageFileFormatSupported[ImageFileFormat.HDR] = true;
        _imageFileFormatSupported[ImageFileFormat.DDS] = true;
        
        if (sdlImagePresent)
        {
            int desiredFormatFlags = IMG_INIT_JPG | IMG_INIT_PNG | IMG_INIT_TIF | IMG_INIT_WEBP | IMG_INIT_JXL | IMG_INIT_AVIF;
            int supportedFormatFlags = IMG_Init(desiredFormatFlags);
            if (supportedFormatFlags == 0)
            {
                logWarning("Failed to init SDL2_Image");
                sdlImagePresent = false;
            }
            
            _imageFileFormatSupported[ImageFileFormat.TIFF] = (supportedFormatFlags & IMG_INIT_TIF) > 0;
            _imageFileFormatSupported[ImageFileFormat.WebP] = (supportedFormatFlags & IMG_INIT_WEBP) > 0;
            _imageFileFormatSupported[ImageFileFormat.JPEG_XL] = (supportedFormatFlags & IMG_INIT_JXL) > 0;
            _imageFileFormatSupported[ImageFileFormat.AVIF] = (supportedFormatFlags & IMG_INIT_AVIF) > 0;
        }

        SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
        SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
        SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
        
        uint windowFlags = SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL;
        if (windowResizable)
            windowFlags |= SDL_WINDOW_RESIZABLE;

        window = SDL_CreateWindow(toStringz(windowTitle), windowX, windowY, width, height, windowFlags);
        if (window is null)
            exitWithError("Failed to create window: " ~ to!string(SDL_GetError()));

        glcontext = SDL_GL_CreateContext(window);
        if (glcontext is null)
            exitWithError("Failed to create OpenGL context: " ~ to!string(SDL_GetError()));
        SDL_GL_MakeCurrent(window, glcontext);
        
        SDL_GL_SetSwapInterval(vsync);
        
        loadedGLSupport = loadOpenGL();
        
        if (isOpenGLLoaded())
        {
            if (loadedGLSupport < GLSupport.gl43)
            {
                exitWithError("Dagon requires OpenGL 4.3, but it seems that your graphics card does not support it");
            }
        }
        else
        {
            exitWithError("Failed to load OpenGL functions. Please, update graphics card driver and make sure it supports OpenGL 4.3");
        }
        
        setFullscreen(fullscreen);

        _eventManager = New!EventManager(this);
        super(_eventManager, null);

        // Initialize OpenGL
        glVersion = String(glGetString(GL_VERSION));
        glVendor = String(glGetString(GL_VENDOR));
        glRenderer = String(glGetString(GL_RENDERER));
        logInfo("OpenGL version: ", glVersion);
        logInfo("OpenGL vendor: ", glVendor);
        logInfo("OpenGL renderer: ", glRenderer);
        
        // Get OpenGL limits
        glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &_maxTextureUnits);
        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &_maxTextureSize);
        logInfo("GL_MAX_TEXTURE_IMAGE_UNITS: ", _maxTextureUnits);
        logInfo("GL_MAX_TEXTURE_SIZE: ", _maxTextureSize);
        
        // Get OpenGL extensions list
        GLint numExtensions;
        glGetIntegerv(GL_NUM_EXTENSIONS, &numExtensions);
        _extensions = New!(string[])(numExtensions);
        for (GLint i = 0; i < numExtensions; i++)
        {
            _extensions[i] = glGetStringi(GL_EXTENSIONS, i).to!string;
        }
        logInfo("GL_ARB_texture_compression_bptc: ", isExtensionSupported("GL_ARB_texture_compression_bptc"));
        
        // Initial OpenGL state settings
        glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClearDepth(1.0);
        glEnable(GL_SCISSOR_TEST);
        glDepthFunc(GL_LESS);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_POLYGON_OFFSET_FILL);
        glCullFace(GL_BACK);
        glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
        
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        SDL_GL_SwapWindow(window);
        
        enumerateCompressedTextureFormats();
        
        bool anisotropicFilteringSupported = isExtensionSupported("GL_EXT_texture_filter_anisotropic");
        logInfo("GL_EXT_texture_filter_anisotropic: ", anisotropicFilteringSupported);
        
        if (anisotropicFilteringSupported)
        {
            maxTextureAnisotropy = 8.0f;
            float queriedValue = maxTextureAnisotropy;
            glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &queriedValue);
            maxTextureAnisotropy = (queriedValue > maxTextureAnisotropy) ? maxTextureAnisotropy : queriedValue;
            logInfo("GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: ", maxTextureAnisotropy);
        }
        else
        {
            maxTextureAnisotropy = 0.0f;
        }
        
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 0, &maxWorkGroups[0]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 1, &maxWorkGroups[1]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 2, &maxWorkGroups[2]);
        logInfo("GL_MAX_COMPUTE_WORK_GROUP_COUNT: ", maxWorkGroups);
        
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 0, &maxWorkGroups[0]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 1, &maxWorkGroups[1]);
        glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_SIZE, 2, &maxWorkGroups[2]);
        logInfo("GL_MAX_COMPUTE_WORK_GROUP_SIZE: ", maxWorkGroups);
        
        // Debug output
        if (enableDebugOutput)
        {
            if (hasKHRDebug)
            {
                glEnable(GL_DEBUG_OUTPUT);
                glDebugMessageCallback(&messageCallback, cast(void*)this);
            }
            else
                logWarning("GL_KHR_debug is not supported, debug output is not available");
        }
        
        // Create cadencer
        if (stepFrequency == 0)
            stepFrequency = displayRefreshRate(60);
        logInfo("Step frequency: ", stepFrequency, " Hz");
        cadencer = New!Cadencer(this, stepFrequency, this);
        
        // Init FreeType and the font manager
        if (freetypePresent)
        {
            if (FT_Init_FreeType(&ftLibrary))
            {
                logError("FT_Init_FreeType failed");
                freetypePresent = false;
            }
            else
            {
                FT_Library_Version(ftLibrary, &ftVersion.major, &ftVersion.minor, &ftVersion.patch);
                logInfo("FreeType version: ", ftVersion.major, ".", ftVersion.minor, ".", ftVersion.patch);
            }
        }
        
        fontManager = New!FontManager(this);
        
        // Init shader cache
        shaderCache = New!ShaderCache(vfs, this);
        shaderCache.enabled = enableShaderCache;
        logInfo("Shader cache enabled: ", shaderCache.enabled);
        _globalShaderCache = shaderCache;
        
        // Get cursors
        // TODO: support custom cursors
        cursor[Cursor.Default] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        cursor[Cursor.IBeam] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_IBEAM);
        cursor[Cursor.Wait] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAIT);
        cursor[Cursor.Crosshair] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
        cursor[Cursor.WaitArrow] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAITARROW);
        cursor[Cursor.SizeNWSE] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE);
        cursor[Cursor.SizeNESW] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENESW);
        cursor[Cursor.SizeWE] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEWE);
        cursor[Cursor.SizeNS] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENS);
        cursor[Cursor.SizeAll] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
        cursor[Cursor.No] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_NO);
        cursor[Cursor.Hand] = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    }
    
    protected void updateSettings()
    {
        // Logger settings
        if ("log.enabled" in config.props)
            logOutputOptions.enabled = cast(bool)config.props["log.enabled"].toUInt;
        
        if ("log.level" in config.props)
        {
            string logLevelStr = config.props["log.level"].toString;
            if (logLevelStr == "debug")
                this.logLevel = LogLevel.Debug;
            else if (logLevelStr == "info")
                this.logLevel = LogLevel.Info;
            else if (logLevelStr == "warning")
                this.logLevel = LogLevel.Warning;
            else if (logLevelStr == "error")
                this.logLevel = LogLevel.Error;
            dagon.core.logger.logLevel = this.logLevel;
        }
        
        if ("log.toStdout" in config.props)
            logOutputOptions.printToStdout = cast(bool)config.props["log.toStdout"].toUInt;
        
        if ("log.file" in config.props)
            if (config.props["log.file"].type == DPropType.String)
                setLogFilename(config.props["log.file"].toString);
        
        if ("log.timestampTags" in config.props)
            logOutputOptions.printTimestamp = cast(bool)config.props["log.timestampTags"].toUInt;
        
        if ("log.levelTags" in config.props)
            logOutputOptions.printLogLevel = cast(bool)config.props["log.levelTags"].toUInt;
        
        if ("appDataFolder")
            appDataFolderName = config.props["appDataFolder"].toString;
        
        // TODO: VFS settings
        
        // Library settings
        if ("SDL2.path" in config.props)
            sdlLibraryPath = config.props["SDL2.path"].toString;
        if ("SDL2Image.path" in config.props)
            sdlLibraryPath = config.props["SDL2Image.path"].toString;
        if ("FreeType.path" in config.props)
            freetypeLibraryPath = config.props["FreeType.path"].toString;
        version(Windows)
        {
            if ("SDL2.path.windows" in config.props)
                sdlLibraryPath = config.props["SDL2.path.windows"].toString;
            if ("SDL2Image.path.windows" in config.props)
                sdlImageLibraryPath = config.props["SDL2Image.path.windows"].toString;
            if ("FreeType.path.windows" in config.props)
                freetypeLibraryPath = config.props["FreeType.path.windows"].toString;
        }
        else version(linux)
        {
            if ("SDL2.path.linux" in config.props)
                sdlLibraryPath = config.props["SDL2.path.linux"].toString;
            if ("SDL2Image.path.linux" in config.props)
                sdlImageLibraryPath = config.props["SDL2Image.path.linux"].toString;
            if ("FreeType.path.linux" in config.props)
                freetypeLibraryPath = config.props["FreeType.path.linux"].toString;
        }
        
        // Window settings
        if ("window.width" in config.props)
            width = config.props["window.width"].toUInt;
        else if ("windowWidth" in config.props)
        {
            logWarning("\"windowWidth\" is deprecated, use \"window.width\" instead");
            width = config.props["windowWidth"].toUInt;
        }
        
        if ("window.height" in config.props)
            height = config.props["window.height"].toUInt;
        else if ("windowHeight" in config.props)
        {
            logWarning("\"windowHeight\" is deprecated, use \"window.height\" instead");
            height = config.props["windowHeight"].toUInt;
        }
        
        if ("window.x" in config.props)
        {
            if (config.props["window.x"].type == DPropType.Number)
                windowX = config.props["window.x"].toInt;
            else
                windowX = SDL_WINDOWPOS_CENTERED;
        }
        if ("window.y" in config.props)
        {
            if (config.props["window.y"].type == DPropType.Number)
                windowY = config.props["window.y"].toInt;
            else
                windowY = SDL_WINDOWPOS_CENTERED;
        }
        
        if ("fullscreen" in config.props)
            fullscreen = cast(bool)(config.props["fullscreen"].toUInt);
        
        if ("window.resizable" in config.props)
            windowResizable = cast(bool)config.props["window.resizable"].toUInt;
        
        if ("window.title" in config.props)
            windowTitle = config.props["window.title"].toString;
        else if ("windowTitle" in config.props)
        {
            logWarning("\"windowTitle\" is deprecated, use \"window.title\" instead");
            windowTitle = config.props["windowTitle"].toString;
        }
        
        if ("locale" in config.props)
            userLocale = config.props["locale"].toString;
        version(Windows)
        {
            if ("hideConsole" in config.props)
                if (config.props["hideConsole"].toUInt)
                    showConsoleWindow(false);
        }
        
        // Graphics settings
        if ("vsync" in config.props)
            vsync = config.props["vsync"].toInt;
        if ("stepFrequency" in config.props)
        {
            if (config.props["stepFrequency"].type == DPropType.Number)
                stepFrequency = config.props["stepFrequency"].toUInt;
            else if (config.props["stepFrequency"].type == DPropType.String)
            {
                if (config.props["stepFrequency"].toString == "auto")
                    stepFrequency = 0; // same as display refresh rate
            }
        }
        if ("gl.enableShaderCache" in config.props)
            enableShaderCache = cast(bool)(config.props["gl.enableShaderCache"].toUInt);
        if ("gl.debugOutput" in config.props)
            enableDebugOutput = cast(bool)config.props["gl.debugOutput"].toUInt;
        
        // Font settings
        if ("font.sans" in config.props)
            defaultFontSans = config.props["font.sans"].toString;
        if ("font.monospace" in config.props)
            defaultFontMonospace = config.props["font.monospace"].toString;
        if ("font.size" in config.props)
            defaultFontSize = config.props["font.size"].toUInt;
    }

    /// Destructor. Cleans up resources and shuts down SDL.
    ~this()
    {
        releaseCompressedTextureFormats();

        SDL_GL_DeleteContext(glcontext);
        
        foreach(i, cur; cursor)
        {
            if (cur)
            {
                SDL_FreeCursor(cur);
                cursor[i] = null;
            }
        }
        
        SDL_DestroyWindow(window);
        SDL_Quit();
        Delete(_extensions);
        
        if (freetypePresent && ftLibrary)
            FT_Done_FreeType(ftLibrary);
        
        freeLogBuffer();
        
        if (vfs)
            Delete(vfs);
    }
    
    /**
     * Sets the window size.
     *
     * Params:
     *   w = New window width.
     *   h = New window height.
     */
    void setWindowSize(uint w, uint h)
    {
        SDL_SetWindowSize(window, w, h);
    }
    
    /// Centers the window on the screen.
    void centerWindow()
    {
        SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);
    }
    
    /// Maximizes the window.
    void maximizeWindow()
    {
        SDL_MaximizeWindow(window);
    }
    
    /// Set mouse cursor
    void setCursor(Cursor cur)
    {
        if (cur < cursor.length)
        {
            if (cursor[cur])
                SDL_SetCursor(cursor[cur]);
        }
    }
    
    /**
     * Switches fullscreen mode.
     *
     * Params:
     *   mode = If true, enables fullscreen; otherwise disables it.
     */
    void setFullscreen(bool mode)
    {
        if (mode)
            SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN);
        else
            SDL_SetWindowFullscreen(window, 0);
    }

    override void onUserEvent(int code)
    {
        if (code == DagonEvent.Exit)
        {
            exit();
        }
    }
    
    override void onResize(int width, int height)
    {
        this.width = width;
        this.height = height;
    }

    /**
     * Called every frame to update application logic.
     *
     * Params:
     *   t = Time information for the frame.
     */
    void onUpdate(Time t)
    {
        // Override me
    }

    /// Called every frame to render the scene.
    void onRender()
    {
        // Override me
    }

    /**
     * Called on each animation frame (cadencer tick).
     *
     * Params:
     *   t = Time information for the frame.
     */
    void update(Time t)
    {
        eventManager.update();
        processEvents();
        onUpdate(t);
        onRender();
        debug checkGLError();
        SDL_GL_SwapWindow(window);
    }

    /// Checks for OpenGL errors and logs them.
    void checkGLError()
    {
        GLenum error = GL_NO_ERROR;
        error = glGetError();
        if (error != GL_NO_ERROR)
        {
            logDebug("OpenGL error %s: %s", error, GLErrorStrings[error]);
        }
    }

    /**
     * Runs the main loop.
     * This will block the thread until the application terminates.
     */
    void run()
    {
        Time t = Time(0.0, 0.0);
        while(eventManager.running)
        {
            eventManager.updateTimer();
            t.delta = eventManager.deltaTime;
            cadencer.update(t);
            t.elapsed += t.delta;
        }
    }

    /// Terminates the application.
    void exit()
    {
        eventManager.exit();
    }
    
    protected uint screenNum = 0;
    
    /**
     * Takes a screenshot of the current framebuffer and returns it as a SuperImage.
     *
     * Returns:
     *   The screenshot image.
     */
    SuperImage takeScreenshot()
    {
        ubyte[] data = New!(ubyte[])(width * height * 3);
        glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, data.ptr);
        SuperImage img = unmanagedImage(width, height, 3, 8);
        auto outputData = img.data;
        for (uint y = 0; y < height; y++)
        {
            memcpy(&outputData[(height - 1 - y) * width * 3], &data[y * width * 3], width * 3);
        }
        return img;
    }
    
    /**
     * Takes a screenshot and saves it to the specified path (auto-incrementing filename).
     *
     * Params:
     *   path = Base path for the screenshot file.
     */
    void takeScreenshot(string path)
    {
        // TODO: use vfs to save the file
        auto img = takeScreenshot();
        
        bool saved = false;
        while (!saved)
        {
            string filePath = path ~ screenNum.to!string ~ ".png";
            if (!fileExists(filePath))
            {
                img.savePNG(filePath);
                saved = true;
            }
            else screenNum++;
        }
        
        Delete(img);
    }
    
    /**
     * Returns the display's refresh rate, or `fallbackRefreshRate` if query fails.
     *
     * Params:
     *   fallbackRefreshRate = Fallback value in case of a query error.
     *
     * Returns:
     *   The refresh rate in Hz.
     */
    int displayRefreshRate(int fallbackRefreshRate = 60)
    {
        SDL_DisplayMode mode;
        int displayIndex = SDL_GetWindowDisplayIndex(window);
        if (SDL_GetDesktopDisplayMode(displayIndex, &mode) != 0)
            return fallbackRefreshRate;
        if (mode.refresh_rate == 0)
            return fallbackRefreshRate;
        return mode.refresh_rate;
    }
    
    /**
     * Sets the cadencer frequency to the display's refresh rate.
     *
     * Params:
     *   fallbackRefreshRate = Fallback value in case of a query error.
     *
     * Returns:
     *   The refresh rate in Hz.
     */
    int frequencyToRefreshRate(int fallbackRefreshRate = 60)
    {
        int refreshRate = displayRefreshRate(fallbackRefreshRate);
        cadencer.setFrequency(refreshRate);
        return refreshRate;
    }
    
    /// Mounts the specified ReadOnlyFileSystem to the virtual file system.
    void mount(ReadOnlyFileSystem fs)
    {
        vfs.mount(fs);
        logInfo("VFS: mounted a filesystem");
    }
    
    /// Mounts the specified directory to the virtual file system.
    void mount(string dirName)
    {
        // TODO: create folder if needed
        vfs.mount(dirName);
        if (dirName == ".")
            logInfo("VFS: mounted working directory");
        else
            logInfo("VFS: mounted ", dirName);
    }
    
    /// Opens file stream for reading from the virtual file system.
    InputStream openFile(string filename)
    {
        FileStat stat;
        if (vfs.stat(filename, stat))
            return vfs.openForInput(filename);
        else
        {
            logError(filename, " is not found");
            return null;
        }
    }
    
    /**
     * Checks if a file exists in the VFS.
     *
     * Params:
     *   filename = Path to the file.
     * Returns:
     *   `true` if the file exists, `false` otherwise.
     */
    bool fileExists(string filename)
    {
        return vfs.exists(filename);
    }
    
    /**
     * Returns file status.
     *
     * Params:
     *   filename = Path to the file.
     * Returns:
     *   FileStat struct for the file.
     */
    FileStat fileStatus(string filename)
    {
        FileStat stat;
        vfs.stat(filename, stat);
        return stat;
    }
    
    /**
     * Switches console window visibility under Windows.
     * Under other OSes does nothing.
     *
     * Params:
     *   mode = show or hide the console window.
     */
    void showConsoleWindow(bool mode)
    {
        version(Windows)
        {
            if (mode)
                ShowWindow(GetConsoleWindow(), SW_SHOW);
            else
                ShowWindow(GetConsoleWindow(), SW_HIDE);
        }
    }
    
    version(Windows)
    {
        /**
         * Windows-only: returns HWND of the application window.
         */
        HWND hwnd()
        {
            return eventManager.wmInfo.info.win.window;
        }
    }
}
