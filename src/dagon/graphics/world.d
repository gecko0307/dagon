/*
Copyright (c) 2023-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides the `World` class and related entity group classes for managing
 * collections of entities in a scene.
 *
 * Description:
 * The `World` class stores entities, manages their root transformation,
 * and provides various entity groups for efficient queries based on entity type
 * (such as spatial, opaque, transparent, background, foreground, lights,
 * decals, and probes). The `MultiWorld` class allows hierarchical composition
 * of multiple worlds. Entity group classes implement filtering and iteration
 * for specific entity types or properties.
 *
 * Copyright: Timur Gafarov 2023-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.world;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.container.array;
import dlib.math.matrix;

import dagon.graphics.entity;
import dagon.graphics.light;

/**
 * Stores entities and provides entity groups for organization and queries.
 */
class World: Owner
{
    /// If false, the world and its entities are hidden.
    bool visible = true;
    
    /// Root transformation matrix for all entities.
    Matrix4x4f rootTransformation;

    /// Inverse of the root transformation.
    Matrix4x4f rootInvTransformation;

    /// Previous frame's root transformation.
    Matrix4x4f prevRootTransformation;
    
    /// Array of all entities in the world.
    protected Array!Entity entities;
    
    /// Group of all spatial entities.
    EntityGroupSpatial spatial;

    /// Group of static opaque spatial entities.
    EntityGroupSpatialOpaque spatialOpaqueStatic;

    /// Group of dynamic opaque spatial entities.
    EntityGroupSpatialOpaque spatialOpaqueDynamic;

    /// Group of transparent spatial entities.
    EntityGroupSpatialTransparent spatialTransparent;

    /// Group of background entities.
    EntityGroupBackground background;

    /// Group of foreground entities.
    EntityGroupForeground foreground;

    /// Group of all light entities.
    EntityGroupLights lights;

    /// Group of sun (directional) lights.
    EntityGroupSunLights sunLights;

    /// Group of area and spot lights.
    EntityGroupAreaLights areaLights;

    /// Group of decal entities.
    EntityGroupDecals decals;

    /// Group of probe entities.
    EntityGroupProbes probes;

     /// Constructs a new world and initializes entity groups.
    this(Owner owner)
    {
        super(owner);
        resetTransformation();
        createEntityGroups();
    }
    
    /// Destructor. Frees an entities array.
    ~this()
    {
        entities.free();
    }
    
    /// Resets the root transformation matrices.
    void resetTransformation()
    {
        rootTransformation = Matrix4x4f.identity;
        rootInvTransformation = Matrix4x4f.identity;
        prevRootTransformation = Matrix4x4f.identity;
    }
    
     /// Creates and initializes all entity groups.
    void createEntityGroups()
    {
        if (spatial is null)
            spatial = New!EntityGroupSpatial(this, this);
        
        if (spatialOpaqueStatic is null)
            spatialOpaqueStatic = New!EntityGroupSpatialOpaque(this, false, this);
        
        if (spatialOpaqueDynamic is null)
            spatialOpaqueDynamic = New!EntityGroupSpatialOpaque(this, true, this);
        
        if (spatialTransparent is null)
            spatialTransparent = New!EntityGroupSpatialTransparent(this, this);
        
        if (background is null)
            background = New!EntityGroupBackground(this, this);
        
        if (foreground is null)
            foreground = New!EntityGroupForeground(this, this);
        
        if (lights is null)
            lights = New!EntityGroupLights(this, this);
        
        if (sunLights is null)
            sunLights = New!EntityGroupSunLights(this, this);
        
        if (areaLights is null)
            areaLights = New!EntityGroupAreaLights(this, this);
        
        if (decals is null)
            decals = New!EntityGroupDecals(this, this);
        
        if (probes is null)
            probes = New!EntityGroupProbes(this, this);
    }

    /// Adds an existing entity to the world.
    void add(Entity e)
    {
        entities.append(e);
    }
    
    /// Creates and adds a new entity, optionally with a parent.
    Entity addEntity(Entity parent = null)
    {
        Entity e = New!Entity(this);
        if (parent)
            e.setParent(parent);
        return e;
    }
    
    /// Iterates over all entities (by index and reference).
    int opApply(scope int delegate(size_t, ref Entity) dg)
    {
        if (visible)
            return entities.opApply(dg);
        else return 0;
    }
    
    /// Iterates over all entities (by reference only).
    int opApply(scope int delegate(ref Entity) dg)
    {
        if (visible)
            return entities.opApply(dg);
        else return 0;
    }
    
    /// Iterates in reverse order (by index and reference).
    int opApplyReverse(scope int delegate(size_t, ref Entity) dg)
    {
        if (visible)
            return entities.opApplyReverse(dg);
        else return 0;
    }
    
    /// Iterates in reverse order (by reference only).
    int opApplyReverse(scope int delegate(ref Entity) dg)
    {
        if (visible)
            return entities.opApplyReverse(dg);
        else return 0;
    }
    
    /// Returns the number of entities in the world.
    size_t length()
    {
        return entities.length;
    }
    
    void putEntityOnTop(Entity entity)
    {
        size_t entityIndex;
        bool found = false;
        foreach(i, e; entities)
        {
            if (e is entity)
            {
                entityIndex = i;
                found = true;
                break;
            }
        }
        
        if (found)
        {
            entities.removeKey(entityIndex);
            entities.append(entity);
        }
    }
}

/**
 * A world that can contain multiple sub-worlds.
 * Allows hierarchical composition of worlds for complex scenes.
 */
class MultiWorld: World
{
    /// An array of sub-worlds.
    Array!World subWorlds;
    
    /// Constructs a multi-world.
    this(Owner owner)
    {
        super(owner);
    }
    
     /// Frees an array of sub-worlds.
    ~this()
    {
        subWorlds.free();
    }
    
    /// Adds a new sub-world.
    World addSubWorld(bool visible = true)
    {
        auto w = New!World(this);
        w.visible = visible;
        subWorlds.append(w);
        return w;
    }
    
    /// Iterates over all entities in all sub-worlds (by index and reference).
    override int opApply(scope int delegate(size_t, ref Entity) dg)
    {
        if (visible)
        {
            int res = entities.opApply(dg);
            if (res) return res;
            foreach(World w; subWorlds.data)
            {
                res = w.opApply(dg);
                if (res)
                    break;
            }
            return res;
        }
        else return 0;
    }
    
    /// Iterates over all entities in all sub-worlds (by reference only).
    override int opApply(scope int delegate(ref Entity) dg)
    {
        if (visible)
        {
            int res = entities.opApply(dg);
            if (res) return res;
            foreach(World w; subWorlds.data)
            {
                res = w.opApply(dg);
                if (res)
                    break;
            }
            return res;
        }
        else return 0;
    }
    
    /// Iterates in reverse order (by index and reference).
    override int opApplyReverse(scope int delegate(size_t, ref Entity) dg)
    {
        if (visible)
        {
            int res = entities.opApplyReverse(dg);
            if (res) return res;
            foreach(World w; subWorlds.data)
            {
                res = w.opApplyReverse(dg);
                if (res)
                    break;
            }
            return res;
        }
        else return 0;
    }
    
    /// Iterates in reverse order (by reference only).
    override int opApplyReverse(scope int delegate(ref Entity) dg)
    {
        if (visible)
        {
            int res = entities.opApplyReverse(dg);
            if (res) return res;
            foreach(World w; subWorlds.data)
            {
                res = w.opApplyReverse(dg);
                if (res)
                    break;
            }
            return res;
        }
        else return 0;
    }
    
    /// Returns the total number of entities in all sub-worlds.
    override size_t length()
    {
        size_t res = entities.length;
        foreach(World w; subWorlds.data)
        {
            res += w.length();
        }
        return res;
    }
}

/**
 * Entity group for spatial entities (excluding decals and probes).
 */
class EntityGroupSpatial: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all spatial entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.layer == EntityLayer.Spatial && !e.decal && !e.probe)
            {
                res = dg(e);
                if (res)
                    break;
            }
        }
        return res;
    }
}

/**
 * Entity group for decal entities.
 */
class EntityGroupDecals: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all decal entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.decal)
            {
                res = dg(e);
                if (res)
                    break;
            }
        }
        return res;
    }
}

/**
 * Entity group for probe entities.
 */
class EntityGroupProbes: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all probe entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.probe)
            {
                res = dg(e);
                if (res)
                    break;
            }
        }
        return res;
    }
}

/**
 * Entity group for opaque spatial entities (static or dynamic).
 */
class EntityGroupSpatialOpaque: Owner, EntityGroup
{
    World world;
    bool dynamic = true;

    this(World world, bool dynamic, Owner owner)
    {
        super(owner);
        this.world = world;
        this.dynamic = dynamic;
    }

    /// Iterates over all opaque spatial entities matching the dynamic/static flag.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.layer == EntityLayer.Spatial && !e.decal && !e.probe)
            {
                bool transparent = false;
                
                if (e.material)
                    transparent = e.material.isTransparent;
                
                transparent = transparent || e.transparent || e.opacity < 1.0f;
                
                if (!transparent && e.dynamic == dynamic)
                {
                    res = dg(e);
                    if (res)
                        break;
                }
            }
        }
        return res;
    }
}

/**
 * Entity group for transparent spatial entities.
 */
class EntityGroupSpatialTransparent: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

     /// Iterates over all transparent spatial entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.layer == EntityLayer.Spatial && !e.decal && !e.probe)
            {
                bool transparent = false;
                
                if (e.material)
                    transparent = e.material.isTransparent;
                
                transparent = transparent || e.transparent || e.opacity < 1.0f;
                
                if (transparent)
                {
                    res = dg(e);
                    if (res)
                        break;
                }
            }
        }
        return res;
    }
}

/**
 * Entity group for background entities.
 */
class EntityGroupBackground: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all background entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.layer == EntityLayer.Background)
            {
                res = dg(e);
                if (res)
                    break;
            }
        }
        return res;
    }
}

/**
 * Entity group for foreground entities.
 */
class EntityGroupForeground: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all foreground entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            if (e.layer == EntityLayer.Foreground)
            {
                res = dg(e);
                if (res)
                    break;
            }
        }
        return res;
    }
}

/**
 * Entity group for all light entities.
 */
class EntityGroupLights: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all light entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            Light light = cast(Light)e;
            if (light)
            {
                res = dg(e);
                if (res)
                    break;
            }
        }
        return res;
    }
}

/**
 * Entity group for sun (directional) lights.
 */
class EntityGroupSunLights: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all sun light entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            Light light = cast(Light)e;
            if (light)
            {
                if (light.type == LightType.Sun)
                {
                    res = dg(e);
                    if (res)
                        break;
                }
            }
        }
        return res;
    }
}

/**
 * Entity group for area and spot lights.
 */
class EntityGroupAreaLights: Owner, EntityGroup
{
    World world;

    this(World world, Owner owner)
    {
        super(owner);
        this.world = world;
    }

    /// Iterates over all area and spot light entities.
    int opApply(scope int delegate(Entity) dg)
    {
        int res = 0;
        foreach(size_t i, Entity e; world)
        {
            Light light = cast(Light)e;
            if (light)
            {
                if (light.type == LightType.AreaSphere ||
                    light.type == LightType.AreaTube ||
                    light.type == LightType.Spot)
                {
                    res = dg(e);
                    if (res)
                        break;
                }
            }
        }
        return res;
    }
}
