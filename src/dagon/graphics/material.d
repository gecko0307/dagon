/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Defines the material system.
 *
 * Description:
 * The `dagon.graphics.material` module provides the `Material` class,
 * which encapsulates all parameters and resources needed for
 * physically-based rendering (PBR), including textures, colors, blending modes,
 * parallax mapping, shadow filtering, and shader/material flags. Materials control
 * how surfaces are shaded, blended, and rendered, and can be customized for a wide
 * range of visual effects.
 *
 * Copyright: Timur Gafarov 2017-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.material;

import std.traits;
import std.math;
import std.algorithm;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.image.color;
import dlib.image.image;
import dlib.image.unmanaged;
import dlib.container.dict;

import dagon.core.bindings;
import dagon.graphics.texture;
import dagon.graphics.state;
import dagon.graphics.shader;
import dagon.graphics.light;

/// Common color constants for convenience.
enum
{
    CBlack = Color4f(0.0f, 0.0f, 0.0f, 1.0f),
    CWhite = Color4f(1.0f, 1.0f, 1.0f, 1.0f),
    CRed = Color4f(1.0f, 0.0f, 0.0f, 1.0f),
    COrange = Color4f(1.0f, 0.5f, 0.0f, 1.0f),
    CYellow = Color4f(1.0f, 1.0f, 0.0f, 1.0f),
    CGreen = Color4f(0.0f, 1.0f, 0.0f, 1.0f),
    CCyan = Color4f(0.0f, 1.0f, 1.0f, 1.0f),
    CBlue = Color4f(0.0f, 0.0f, 1.0f, 1.0f),
    CPurple = Color4f(0.5f, 0.0f, 1.0f, 1.0f),
    CMagenta = Color4f(1.0f, 0.0f, 1.0f, 1.0f)
}

enum int None = 0;

/// Shadow filter mode constants.
enum int ShadowFilterNone = 0;
enum int ShadowFilterPCF = 1;

/// Parallax mapping mode constants.
enum int ParallaxNone = 0;
enum int ParallaxSimple = 1;
enum int ParallaxOcclusionMapping = 2;

/// Blend mode constants.
enum int Opaque = 0;
enum int Transparent = 1;
enum int Additive = 2;

/// Texture mapping mode constants.
enum int VertexUV = 0;
enum int Matcap = 1;

/**
 * Represents a physically-based material for rendering surfaces.
 *
 * Description:
 * The `Material` class encapsulates all parameters and resources needed for
 * PBR, including textures, colors, blending, parallax, shadow filtering, and
 * shader/material flags. Materials are used to control how surfaces are shaded,
 * blended, and rendered in the engine.
 */
class Material: Owner
{
    /// The material name (for identification).
    string name;

    /// Optional shader used for rendering this material.
    Shader shader;

    /// Optional main directional light (sun) affecting this material.
    Light sun;

    /// Base color (albedo) texture.
    Texture baseColorTexture;

    /// Roughness/metallic texture.
    Texture roughnessMetallicTexture;

    /// Emission texture.
    Texture emissionTexture;

    /// Tangent-space normal map texture.
    Texture normalTexture;

    /// Height map texture (for parallax mapping).
    Texture heightTexture;

    /// Alpha mask texture (for terrain texturing layer material).
    Texture maskTexture;

    /// Base color factor (albedo color). Used if `baseColorTexture` is not specified
    Color4f baseColorFactor = Color4f(1.0f, 1.0f, 1.0f, 1.0f);
    
    /// Does the baseColor in linear RGB space (true), or in sRGB (false)
    bool linearColor = false;

    /// Emission color factor. Used if `emissionTexture` is not specified
    Color4f emissionFactor = Color4f(0.0f, 0.0f, 0.0f, 1.0f);

    /// Tangent-space normal vector. Used if `normalTexture` is not specified
    Vector3f normalFactor = Vector3f(0.0f, 0.0f, 1.0f);

    /// Texture transformation matrix.
    Matrix3x3f textureTransformation;

    /// Height factor. Used if `heightTexture` is not specified
    float heightFactor = 0.0f;

    /// Emission energy multiplier.
    float emissionEnergy = 1.0f;

    /// Opacity (alpha value, 0.0 = fully transparent, 1.0 = fully opaque).
    float opacity = 1.0f;

    /// Alpha test threshold (for masked transparency).
    float alphaTestThreshold = 0.5f;

    /// Surface roughness factor (0 = smooth, 1 = rough). Used if `roughnessMetallicTexture` is not specified
    float roughnessFactor = 0.5f;

    /// Surface metallic factor (0 = dielectric, 1 = metal). Used if `roughnessMetallicTexture` is not specified
    float metallicFactor = 0.0f;

    /// Specularity factor.
    float specularity = 1.0f;

    /// Subsurface scattering factor.
    float subsurfaceScattering = 0.0f;

    /// Parallax mapping scale.
    float parallaxScale = 0.03f;

    /// Parallax mapping bias.
    float parallaxBias = -0.01f;

    /// Alpha mask factor (for terrain texturing layer material). Used if `maskTexture` is not specified
    float maskFactor = 1.0f;

    /// Parallax mapping mode.
    int parallaxMode = ParallaxNone;

    /// Shadow filtering mode.
    int shadowFilter = ShadowFilterPCF;

    /// Blending mode (opaque, transparent, additive).
    int blendMode = Opaque;

    /// Texture mapping mode.
    int textureMappingMode = VertexUV;

    /// If `true`, disables all shading (renderer-specific option).
    bool shadeless = false;

    /// If `true`, invert the Y channel of the normal map.
    bool invertNormalY = true;

    /// If `true`, the surface receives shadows.
    bool useShadows = true;

    /// If `true`, the surface is fogged according to `Environment` object settings
    bool useFog = true;

    /// If `true`, enable backface culling.
    bool useCulling = true;

    /// If `true`, use spherical normal mapping.
    bool sphericalNormal = false;
    
    /// Enables cel shading (pipeline-specific)
    bool celShading = false;
    
    /// Enables rim light (pipeline-specific)
    bool rimLight = false;

    /// If `false`, disables writing to the color buffer.
    bool colorWrite = true;

    /// If `false`, disables writing to the depth buffer.
    bool depthWrite = true;

    /// If `false`, disables G-buffer color output.
    bool outputColor = true;

    /// If `false`, disables G-buffer normal output.
    bool outputNormal = true;

    /// If `false`, disables G-buffer PBR output.
    bool outputPBR = true;

    /// If `false`, disables G-buffer emission output.
    bool outputEmission = true;
    
    /// Internal texture offset (for UV translation).
    protected Vector2f textureOffsetInternal = Vector2f(0.0f, 0.0f);

    /// Internal texture scaling (for UV scaling).
    protected Vector2f textureScalingInternal = Vector2f(1.0f, 1.0f);
    
    /**
     * Constructs a new material with default parameters.
     *
     * Params:
     *   owner = The owner object.
     */
    this(Owner owner)
    {
        super(owner);
        textureTransformation = Matrix3x3f.identity;
    }
    
    /// Destructor. Releases all resources.
    ~this()
    {
    }
    
    /**
     * Returns true if the material is transparent (blend mode is not opaque).
     */
    bool isTransparent() const
    {
        return (blendMode != Opaque);
    }
    
    /**
     * Gets the current texture offset (UV translation).
     */
    Vector2f textureOffset() const
    {
        return textureOffsetInternal;
    }
    
    /**
     * Sets the texture offset (UV translation).
     *
     * Params:
     *   v = The new texture offset.
     */
    void textureOffset(Vector2f v)
    {
        textureOffsetInternal = v;
        textureTransformation.a13 = v.x;
        textureTransformation.a23 = v.y;
    }
    
    /**
     * Gets the current texture scaling (UV scaling).
     */
    Vector2f textureScale() const
    {
        return textureScalingInternal;
    }
    
    /**
     * Sets the texture scaling (UV scaling).
     *
     * Params:
     *   s = The new texture scaling.
     */
    void textureScale(Vector2f s)
    {
        textureScalingInternal = s;
        textureTransformation.a11 = s.x;
        textureTransformation.a22 = s.y;
    }
    
    /**
     * Sets the sprite UV size and position for texture atlases.
     *
     * Params:
     *   uvSize     = The size of the sprite in UV space.
     *   uvPosition = The position of the sprite in UV space.
     */
    void setSprite(Vector2f uvSize, Vector2f uvPosition)
    {
        textureScale = uvSize;
        textureOffset = uvPosition;
    }
    
    /**
     * Binds the material and sets all relevant graphics state for rendering.
     *
     * Params:
     *   state = Pointer to the current graphics pipeline state.
     */
    void bind(GraphicsState* state)
    {
        if (blendMode == Transparent)
        {
            glEnablei(GL_BLEND, 0);
            glEnablei(GL_BLEND, 1);
            glEnablei(GL_BLEND, 2);
            glEnablei(GL_BLEND, 3);
            glEnablei(GL_BLEND, 4);
            glBlendFuncSeparatei(0, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
            glBlendFuncSeparatei(1, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
            glBlendFuncSeparatei(2, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
            glBlendFuncSeparatei(3, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
            glBlendFuncSeparatei(4, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        else if (blendMode == Additive)
        {
            glEnablei(GL_BLEND, 0);
            glEnablei(GL_BLEND, 1);
            glEnablei(GL_BLEND, 2);
            glEnablei(GL_BLEND, 3);
            glEnablei(GL_BLEND, 4);
            glBlendFunci(0, GL_SRC_ALPHA, GL_ONE);
            glBlendFunci(1, GL_SRC_ALPHA, GL_ONE);
            glBlendFunci(2, GL_SRC_ALPHA, GL_ONE);
            glBlendFunci(3, GL_SRC_ALPHA, GL_ONE);
            glBlendFunci(4, GL_SRC_ALPHA, GL_ONE);
        }

        if (useCulling && state.culling)
        {
            glEnable(GL_CULL_FACE);
        }
        else
        {
            glDisable(GL_CULL_FACE);
        }

        if (!colorWrite || !state.colorMask)
        {
            glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
        }

        if (!depthWrite || !state.depthMask)
        {
            glDepthMask(GL_FALSE);
        }

        state.material = this;
    }

    /**
     * Unbinds the material and restores graphics state.
     *
     * Params:
     *   state = Pointer to the current graphics pipeline state.
     */
    void unbind(GraphicsState* state)
    {
        state.material = null;

        glDepthMask(GL_TRUE);
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);

        glDisable(GL_CULL_FACE);

        glDisablei(GL_BLEND, 0);
        glDisablei(GL_BLEND, 1);
        glDisablei(GL_BLEND, 2);
        glDisablei(GL_BLEND, 3);
        glDisablei(GL_BLEND, 4);
    }
}
