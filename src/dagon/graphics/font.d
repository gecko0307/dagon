/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * FreeType font.
 *
 * Description:
 * The `dagon.graphics.font` module defines the `Font` class, which represents
 * a font resource capable of rendering glyphs and text strings.
 *
 * Copyright: Timur Gafarov 2017-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.font;

import std.stdio;
import std.math;
import std.string;
import std.ascii;
import std.utf;
import std.file;
import std.conv;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.core.stream;
import dlib.filesystem.filesystem;
import dlib.filesystem.stdfs;
import dlib.container.dict;
import dlib.text.utf8;
import dlib.math.vector;
import dlib.math.utils;
import dlib.image.color;
import dlib.text.str;

import dagon.core.bindings;
import dagon.core.logger;
import dagon.core.application;
import dagon.core.shaderloader;
import dagon.graphics.state;
import dagon.graphics.shader;

/// Represents a single glyph of the FreeType font for rendering and typographics.
struct Glyph
{
    bool valid;
    GLuint textureId = 0;
    FT_Glyph ftGlyph = null;
    int width = 0;
    int height = 0;
    FT_Pos advanceX = 0;
}

/// Returns nearest higher power of 2 for an arbitrary integer.
int nextPowerOfTwo(int a)
{
    int rval = 1;
    while(rval < a)
        rval <<= 1;
    return rval;
}

/// Object that loads and registers fonts.
class FontManager: Owner
{
    /// Application that the manager is bound to.
    Application application;
    
    /// Dictionary of the registered fonts.
    Dict!(Font, string) fonts;
    
    /// Default sans font.
    Font sans;
    
    /// Default monospace font.
    Font monospace;
    
    /// Constructor.
    this(Application application)
    {
        super(application);
        this.application = application;
        
        fonts = New!(Dict!(Font, string));
        
        if (application.freetypePresent)
        {
            uint fontSize = application.defaultFontSize;
            sans = addFont("sans", application.defaultFontSans, fontSize);
            monospace = addFont("sans", application.defaultFontMonospace, fontSize);
        }
        else
        {
            logError("Failed to load default fonts");
        }
    }
    
    ~this()
    {
        Delete(fonts);
    }
    
    /// Registers a font under a given name.
    Font addFont(string name, Font font)
    {
        fonts[name] = font;
        return font;
    }
    
    /// Loads and registers a font under a given name.
    Font addFont(string name, string filename, uint height)
    {
        if (application.freetypePresent)
        {
            Font font = New!Font(height, application.pixelRatio, this);
            font.ftLibrary = application.ftLibrary;
            font.createFromFile(filename);
            font.prepareVAO();
            font.preloadASCII();
            fonts[name] = font;
            return font;
        }
        else
        {
            logError("Failed to add font \"", name, "\": problem with FreeType?");
            return null;
        }
    }
}

/**
 * Basic typography class.
 *
 * Description:
 * Stores a dictionary of glyphs loaded from the font file and the boilerplate necessary for
 * text rendering. Provides methods for rendering single glyphs and UTF-8 strings
 * and measuring string width.
 */
final class Font: Owner
{
    public:
    
    /// FreeType library instance.
    FT_Library ftLibrary;
    
    /// FreeType face object.
    FT_Face ftFace;
    
    /// Dictionary of loaded glyphs.
    Dict!(Glyph, dchar) glyphs;
    
    /// Font size in pixels.
    float height;
    
    /// Pixel ratio for High DPI text rendering
    float pixelRatio;

    protected:

    /// Vertex buffer for rendering a glyph quad.
    Vector2f[4] vertices;
    
    /// Texture coordinate buffer for rendering a glyph quad.
    Vector2f[4] texcoords;
    
    /// Vertex indices forming a glyph quad.
    uint[3][2] indices;

    /// OpenGL vertex array object for the glyph quad.
    GLuint vao = 0;
    
    /// OpenGL vertex buffer object for the glyph quad.
    GLuint vbo = 0;
    
    /// OpenGL texture coordinate buffer object for the glyph quad.
    GLuint tbo = 0;
    
    /// OpenGL element array buffer object for the glyph quad.
    GLuint eao = 0;

    /// OpenGL shader program for rendering the glyph quad.
    GLuint shaderProgram;

    GLint modelViewMatrixLoc;
    GLint projectionMatrixLoc;

    GLint resolutionLoc;
    GLint glyphPositionLoc;
    GLint glyphScaleLoc;
    GLint glyphTexcoordScaleLoc;

    GLint glyphTextureLoc;
    GLint glyphColorLoc;

    String vs, fs;
    
    protected ubyte[] buffer;
    
    public:

    /// True if the text can be rendered.
    bool valid;

    /**
     * Constructor.
     *
     * Params:
     *   height = em height (font size) in pixels
     *   owner = Owner object.
     */
    this(uint height, float pixelRatio, Owner owner)
    {
        super(owner);
        this.height = ceil(height * pixelRatio);
        this.pixelRatio = pixelRatio;

        vertices[0] = Vector2f(0, 1);
        vertices[1] = Vector2f(0, 0);
        vertices[2] = Vector2f(1, 0);
        vertices[3] = Vector2f(1, 1);

        texcoords[0] = Vector2f(0, 1);
        texcoords[1] = Vector2f(0, 0);
        texcoords[2] = Vector2f(1, 0);
        texcoords[3] = Vector2f(1, 1);

        indices[0][0] = 0;
        indices[0][1] = 1;
        indices[0][2] = 2;

        indices[1][0] = 0;
        indices[1][1] = 2;
        indices[1][2] = 3;
        
        valid = false;
        
        glyphs = New!(Dict!(Glyph, dchar));
    }

    /// Creates a font object from file.
    void createFromFile(string filename)
    {
        if (ftLibrary is null)
            return;
        
        auto fs = globalVFS();
        
        FileStat s;
        if (!fs.stat(filename, s))
            exitWithError("Cannot find font file " ~ filename);
        
        auto istrm = fs.openForInput(filename);
        buffer = New!(ubyte[])(cast(size_t)s.sizeInBytes);
        istrm.fillArray(buffer);
        Delete(istrm);
        
        if (FT_New_Memory_Face(ftLibrary, buffer.ptr, cast(uint)buffer.length, 0, &ftFace))
            exitWithError("FT_New_Face failed (there is probably a problem with your font file)");

        int h = cast(int)height;
        FT_Set_Char_Size(ftFace, h << 6, h << 6, 96, 96);
    }

    /// Creates a font object from memory buffer.
    void createFromMemory(ubyte[] buffer)
    {
        if (ftLibrary is null)
            return;
        
        if (FT_New_Memory_Face(ftLibrary, buffer.ptr, cast(uint)buffer.length, 0, &ftFace))
            exitWithError("FT_New_Face failed (there is probably a problem with your font file)");

        FT_Set_Char_Size(ftFace, cast(int)height << 6, cast(int)height << 6, 96, 96);
    }

    /// Initializes OpenGL buffers for rendering.
    void prepareVAO()
    {
        if (valid)
            return;

        glGenBuffers(1, &vbo);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBufferData(GL_ARRAY_BUFFER, vertices.length * float.sizeof * 2, vertices.ptr, GL_STATIC_DRAW);

        glGenBuffers(1, &tbo);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glBufferData(GL_ARRAY_BUFFER, texcoords.length * float.sizeof * 2, texcoords.ptr, GL_STATIC_DRAW);

        glGenBuffers(1, &eao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.length * uint.sizeof * 3, indices.ptr, GL_STATIC_DRAW);

        glGenVertexArrays(1, &vao);
        glBindVertexArray(vao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);

        glEnableVertexAttribArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, null);

        glEnableVertexAttribArray(1);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, null);

        glBindVertexArray(0);

        vs = Shader.load("data/__internal/shaders/Glyph/Glyph.vert.glsl");
        fs = Shader.load("data/__internal/shaders/Glyph/Glyph.frag.glsl");

        GLuint vert = compileShader(vs, ShaderStage.vertex);
        GLuint frag = compileShader(fs, ShaderStage.fragment);
        if (vert != 0 && frag != 0)
            shaderProgram = linkShaders(vert, frag);

        if (shaderProgram != 0)
        {
            modelViewMatrixLoc = glGetUniformLocation(shaderProgram, "modelViewMatrix");
            projectionMatrixLoc = glGetUniformLocation(shaderProgram, "projectionMatrix");

            resolutionLoc = glGetUniformLocation(shaderProgram, "resolution");
            glyphPositionLoc = glGetUniformLocation(shaderProgram, "glyphPosition");
            glyphScaleLoc = glGetUniformLocation(shaderProgram, "glyphScale");
            glyphTexcoordScaleLoc = glGetUniformLocation(shaderProgram, "glyphTexcoordScale");
            glyphTextureLoc = glGetUniformLocation(shaderProgram, "glyphTexture");
            glyphColorLoc = glGetUniformLocation(shaderProgram, "glyphColor");
        }

        valid = true;
    }

    /// Loads first 128 characters to the VRAM.
    void preloadASCII()
    {
        if (ftLibrary is null)
            return;
        
        enum ASCII_CHARS = 128;
        foreach(i; 0..ASCII_CHARS)
        {
            GLuint tex;
            glGenTextures(1, &tex);
            loadGlyph(i, tex);
        }
    }

    ~this()
    {
        vs.free();
        fs.free();

        if (valid)
        {
            glDeleteVertexArrays(1, &vao);
            glDeleteBuffers(1, &vbo);
            glDeleteBuffers(1, &tbo);
            glDeleteBuffers(1, &eao);
        }

        foreach(i, glyph; glyphs)
            glDeleteTextures(1, &glyph.textureId);
        if (glyphs.length > 0)
            Delete(glyphs);
        
        if (buffer.length > 0)
            Delete(buffer);
    }

    /// Loads a single glyph to the given OpenGL texture.
    uint loadGlyph(dchar code, GLuint texId)
    {
        FT_Glyph glyph;

        uint charIndex = FT_Get_Char_Index(ftFace, code);

        if (charIndex == 0)
        {
            //TODO: if character wasn't found in font file
        }

        auto res = FT_Load_Glyph(ftFace, charIndex, FT_LOAD_DEFAULT);

        if (res)
            exitWithError("FT_Load_Glyph failed with code " ~ res.to!string);

        if (FT_Get_Glyph(ftFace.glyph, &glyph))
            exitWithError("FT_Get_Glyph failed");

        FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, null, 1);
        FT_BitmapGlyph bitmapGlyph = cast(FT_BitmapGlyph)glyph;

        FT_Bitmap bitmap = bitmapGlyph.bitmap;

        int width = nextPowerOfTwo(bitmap.width);
        int height = nextPowerOfTwo(bitmap.rows);

        GLubyte[] img = New!(GLubyte[])(2 * width * height);

        foreach(j; 0..height)
        foreach(i; 0..width)
        {
            img[2 * (i + j * width)] = 255;
            img[2 * (i + j * width) + 1] =
                (i >= bitmap.width || j >= bitmap.rows)?
                 0 : bitmap.buffer[i + bitmap.width * j];
        }

        glBindTexture(GL_TEXTURE_2D, texId);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        glTexImage2D(GL_TEXTURE_2D,
            0, GL_RG8, width, height,
            0, GL_RG, GL_UNSIGNED_BYTE, img.ptr);

        Delete(img);

        Glyph g = Glyph(true, texId, glyph, width, height, ftFace.glyph.advance.x);
        glyphs[code] = g;

        return charIndex;
    }

    /// Loads a given character by its Unicode code point.
    dchar loadChar(dchar code)
    {
        GLuint tex;
        glGenTextures(1, &tex);
        loadGlyph(code, tex);
        return code;
    }

    /// Renders a single glyph by its Unicode code point at the given offset from the local origin.
    float renderGlyph(dchar code, float xShift, float yShift = 0.0f)
    {
        Glyph glyph;
        if (code in glyphs)
            glyph = glyphs[code];
        else
            glyph = glyphs[loadChar(code)];

        FT_BitmapGlyph bitmapGlyph = cast(FT_BitmapGlyph)(glyph.ftGlyph);
        FT_Bitmap bitmap = bitmapGlyph.bitmap;

        glBindTexture(GL_TEXTURE_2D, glyph.textureId);

        float chWidth = cast(float)bitmap.width;
        float chHeight = cast(float)bitmap.rows;
        float texWidth = cast(float)glyph.width;
        float texHeight = cast(float)glyph.height;

        float x = 0.5f / texWidth + chWidth / texWidth;
        float y = 0.5f / texHeight + chHeight / texHeight;

        Vector2f glyphPosition, glyphScale, glyphTexcoordScale;

        glyphPosition = Vector2f(
            xShift + bitmapGlyph.left / pixelRatio,
            yShift / pixelRatio - bitmapGlyph.top / pixelRatio);
        glyphScale = Vector2f(
            cast(float)bitmap.width / pixelRatio,
            cast(float)bitmap.rows / pixelRatio);
        glyphTexcoordScale = Vector2f(x, y);
        
        glUniform2fv(glyphPositionLoc, 1, glyphPosition.arrayof.ptr);
        glUniform2fv(glyphScaleLoc, 1, glyphScale.arrayof.ptr);
        glUniform2fv(glyphTexcoordScaleLoc, 1, glyphTexcoordScale.arrayof.ptr);

        glBindVertexArray(vao);
        glDrawElements(GL_TRIANGLES, cast(uint)indices.length * 3, GL_UNSIGNED_INT, cast(void*)0);
        glBindVertexArray(0);

        xShift = cast(float)(glyph.advanceX >> 6) / pixelRatio;
        
        glBindTexture(GL_TEXTURE_2D, 0);

        return xShift;
    }

    /// Returns glyph's advance width (the distance from its origin to the origin of the next glyph on the line).
    int glyphAdvance(dchar code)
    {
        Glyph glyph;
        if (code in glyphs)
            glyph = glyphs[code];
        else
            glyph = glyphs[loadChar(code)];
        return cast(int)(glyph.advanceX >> 6);
    }
    
    /// Begins text rendering.
    void beginRender(GraphicsState* state, Color4f color)
    {
        if (!valid)
            return;
        
        glUseProgram(shaderProgram);

        glUniform2fv(resolutionLoc, 1, state.resolution.arrayof.ptr);
        glUniformMatrix4fv(modelViewMatrixLoc, 1, GL_FALSE, state.modelViewMatrix.arrayof.ptr);
        glUniformMatrix4fv(projectionMatrixLoc, 1, GL_FALSE, state.projectionMatrix.arrayof.ptr);
        glUniform4fv(glyphColorLoc, 1, color.arrayof.ptr);
        glUniform1i(glyphTextureLoc, 0);
    }
    
    /// Ends text rendering.
    void endRender()
    {
        if (!valid)
            return;
        
        glUseProgram(0);
    }

    /**
     * Renders the given UTF-8 string using the specified graphics pipeline state and color.
     *
     * Params:
     *   state = The graphics state to use for rendering.
     *   color = The color to render the text with.
     *   str   = The string to render.
     */
    void render(GraphicsState* state, Color4f color, string str)
    {
        if (!valid)
            return;

        beginRender(state, color);

        float shift = 0.0f;
        UTF8Decoder dec = UTF8Decoder(str);
        int ch;
        do
        {
            ch = dec.decodeNext();
            if (ch == 0 || ch == UTF8_END || ch == UTF8_ERROR) break;
            dchar code = ch;
            if (code.isASCII)
            {
                if (code.isPrintable)
                    shift += renderGlyph(code, shift);
            }
            else
                shift += renderGlyph(code, shift);
        } while(ch != UTF8_END && ch != UTF8_ERROR);

        endRender();
    }

    /**
     * Returns the width of the given single-line UTF-8 string in pixels.
     *
     * Params:
     *   str = The string to measure.
     * Returns:
     *   The width of the string.
     */
    float width(string str)
    {
        if (ftLibrary is null)
            return 0.0f;
        
        float width = 0.0f;
        UTF8Decoder dec = UTF8Decoder(str);
        int ch;
        do
        {
            ch = dec.decodeNext();
            if (ch == 0 || ch == UTF8_END || ch == UTF8_ERROR) break;
            dchar code = ch;
            if (code.isASCII)
            {
                if (code.isPrintable)
                    width += glyphAdvance(code);
            }
            else
                width += glyphAdvance(code);
        }
        while(ch != UTF8_END && ch != UTF8_ERROR);

        return width;
    }
    
    /**
     * Returns visual position of the glyph under the given index in the UTF-8 string.
     * Takes newlines into account.
     */
    Vector2f glyphPosition(string str, size_t index, float maxWidth, float lineHeight)
    {
        if (ftLibrary is null)
            return Vector2f(0.0f, 0.0f);
        
        float xShift = 0.0f;
        float yShift = 0.0f;
        UTF8Decoder dec = UTF8Decoder(str);
        int ch;
        size_t chIndex = 0;
        do
        {
            if (chIndex == index)
                break;
            
            ch = dec.decodeNext();
            if (ch == 0 || ch == UTF8_END || ch == UTF8_ERROR) break;
            dchar code = ch;
            
            if (code == '\n')
            {
                xShift = 0.0f;
                yShift += lineHeight;
            }
            else
            {
                if (code.isASCII)
                {
                    if (code.isPrintable)
                        xShift += glyphAdvance(code);
                }
                else
                    xShift += glyphAdvance(code);
                
                if (xShift > maxWidth)
                {
                    xShift = 0.0f;
                    yShift += lineHeight;
                }
            }
            
            chIndex++;
        }
        while(ch != 0 && ch != UTF8_END && ch != UTF8_ERROR);

        return Vector2f(xShift, yShift);
    }
}
