/*
Copyright (c) 2018 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dagon.graphics.deferred;

import std.stdio;
import std.conv;

import dlib.core.memory;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.transformation;
import dlib.image.color;

import derelict.opengl;

import dagon.core.ownership;
import dagon.graphics.rc;
import dagon.graphics.gbuffer;
import dagon.graphics.shadow;
import dagon.graphics.clustered;
import dagon.graphics.shapes;

class DeferredEnvironmentPass: Owner
{
    Vector2f[4] vertices;
    Vector2f[4] texcoords;
    uint[3][2] indices;
    
    GLuint vao = 0;
    GLuint vbo = 0;
    GLuint tbo = 0;
    GLuint eao = 0;
    
    GLenum envPassShaderVert;
    GLenum envPassShaderFrag;
    GLenum envPassShaderProgram;
    
    private string envPassVsText = 
    q{
        #version 330 core
        
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        uniform vec2 viewSize;
        
        layout (location = 0) in vec2 va_Vertex;
        layout (location = 1) in vec2 va_Texcoord;

        out vec2 texCoord;
        
        void main()
        {
            texCoord = va_Texcoord;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(va_Vertex * viewSize, 0.0, 1.0);
        }
    };
    
    private string envPassFsText =
    q{
        #version 330 core
        
        #define PI 3.14159265359
        const float PI2 = PI * 2.0;
        
        uniform sampler2D colorBuffer;
        uniform sampler2D rmsBuffer;
        uniform sampler2D positionBuffer;
        uniform sampler2D normalBuffer;
        uniform sampler2D emissionBuffer;
        uniform vec2 viewSize;

        uniform sampler2DArrayShadow shadowTextureArray;
        uniform float shadowTextureSize;
        //uniform bool useShadows;
        uniform mat4 shadowMatrix1;
        uniform mat4 shadowMatrix2;
        uniform mat4 shadowMatrix3;
        
        uniform sampler2D environmentMap;
        uniform bool useEnvironmentMap;
        
        uniform mat4 camViewMatrix;
        uniform mat4 camInvViewMatrix;
        uniform mat4 camProjectionMatrix;
        
        uniform vec3 sunDirection;
        uniform vec3 sunColor;
        uniform float sunEnergy;
        uniform vec3 skyZenithColor;
        uniform vec3 skyHorizonColor;
        uniform vec3 groundColor;
        uniform float skyEnergy;
        uniform float groundEnergy;

        in vec2 texCoord;
        
        layout(location = 0) out vec4 frag_color;
        layout(location = 1) out vec4 frag_luminance;
        
        const float eyeSpaceNormalShift = 0.05;
        
        float shadowLookup(in sampler2DArrayShadow depths, in float layer, in vec4 coord, in vec2 offset)
        {
            float texelSize = 1.0 / shadowTextureSize;
            vec2 v = offset * texelSize * coord.w;
            vec4 c = (coord + vec4(v.x, v.y, 0.0, 0.0)) / coord.w;
            c.w = c.z;
            c.z = layer;
            float s = texture(depths, c);
            return s;
        }
        
        float shadow(in sampler2DArrayShadow depths, in float layer, in vec4 coord, in float yshift)
        {
            return shadowLookup(depths, layer, coord, vec2(0.0, yshift));
        }
        
        float shadowPCF(in sampler2DArrayShadow depths, in float layer, in vec4 coord, in float radius, in float yshift)
        {
            float s = 0.0;
            float x, y;
	        for (y = -radius ; y < radius ; y += 1.0)
	        for (x = -radius ; x < radius ; x += 1.0)
            {
	            s += shadowLookup(depths, layer, coord, vec2(x, y + yshift));
            }
	        s /= radius * radius * 4.0;
            return s;
        }
        
        float weight(in vec4 tc, in float coef)
        {
            vec2 proj = vec2(tc.x / tc.w, tc.y / tc.w);
            proj = (1.0 - abs(proj * 2.0 - 1.0)) * coef;
            proj = clamp(proj, 0.0, 1.0);
            return min(proj.x, proj.y);
        }
        
        float rescale(float x, float mi, float ma)
        {
            return (max(x, mi) - mi) / (ma - mi);
        }
        
        float sigmoid(float x, float k)
        {
            float s = (x + x * k - k * 0.5 - 0.5) / (abs(x * k * 4.0 - k * 2.0) - k + 1.0) + 0.5;
            return clamp(s, 0.0, 1.0);
        }

        vec3 sky(vec3 wN, vec3 wSun, float roughness)
        {
            float downOrUp = dot(wN, vec3(0, 1, 0)) * 0.5 + 0.5;
            float groundOrSky = sigmoid(downOrUp, 1.0 - roughness);
            float horizonOrZenith = clamp(dot(wN, vec3(0, 1, 0)), 0.0, 1.0);
            vec3 env1 = mix(groundColor * groundEnergy, skyHorizonColor * skyEnergy, groundOrSky);
            vec3 env2 = mix(env1, skyZenithColor * skyEnergy, horizonOrZenith);
            return env2;
        }
        
        vec3 fresnel(float cosTheta, vec3 f0)
        {
            return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);
        }

        vec3 fresnelRoughness(float cosTheta, vec3 f0, float roughness)
        {
            return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(1.0 - cosTheta, 5.0);
        }
        
        float distributionGGX(vec3 N, vec3 H, float roughness)
        {
            float a = roughness * roughness;
            float a2 = a * a;
            float NdotH = max(dot(N, H), 0.0);
            float NdotH2 = NdotH * NdotH;
            float num = a2;
            float denom = max(NdotH2 * (a2 - 1.0) + 1.0, 0.001);
            denom = PI * denom * denom;
            return num / denom;
        }

        float geometrySchlickGGX(float NdotV, float roughness)
        {
            float r = (roughness + 1.0);
            float k = (r*r) / 8.0;
            float num = NdotV;
            float denom = NdotV * (1.0 - k) + k;
            return num / denom;
        }

        float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
        {
            float NdotV = max(dot(N, V), 0.0);
            float NdotL = max(dot(N, L), 0.0);
            float ggx2  = geometrySchlickGGX(NdotV, roughness);
            float ggx1  = geometrySchlickGGX(NdotL, roughness);
            return ggx1 * ggx2;
        }
        
        vec2 envMapEquirect(vec3 dir)
        {
            float phi = acos(dir.y);
            float theta = atan(dir.x, dir.z) + PI;
            return vec2(theta / PI2, phi / PI);
        }

        vec3 noise(vec2 coord)
        {
            float noiseX, noiseY, noiseZ;
            const float noiseamount = 0.0002;
            noiseX = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;
            noiseY = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233)*2.0)) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;
            noiseZ = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233)*3.0)) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;
            return vec3(noiseX, noiseY, noiseZ) * noiseamount;
        }
        
        const vec3 uKernelOffsets[10] = vec3[](
            vec3(-0.010735935, 0.01647018, 0.0062425877),
            vec3(-0.06533369, 0.3647007, -0.13746321),
            vec3(-0.6539235, -0.016726388, -0.53000957),
            vec3(0.40958285, 0.0052428036, -0.5591124),
            vec3(-0.1465366, 0.09899267, 0.15571679),
            vec3(-0.44122112, -0.5458797, 0.04912532),
            vec3(0.03755566, -0.10961345, -0.33040273),
            vec3(0.019100213, 0.29652783, 0.066237666),
            vec3(0.8765323, 0.011236004, 0.28265962),
            vec3(0.29264435, -0.40794238, 0.15964167));
            
        const int SSAO_SAMPLE_COUNT = 8;
        
        // TODO: make uniform
        const float ssaoRadius = 0.5;
        const float ssaoFalloff = 100.0;
        
        vec3 toLinear(vec3 v)
        {
            return pow(v, vec3(2.2));
        }
        
        float luminance(vec3 color)
        {
            return (
                color.x * 0.27 +
                color.y * 0.67 +
                color.z * 0.06
            );
        }
        
        void main()
        {
            vec4 col = texture(colorBuffer, texCoord);
            
            if (col.a < 1.0)
                discard;
            
            vec3 albedo = toLinear(col.rgb);
            
            vec4 rms = texture(rmsBuffer, texCoord);
            float roughness = rms.r;
            float metallic = rms.g;
            
            vec3 eyePos = texture(positionBuffer, texCoord).xyz;
            vec3 N = normalize(texture(normalBuffer, texCoord).xyz);
            vec3 E = normalize(-eyePos);
            vec3 R = reflect(E, N);

            vec3 worldPos = (camInvViewMatrix * vec4(eyePos, 1.0)).xyz;
            vec3 worldCamPos = (camInvViewMatrix[3]).xyz;
            vec3 worldView = normalize(worldPos - worldCamPos);
            vec3 worldN = normalize(N * mat3(camViewMatrix));
            vec3 worldR = reflect(worldView, worldN);
            vec3 worldSun = sunDirection * mat3(camViewMatrix);
        
            vec4 posShifted = vec4(eyePos, 1.0) + vec4(N * eyeSpaceNormalShift, 0.0);
            vec4 shadowCoord1 = shadowMatrix1 * posShifted;
            vec4 shadowCoord2 = shadowMatrix2 * posShifted;
            vec4 shadowCoord3 = shadowMatrix3 * posShifted;
            
            // Calculate shadow from 3 cascades           
            float s1, s2, s3;
            {            
                s1 = shadowPCF(shadowTextureArray, 0.0, shadowCoord1, 2.0, 0.0);
                s2 = shadow(shadowTextureArray, 1.0, shadowCoord2, 0.0);
                s3 = shadow(shadowTextureArray, 2.0, shadowCoord3, 0.0);
                float w1 = weight(shadowCoord1, 8.0);
                float w2 = weight(shadowCoord2, 8.0);
                float w3 = weight(shadowCoord3, 8.0);
                s3 = mix(1.0, s3, w3); 
                s2 = mix(s3, s2, w2);
                s1 = mix(s2, s1, w1); // s1 stores resulting shadow value
            }
            
            // SSAO
            vec3 rvec = noise(texCoord);
	        vec3 tangent = normalize(rvec - N * dot(rvec, N));
	        vec3 bitangent = cross(tangent, N);
            mat3 kernelBasis = mat3(tangent, bitangent, N);
            float occlusion = 0.0;
            for (int s = 0; s < SSAO_SAMPLE_COUNT; s++)
            {
                vec3 delta = kernelBasis * uKernelOffsets[s];
                delta *= float(dot(N, delta) >= 0.0) * 2.0 - 1.0;
                vec3 samplePos = eyePos + delta * ssaoRadius;

                vec4 projSamplePos = camProjectionMatrix * vec4(samplePos, 1.0);
                vec2 sampleUV = (projSamplePos.xy / projSamplePos.w) * 0.5 + 0.5;
                float sampleTargetZ = texture(positionBuffer, sampleUV).z;
                float d = sampleTargetZ - samplePos.z;
                occlusion += clamp(d, 0.0, 0.25) / 0.25;
            }
            float falloff = 1.0 - clamp(abs(eyePos.z) / ssaoFalloff, 0.0, 1.0);
            occlusion = 1.0 - (occlusion / float(SSAO_SAMPLE_COUNT)) * falloff;
            
            vec3 radiance = vec3(0.0, 0.0, 0.0);
            
            vec3 f0 = vec3(0.04); 
            f0 = mix(f0, albedo, metallic);
            
            // Sun light
            {
                vec3 L = sunDirection;
                float NL = max(dot(N, L), 0.0); 
                vec3 H = normalize(E + L); 
                
                float NDF = distributionGGX(N, H, roughness);        
                float G = geometrySmith(N, E, L, roughness);
                vec3 F = fresnel(max(dot(H, E), 0.0), f0);
                
                vec3 kS = F;
                vec3 kD = vec3(1.0) - kS;
                kD *= 1.0 - metallic;

                vec3 numerator = NDF * G * F;
                float denominator = 4.0 * max(dot(N, E), 0.0) * NL;
                vec3 specular = numerator / max(denominator, 0.001);

                radiance += (kD * albedo / PI + specular) * sunColor * sunEnergy * s1 * NL;
            }
            
            // Ambient light
            vec3 ambientDiffuse;
            vec3 ambientSpecular;
            if (useEnvironmentMap)
            {
                ivec2 envMapSize = textureSize(environmentMap, 0);
                float maxLod = log2(float(max(envMapSize.x, envMapSize.y))) - 1.0;
                float diffLod = maxLod;
                float specLod = maxLod * roughness;
                    
                ambientDiffuse = textureLod(environmentMap, envMapEquirect(worldN), diffLod).rgb;
                ambientSpecular = textureLod(environmentMap, envMapEquirect(worldR), specLod).rgb;
            }
            else
            {
                ambientDiffuse = sky(worldN, worldSun, 1.0);
                ambientSpecular = sky(worldR, worldSun, roughness);
            }
            
            {
                vec3 F = fresnelRoughness(max(dot(N, E), 0.0), f0, roughness);
                vec3 kS = F;
                vec3 kD = 1.0 - kS;
                kD *= 1.0 - metallic;
                vec3 diffuse = ambientDiffuse * albedo;
                vec3 ambient = kD * diffuse + F * ambientSpecular;
                radiance += ambient;
            }
            
            // Emission
            radiance += texture(emissionBuffer, texCoord).rgb;
            
            // Occlusion
            radiance *= occlusion;

            frag_color = vec4(radiance, 1.0);
            frag_luminance = vec4(luminance(radiance), 0.0, 0.0, 1.0);
        }
    };
    
    GLint modelViewMatrixLoc;
    GLint projectionMatrixLoc;
    
    GLint colorBufferLoc;
    GLint rmsBufferLoc;
    GLint positionBufferLoc;
    GLint normalBufferLoc;
    GLint emissionBufferLoc;
    
    GLint viewportSizeLoc;
    
    GLint sunDirectionLoc;
    GLint sunColorLoc;
    GLint sunEnergyLoc;
    
    GLint skyZenithColorLoc;
    GLint skyHorizonColorLoc;
    GLint skyEnergyLoc;
    GLint groundColorLoc;
    GLint groundEnergyLoc;
    
    GLint shadowMatrix1Loc;
    GLint shadowMatrix2Loc; 
    GLint shadowMatrix3Loc;
    GLint shadowTextureArrayLoc;
    GLint shadowTextureSizeLoc;
    
    GLint environmentMapLoc;
    GLint useEnvironmentMapLoc;
    
    GLint camProjectionMatrixLoc;
    GLint camViewMatrixLoc;
    GLint camInvViewMatrixLoc;
    
    GBuffer gbuffer;
    CascadedShadowMap shadowMap;
    
    Matrix4x4f defaultShadowMatrix;

    this(GBuffer gbuffer, CascadedShadowMap shadowMap, Owner o)
    {
        super(o);
        
        this.gbuffer = gbuffer;
        this.shadowMap = shadowMap;
        
        vertices[0] = Vector2f(0, 0);
        vertices[1] = Vector2f(0, 1);
        vertices[2] = Vector2f(1, 0);
        vertices[3] = Vector2f(1, 1);
        
        texcoords[0] = Vector2f(0, 1);
        texcoords[1] = Vector2f(0, 0);
        texcoords[2] = Vector2f(1, 1);
        texcoords[3] = Vector2f(1, 0);
        
        indices[0][0] = 0;
        indices[0][1] = 1;
        indices[0][2] = 2;
        
        indices[1][0] = 2;
        indices[1][1] = 1;
        indices[1][2] = 3;
        
        glGenBuffers(1, &vbo);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBufferData(GL_ARRAY_BUFFER, vertices.length * float.sizeof * 2, vertices.ptr, GL_STATIC_DRAW); 

        glGenBuffers(1, &tbo);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glBufferData(GL_ARRAY_BUFFER, texcoords.length * float.sizeof * 2, texcoords.ptr, GL_STATIC_DRAW);

        glGenBuffers(1, &eao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.length * uint.sizeof * 3, indices.ptr, GL_STATIC_DRAW);

        glGenVertexArrays(1, &vao);
        glBindVertexArray(vao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
    
        glEnableVertexAttribArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, null);
    
        glEnableVertexAttribArray(1);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, null);

        glBindVertexArray(0);
        
        const(char*)pvs = envPassVsText.ptr;
        const(char*)pfs = envPassFsText.ptr;
        
        char[1000] infobuffer = 0;
        int infobufferlen = 0;

        envPassShaderVert = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(envPassShaderVert, 1, &pvs, null);
        glCompileShader(envPassShaderVert);
        GLint success = 0;
        glGetShaderiv(envPassShaderVert, GL_COMPILE_STATUS, &success);
        if (!success)
        {
            GLint logSize = 0;
            glGetShaderiv(envPassShaderVert, GL_INFO_LOG_LENGTH, &logSize);
            glGetShaderInfoLog(envPassShaderVert, 999, &logSize, infobuffer.ptr);
            writeln("Error in vertex shader:");
            writeln(infobuffer[0..logSize]);
        }

        envPassShaderFrag = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(envPassShaderFrag, 1, &pfs, null);
        glCompileShader(envPassShaderFrag);
        success = 0;
        glGetShaderiv(envPassShaderFrag, GL_COMPILE_STATUS, &success);
        if (!success)
        {
            GLint logSize = 0;
            glGetShaderiv(envPassShaderFrag, GL_INFO_LOG_LENGTH, &logSize);
            glGetShaderInfoLog(envPassShaderFrag, 999, &logSize, infobuffer.ptr);
            writeln("Error in fragment shader:");
            writeln(infobuffer[0..logSize]);
        }

        envPassShaderProgram = glCreateProgram();
        glAttachShader(envPassShaderProgram, envPassShaderVert);
        glAttachShader(envPassShaderProgram, envPassShaderFrag);
        glLinkProgram(envPassShaderProgram);
        
        modelViewMatrixLoc = glGetUniformLocation(envPassShaderProgram, "modelViewMatrix");
        projectionMatrixLoc = glGetUniformLocation(envPassShaderProgram, "projectionMatrix");

        viewportSizeLoc = glGetUniformLocation(envPassShaderProgram, "viewSize");
        
        colorBufferLoc = glGetUniformLocation(envPassShaderProgram, "colorBuffer");
        rmsBufferLoc = glGetUniformLocation(envPassShaderProgram, "rmsBuffer");
        positionBufferLoc = glGetUniformLocation(envPassShaderProgram, "positionBuffer");
        normalBufferLoc = glGetUniformLocation(envPassShaderProgram, "normalBuffer");
        emissionBufferLoc = glGetUniformLocation(envPassShaderProgram, "emissionBuffer");
        
        sunDirectionLoc = glGetUniformLocation(envPassShaderProgram, "sunDirection");
        sunColorLoc = glGetUniformLocation(envPassShaderProgram, "sunColor");
        sunEnergyLoc = glGetUniformLocation(envPassShaderProgram, "sunEnergy");
     
        skyZenithColorLoc = glGetUniformLocation(envPassShaderProgram, "skyZenithColor");
        skyHorizonColorLoc = glGetUniformLocation(envPassShaderProgram, "skyHorizonColor");
        skyEnergyLoc = glGetUniformLocation(envPassShaderProgram, "skyEnergy");
        groundColorLoc = glGetUniformLocation(envPassShaderProgram, "groundColor");
        groundEnergyLoc = glGetUniformLocation(envPassShaderProgram, "groundEnergy");
        
        shadowMatrix1Loc = glGetUniformLocation(envPassShaderProgram, "shadowMatrix1");
        shadowMatrix2Loc = glGetUniformLocation(envPassShaderProgram, "shadowMatrix2");
        shadowMatrix3Loc = glGetUniformLocation(envPassShaderProgram, "shadowMatrix3");
        shadowTextureArrayLoc = glGetUniformLocation(envPassShaderProgram, "shadowTextureArray");
        shadowTextureSizeLoc = glGetUniformLocation(envPassShaderProgram, "shadowTextureSize");
        
        environmentMapLoc = glGetUniformLocation(envPassShaderProgram, "environmentMap");
        useEnvironmentMapLoc = glGetUniformLocation(envPassShaderProgram, "useEnvironmentMap");
        
        camProjectionMatrixLoc = glGetUniformLocation(envPassShaderProgram, "camProjectionMatrix");
        camViewMatrixLoc = glGetUniformLocation(envPassShaderProgram, "camViewMatrix");
        camInvViewMatrixLoc = glGetUniformLocation(envPassShaderProgram, "camInvViewMatrix");
    }
    
    ~this()
    {
        glDeleteVertexArrays(1, &vao);
        glDeleteBuffers(1, &vbo);
        glDeleteBuffers(1, &tbo);
        glDeleteBuffers(1, &eao);
    }
    
    void render(RenderingContext* rc2d, RenderingContext* rc3d)
    {    
        glUseProgram(envPassShaderProgram);
        
        glUniformMatrix4fv(modelViewMatrixLoc, 1, 0, rc2d.viewMatrix.arrayof.ptr);
        glUniformMatrix4fv(projectionMatrixLoc, 1, 0, rc2d.projectionMatrix.arrayof.ptr);
        
        Vector2f viewportSize;
        
        viewportSize = Vector2f(rc3d.eventManager.windowWidth, rc3d.eventManager.windowHeight);
        glUniform2fv(viewportSizeLoc, 1, viewportSize.arrayof.ptr);

        Vector4f sunVector = Vector4f(0.0f, 1.0f, 0.0, 0.0f);
        Vector3f sunColor = Vector3f(1.0f, 1.0f, 1.0f);
        float sunEnergy = 100.0f;
        Color4f skyZenithColor = Color4f(0, 0, 0, 0);
        Color4f skyHorizonColor = Color4f(0, 0, 0, 0);
        float skyEnergy = 1.0f;
        Color4f groundColor = Color4f(0, 0, 0, 0);
        float groundEnergy = 1.0f;
        if (rc3d.environment)
        {
            sunVector = Vector4f(rc3d.environment.sunDirection);
            sunVector.w = 0.0;
            
            sunColor = rc3d.environment.sunColor;
            sunEnergy = rc3d.environment.sunEnergy;
            
            skyZenithColor = rc3d.environment.skyZenithColor;
            skyHorizonColor = rc3d.environment.skyHorizonColor;
            groundColor = rc3d.environment.groundColor;
            skyEnergy = rc3d.environment.skyEnergy;
            groundEnergy = rc3d.environment.groundEnergy;
        }
        
        Vector3f sunDirectionEye = sunVector * rc3d.viewMatrix;
        glUniform3fv(sunDirectionLoc, 1, sunDirectionEye.arrayof.ptr);
        glUniform3fv(sunColorLoc, 1, sunColor.arrayof.ptr);
        glUniform1f(sunEnergyLoc, sunEnergy);

        glUniform3fv(skyZenithColorLoc, 1, skyZenithColor.arrayof.ptr);
        glUniform3fv(skyHorizonColorLoc, 1, skyHorizonColor.arrayof.ptr);
        glUniform1f(skyEnergyLoc, skyEnergy);
        glUniform3fv(groundColorLoc, 1, groundColor.arrayof.ptr);
        glUniform1f(groundEnergyLoc, groundEnergy);
        
        glUniformMatrix4fv(camProjectionMatrixLoc, 1, 0, rc3d.projectionMatrix.arrayof.ptr);
        glUniformMatrix4fv(camViewMatrixLoc, 1, 0, rc3d.viewMatrix.arrayof.ptr);
        glUniformMatrix4fv(camInvViewMatrixLoc, 1, 0, rc3d.invViewMatrix.arrayof.ptr);
        
        // Texture 0 - color buffer
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, gbuffer.colorTexture);
        glUniform1i(colorBufferLoc, 0);
        
        // Texture 1 - roughness-metallic-specularity buffer
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, gbuffer.rmsTexture);
        glUniform1i(rmsBufferLoc, 1);
        
        // Texture 2 - position buffer
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, gbuffer.positionTexture);
        glUniform1i(positionBufferLoc, 2);
        
        // Texture 3 - normal buffer
        glActiveTexture(GL_TEXTURE3);
        glBindTexture(GL_TEXTURE_2D, gbuffer.normalTexture);
        glUniform1i(normalBufferLoc, 3);
        
        // Texture 4 - environment map
        bool useEnvmap = false;
        if (rc3d.environment)
        {
            if (rc3d.environment.environmentMap)
                useEnvmap = true;
        }
        if (useEnvmap)
        {
            glActiveTexture(GL_TEXTURE4);
            rc3d.environment.environmentMap.bind();
            glUniform1i(useEnvironmentMapLoc, 1);
        }
        else
        {
            glUniform1i(useEnvironmentMapLoc, 0);
        }
        glUniform1i(environmentMapLoc, 4);
        
        // Texture 5 - emission buffer
        glActiveTexture(GL_TEXTURE5);
        glBindTexture(GL_TEXTURE_2D, gbuffer.emissionTexture);
        glUniform1i(emissionBufferLoc, 5);
        
        // Texture 8 - shadow map cascades (3 layer texture array)
        if (shadowMap)
        {
            glActiveTexture(GL_TEXTURE7);
            glBindTexture(GL_TEXTURE_2D_ARRAY, shadowMap.depthTexture);
            glUniform1i(shadowTextureArrayLoc, 7);
            glUniform1f(shadowTextureSizeLoc, cast(float)shadowMap.size);
            glUniformMatrix4fv(shadowMatrix1Loc, 1, 0, shadowMap.area1.shadowMatrix.arrayof.ptr);
            glUniformMatrix4fv(shadowMatrix2Loc, 1, 0, shadowMap.area2.shadowMatrix.arrayof.ptr);
            glUniformMatrix4fv(shadowMatrix3Loc, 1, 0, shadowMap.area3.shadowMatrix.arrayof.ptr);
        }
        else
        {        
            glUniformMatrix4fv(shadowMatrix1Loc, 1, 0, defaultShadowMatrix.arrayof.ptr);
            glUniformMatrix4fv(shadowMatrix2Loc, 1, 0, defaultShadowMatrix.arrayof.ptr);
            glUniformMatrix4fv(shadowMatrix3Loc, 1, 0, defaultShadowMatrix.arrayof.ptr);
        }
        
        glActiveTexture(GL_TEXTURE0);

        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_FALSE);
        glBindVertexArray(vao);
        glDrawElements(GL_TRIANGLES, cast(uint)indices.length * 3, GL_UNSIGNED_INT, cast(void*)0);
        glBindVertexArray(0);
        glDepthMask(GL_TRUE);
        glEnable(GL_DEPTH_TEST);

        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE3);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE5);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE8);
        glBindTexture(GL_TEXTURE_2D_ARRAY, 0);
        
        glActiveTexture(GL_TEXTURE0);
        
        glUseProgram(0);
    }
}

class DeferredLightPass: Owner
{
    Vector2f[4] vertices;
    Vector2f[4] texcoords;
    uint[3][2] indices;
    
    GLuint vao = 0;
    GLuint vbo = 0;
    GLuint tbo = 0;
    GLuint eao = 0;
    
    GLenum lightPassShaderVert;
    GLenum lightPassShaderFrag;
    GLenum lightPassShaderProgram;
    
    private string lightPassVsText = 
    q{
        #version 330 core
        
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        uniform vec2 viewSize;
        
        layout (location = 0) in vec3 va_Vertex;
        
        void main()
        {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(va_Vertex, 1.0);
        }
    };
    
    private string lightPassFsText =
    q{
        #version 330 core
        
        #define PI 3.14159265359
        
        uniform sampler2D colorBuffer;
        uniform sampler2D rmsBuffer;
        uniform sampler2D positionBuffer;
        uniform sampler2D normalBuffer;
        
        uniform vec2 viewSize;
        
        uniform vec3 lightPosition;
        uniform float lightRadius;
        uniform float lightAreaRadius;
        uniform vec3 lightColor;
        uniform float lightEnergy;
        
        layout(location = 0) out vec4 frag_color;
        layout(location = 1) out vec4 frag_luminance;

        vec3 fresnel(float cosTheta, vec3 f0)
        {
            return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);
        }

        vec3 fresnelRoughness(float cosTheta, vec3 f0, float roughness)
        {
            return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(1.0 - cosTheta, 5.0);
        }
        
        float distributionGGX(vec3 N, vec3 H, float roughness)
        {
            float a = roughness * roughness;
            float a2 = a * a;
            float NdotH = max(dot(N, H), 0.0);
            float NdotH2 = NdotH * NdotH;
            float num = a2;
            float denom = max(NdotH2 * (a2 - 1.0) + 1.0, 0.001);
            denom = PI * denom * denom;
            return num / denom;
        }

        float geometrySchlickGGX(float NdotV, float roughness)
        {
            float r = (roughness + 1.0);
            float k = (r*r) / 8.0;
            float num = NdotV;
            float denom = NdotV * (1.0 - k) + k;
            return num / denom;
        }

        float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
        {
            float NdotV = max(dot(N, V), 0.0);
            float NdotL = max(dot(N, L), 0.0);
            float ggx2  = geometrySchlickGGX(NdotV, roughness);
            float ggx1  = geometrySchlickGGX(NdotL, roughness);
            return ggx1 * ggx2;
        }
        
        vec3 toLinear(vec3 v)
        {
            return pow(v, vec3(2.2));
        }
        
        float luminance(vec3 color)
        {
            return (
                color.x * 0.27 +
                color.y * 0.67 +
                color.z * 0.06
            );
        }
        
        void main()
        {
            vec2 texCoord = gl_FragCoord.xy / viewSize;
            
            vec4 col = texture(colorBuffer, texCoord);
            
            if (col.a < 1.0)
                discard;
            
            vec3 albedo = toLinear(col.rgb);
            
            vec4 rms = texture(rmsBuffer, texCoord);
            float roughness = rms.r;
            float metallic = rms.g;
            
            vec3 eyePos = texture(positionBuffer, texCoord).xyz;
            vec3 N = normalize(texture(normalBuffer, texCoord).xyz);
            vec3 E = normalize(-eyePos);
            vec3 R = reflect(E, N);
            
            vec3 f0 = vec3(0.04); 
            f0 = mix(f0, albedo, metallic);
            
            vec3 positionToLightSource = lightPosition - eyePos;
            float distanceToLight = length(positionToLightSource);           
            float attenuation = pow(clamp(1.0 - (distanceToLight / lightRadius), 0.0, 1.0), 2.0) * lightEnergy;
            
            vec3 Lpt = normalize(positionToLightSource);

            vec3 centerToRay = dot(positionToLightSource, R) * R - positionToLightSource;
            vec3 closestPoint = positionToLightSource + centerToRay * clamp(lightAreaRadius / length(centerToRay), 0.0, 1.0);
            vec3 L = normalize(closestPoint);  

            float NL = max(dot(N, Lpt), 0.0); 
            vec3 H = normalize(E + L);
                    
            float NDF = distributionGGX(N, H, roughness);        
            float G = geometrySmith(N, E, L, roughness);      
            vec3 F = fresnel(max(dot(H, E), 0.0), f0);
                    
            vec3 kS = F;
            vec3 kD = vec3(1.0) - kS;
            kD *= 1.0 - metallic;

            vec3 numerator = NDF * G * F;
            float denominator = 4.0 * max(dot(N, E), 0.0) * NL;
            vec3 specular = numerator / max(denominator, 0.001);
                    
            vec3 radiance = (kD * albedo / PI + specular) * lightColor * attenuation * NL;

            frag_color = vec4(radiance, 1.0);
            frag_luminance = vec4(luminance(radiance), 0.0, 0.0, 1.0);
        }
    };
    
    GLint modelViewMatrixLoc;
    GLint projectionMatrixLoc;
    
    GLint colorBufferLoc;
    GLint rmsBufferLoc;
    GLint positionBufferLoc;
    GLint normalBufferLoc;
    
    GLint viewportSizeLoc;
    
    GLint lightPositionLoc;
    GLint lightRadiusLoc;
    GLint lightAreaRadiusLoc;
    GLint lightColorLoc;
    GLint lightEnergyLoc;
    
    GBuffer gbuffer;
    ClusteredLightManager lightManager;
    ShapeSphere lightVolume;

    this(GBuffer gbuffer, ClusteredLightManager lightManager, Owner o)
    {
        super(o);
        
        this.gbuffer = gbuffer;
        this.lightManager = lightManager;
        this.lightVolume = New!ShapeSphere(1.0f, 8, 4, false, this);
        
        vertices[0] = Vector2f(0, 0);
        vertices[1] = Vector2f(0, 1);
        vertices[2] = Vector2f(1, 0);
        vertices[3] = Vector2f(1, 1);
        
        texcoords[0] = Vector2f(0, 1);
        texcoords[1] = Vector2f(0, 0);
        texcoords[2] = Vector2f(1, 1);
        texcoords[3] = Vector2f(1, 0);
        
        indices[0][0] = 0;
        indices[0][1] = 1;
        indices[0][2] = 2;
        
        indices[1][0] = 2;
        indices[1][1] = 1;
        indices[1][2] = 3;
        
        glGenBuffers(1, &vbo);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBufferData(GL_ARRAY_BUFFER, vertices.length * float.sizeof * 2, vertices.ptr, GL_STATIC_DRAW); 

        glGenBuffers(1, &tbo);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glBufferData(GL_ARRAY_BUFFER, texcoords.length * float.sizeof * 2, texcoords.ptr, GL_STATIC_DRAW);

        glGenBuffers(1, &eao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.length * uint.sizeof * 3, indices.ptr, GL_STATIC_DRAW);

        glGenVertexArrays(1, &vao);
        glBindVertexArray(vao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
    
        glEnableVertexAttribArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, null);
    
        glEnableVertexAttribArray(1);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, null);

        glBindVertexArray(0);
        
        const(char*)pvs = lightPassVsText.ptr;
        const(char*)pfs = lightPassFsText.ptr;
        
        char[1000] infobuffer = 0;
        int infobufferlen = 0;

        lightPassShaderVert = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(lightPassShaderVert, 1, &pvs, null);
        glCompileShader(lightPassShaderVert);
        GLint success = 0;
        glGetShaderiv(lightPassShaderVert, GL_COMPILE_STATUS, &success);
        if (!success)
        {
            GLint logSize = 0;
            glGetShaderiv(lightPassShaderVert, GL_INFO_LOG_LENGTH, &logSize);
            glGetShaderInfoLog(lightPassShaderVert, 999, &logSize, infobuffer.ptr);
            writeln("Error in vertex shader:");
            writeln(infobuffer[0..logSize]);
        }

        lightPassShaderFrag = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(lightPassShaderFrag, 1, &pfs, null);
        glCompileShader(lightPassShaderFrag);
        success = 0;
        glGetShaderiv(lightPassShaderFrag, GL_COMPILE_STATUS, &success);
        if (!success)
        {
            GLint logSize = 0;
            glGetShaderiv(lightPassShaderFrag, GL_INFO_LOG_LENGTH, &logSize);
            glGetShaderInfoLog(lightPassShaderFrag, 999, &logSize, infobuffer.ptr);
            writeln("Error in fragment shader:");
            writeln(infobuffer[0..logSize]);
        }

        lightPassShaderProgram = glCreateProgram();
        glAttachShader(lightPassShaderProgram, lightPassShaderVert);
        glAttachShader(lightPassShaderProgram, lightPassShaderFrag);
        glLinkProgram(lightPassShaderProgram);
        
        modelViewMatrixLoc = glGetUniformLocation(lightPassShaderProgram, "modelViewMatrix");
        projectionMatrixLoc = glGetUniformLocation(lightPassShaderProgram, "projectionMatrix");

        viewportSizeLoc = glGetUniformLocation(lightPassShaderProgram, "viewSize");
        
        colorBufferLoc = glGetUniformLocation(lightPassShaderProgram, "colorBuffer");
        rmsBufferLoc = glGetUniformLocation(lightPassShaderProgram, "rmsBuffer");
        positionBufferLoc = glGetUniformLocation(lightPassShaderProgram, "positionBuffer");
        normalBufferLoc = glGetUniformLocation(lightPassShaderProgram, "normalBuffer");
        
        lightPositionLoc = glGetUniformLocation(lightPassShaderProgram, "lightPosition");
        lightRadiusLoc = glGetUniformLocation(lightPassShaderProgram, "lightRadius");
        lightEnergyLoc = glGetUniformLocation(lightPassShaderProgram, "lightEnergy");
        lightAreaRadiusLoc = glGetUniformLocation(lightPassShaderProgram, "lightAreaRadius");
        lightColorLoc = glGetUniformLocation(lightPassShaderProgram, "lightColor");
    }
    
    ~this()
    {
        glDeleteVertexArrays(1, &vao);
        glDeleteBuffers(1, &vbo);
        glDeleteBuffers(1, &tbo);
        glDeleteBuffers(1, &eao);
    }
    
    void render(RenderingContext* rc2d, RenderingContext* rc3d)
    {    
        glUseProgram(lightPassShaderProgram);

        glUniformMatrix4fv(projectionMatrixLoc, 1, 0, rc3d.projectionMatrix.arrayof.ptr);
        
        Vector2f viewportSize;
        
        viewportSize = Vector2f(rc3d.eventManager.windowWidth, rc3d.eventManager.windowHeight);
        glUniform2fv(viewportSizeLoc, 1, viewportSize.arrayof.ptr);

        // Texture 0 - color buffer
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, gbuffer.colorTexture);
        glUniform1i(colorBufferLoc, 0);
        
        // Texture 1 - roughness-metallic-specularity buffer
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, gbuffer.rmsTexture);
        glUniform1i(rmsBufferLoc, 1);
        
        // Texture 2 - position buffer
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, gbuffer.positionTexture);
        glUniform1i(positionBufferLoc, 2);
        
        // Texture 3 - normal buffer
        glActiveTexture(GL_TEXTURE3);
        glBindTexture(GL_TEXTURE_2D, gbuffer.normalTexture);
        glUniform1i(normalBufferLoc, 3);
        
        glActiveTexture(GL_TEXTURE0);

        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_FALSE);
        
        glEnable(GL_CULL_FACE);
        glCullFace(GL_FRONT);
        
        glEnablei(GL_BLEND, 0);
        glEnablei(GL_BLEND, 1);
        glBlendFunci(0, GL_ONE, GL_ONE);
        glBlendFunci(1, GL_ONE, GL_ONE);
        
        foreach(light; lightManager.lightSources.data)
        {
            Matrix4x4f modelViewMatrix = 
                rc3d.viewMatrix *
                translationMatrix(light.position) * 
                scaleMatrix(Vector3f(light.radius, light.radius, light.radius));
            glUniformMatrix4fv(modelViewMatrixLoc, 1, 0, modelViewMatrix.arrayof.ptr);
            
            Vector3f lightPositionEye = light.position * rc3d.viewMatrix;
            
            glUniform3fv(lightPositionLoc, 1, lightPositionEye.arrayof.ptr);
            glUniform1f(lightRadiusLoc, light.radius);
            glUniform1f(lightAreaRadiusLoc, light.areaRadius);
            glUniform3fv(lightColorLoc, 1, light.color.arrayof.ptr);
            glUniform1f(lightEnergyLoc, light.energy);
            
            lightVolume.render(rc3d);
        }
        
        glDisablei(GL_BLEND, 0);
        glDisablei(GL_BLEND, 1);
        
        glCullFace(GL_BACK);
        glDisable(GL_CULL_FACE);
        
        glDepthMask(GL_TRUE);
        glEnable(GL_DEPTH_TEST);

        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE3);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        glActiveTexture(GL_TEXTURE0);
        
        glUseProgram(0);
    }
}
