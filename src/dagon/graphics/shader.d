/*
Copyright (c) 2018-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides classes and utilities for OpenGL shader management.
 *
 * The `dagon.graphics.shader` module defines the `Shader` class for managing
 * OpenGL shader programs, uniform, subroutine and UBO parameters, and binding logic.
 * The module also includes `ShaderProgram` for program compilation/linking.
 *
 * Copyright: Timur Gafarov 2018-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.shader;

import core.stdc.string;
import std.stdio;
import std.string;
import std.algorithm;
import std.file;
import std.digest.murmurhash;

import dlib.core.ownership;
import dlib.core.memory;
import dlib.core.stream;
import dlib.container.array;
import dlib.container.dict;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.utils: min2;
import dlib.image.color;
import dlib.filesystem.filesystem;
import dlib.filesystem.stdfs;
import dlib.text.str;

import dagon.core.application;
import dagon.core.bindings;
import dagon.core.logger;
import dagon.core.vfs;
import dagon.core.mappedlist;
import dagon.core.shaderloader;
import dagon.graphics.texture;
import dagon.graphics.state;

/**
 * Global shader cache for saving and loading compiled shader binaries.
 */
class ShaderCache: Owner
{
    /// Virtual filesystem to use for file operations.
    VirtualFileSystem vfs;

    /// Standard filesystem interface.
    StdFileSystem fs;
    
    /// Cache folder path.
    string cacheFolder = "data/__internal/shader_cache";
    
    /// Whether the shader cache is enabled.
    bool enabled = false;
    
    /// Constructor.
    this(VirtualFileSystem vfs, Owner owner)
    {
        super(owner);
        this.vfs = vfs;
        fs = vfs.stdfs;
        fs.createDir(cacheFolder, true);
    }
    
    /// Saves a compiled shader binary to file.
    void saveBinary(string filename, ubyte[] data)
    {
        string dirSeparator;
        version(Windows) dirSeparator = "\\";
        version(Posix) dirSeparator = "/";
        
        String path = String(cacheFolder);
        path ~= "/";
        path ~= filename;
        
        OutputStream strm = fs.openForOutput(path, FileSystem.create);
        strm.writeArray(data);
        strm.close();
        Delete(strm);
        
        path.free();
    }
    
    /// Loads a shader binary from file.
    ubyte[] loadBinary(string filename)
    {
        ubyte[] binary;
        
        String path = String(cacheFolder);
        path ~= "/";
        path ~= filename;
        
        if (vfs.exists(path))
        {
            FileStat s;
            fs.stat(path, s);
            size_t size = cast(size_t)s.sizeInBytes;
            if (size > 0)
            {
                auto istrm = fs.openForInput(path);
                binary = New!(ubyte[])(size);
                istrm.fillArray(binary);
                Delete(istrm);
            }
        }
        
        return binary;
    }
}

/**
 * A shader program class that can be shared between multiple `Shader` instances.
 * Manages OpenGL program object.
 */
abstract class BaseShaderProgram: Owner
{
    /// OpenGL program handle.
    GLuint program;

    /// Number of vertex shader subroutine uniform locations.
    GLsizei numVertexSubroutines = 0;

    /// Number of fragment shader subroutine uniform locations.
    GLsizei numFragmentSubroutines = 0;

    /// Number of compute shader subroutine uniform locations.
    GLsizei numComputeSubroutines = 0;
    
    /// Compiled shader binary data.
    ubyte[] binary;

    /// Size of the shader binary data.
    GLint binarySize = 0;

    /// Format of the shader binary data.
    GLenum binaryFormat;
    
    /// Constructor.
    this(Owner owner)
    {
        super(owner);
    }
    
    /// Destructor. Frees the shader binary data.
    ~this()
    {
        if (binary.length)
            Delete(binary);
    }

    /// Binds the shader program for use.
    void bind()
    {
        glUseProgram(program);
    }

    /// Unbinds the shader program.
    void unbind()
    {
        glUseProgram(0);
    }

    /// Validates the program.
    bool validate()
    {
        glValidateProgram(program);
        
        GLint status;
        glGetProgramiv(program, GL_VALIDATE_STATUS, &status);
        
        if (status != GL_TRUE)
        {
            GLint infolen;
            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infolen);
            if (infolen > 0)
            {
                char[logMaxLen + 1] infobuffer = 0;
                glGetProgramInfoLog(program, logMaxLen, null, infobuffer.ptr);
                infolen = min2(infolen - 1, logMaxLen);
                char[] s = stripRight(infobuffer[0..infolen]);
                logError(s);
            }
        }

        return(status == GL_TRUE);
    }
    
    /// Saves the compiled shader binary to the cache.
    void saveBinary(string name)
    {
        static if (glSupport >= GLSupport.gl41)
        {
            // Get the size of the binary
            glGetProgramiv(program, GL_PROGRAM_BINARY_LENGTH, &binarySize);
            
            if (binarySize > 0)
            {
                // Allocate buffer for the binary, as well as the binary format
                size_t bufferSize = GLenum.sizeof + binarySize;
                binary = New!(ubyte[])(bufferSize);
                
                // Get the binary from the driver, saving the format
                glGetProgramBinary(program, binarySize, null, &binaryFormat, binary.ptr + GLenum.sizeof);
                *(cast(GLenum*)binary.ptr) = binaryFormat;
                
                globalShaderCache.saveBinary(name, binary);
            }
        }
    }
    
    /// Loads a compiled shader binary from the cache.
    bool loadBinary(string name)
    {
        static if (glSupport >= GLSupport.gl41)
        {
            binary = globalShaderCache.loadBinary(name);
            if (binary.length)
            {
                program = glCreateProgram();
                binaryFormat = *(cast(GLenum*)binary.ptr);
                binarySize = cast(uint)(binary.length - GLenum.sizeof);
                glProgramBinary(program, binaryFormat, binary.ptr + GLenum.sizeof, binarySize);
                
                if (checkLinking(program))
                {
                    debug logDebug("Loaded cached shader binary ", name);
                    return true;
                }
                else
                {
                    glDeleteProgram(program);
                    return false;
                }
            }
            else
                return false;
        }
        
        return false;
    }
}

/**
 * Represents a compiled and linked shader program with vertex and fragment shaders.
 */
class ShaderProgram: BaseShaderProgram
{
    /// Compiles and links a shader program from vertex and fragment sources.
    this(string vertexShaderSrc, string fragmentShaderSrc, Owner owner)
    {
        super(owner);
        
        bool recompilationNeeded = true;
        
        ubyte[16] hashBytes;
        string hash;
        
        if (globalShaderCache.enabled)
        {
            hashBytes = digest!(MurmurHash3!(128, 64))(vertexShaderSrc, fragmentShaderSrc)[];
            hash = toHexString(hashBytes).idup;
            
            if (loadBinary(hash))
            {
                recompilationNeeded = false;
                getNumSubroutines();
            }
        }

        if (recompilationNeeded)
        {
            GLuint vert = compileShader(vertexShaderSrc, ShaderStage.vertex);
            GLuint frag = compileShader(fragmentShaderSrc, ShaderStage.fragment);
            if (vert != 0 && frag != 0)
            {
                program = linkShaders(vert, frag);
                getNumSubroutines();
                if (globalShaderCache.enabled)
                    saveBinary(hash);
            }
        }
    }
    
    /// Gets the number of subroutine uniform locations for vertex and fragment shaders.
    final void getNumSubroutines()
    {
        glGetProgramStageiv(program,
            GL_VERTEX_SHADER,
            GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS,
            &numVertexSubroutines);
        
        glGetProgramStageiv(program,
            GL_FRAGMENT_SHADER,
            GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS,
            &numFragmentSubroutines);
    }
}

/**
 * Abstract base class for shader parameters (uniforms and subroutines).
 * Stores parameter name, location, and binding logic.
 */
abstract class BaseShaderParameter: Owner
{
    /// Owning shader.
    Shader shader;

    /// Parameter name.
    string name;

    /// Parameter location in the shader program.
    GLint location;

    /// Whether to automatically bind the parameter when the shader is bound.
    bool autoBind = true;

    /// Initializes the uniform location.
    this(Shader shader, string name)
    {
        super(shader);
        this.shader = shader;
        this.name = name;
    }

    /// Initializes the uniform location.
    void initUniform();

    /// Binds the parameter value to the shader.
    void bind();

    /// Unbinds the parameter.
    void unbind();
}

/// Shader type enumeration.
enum ShaderType
{
    Vertex,
    Fragment,
    Compute
}

/**
 * Represents a shader subroutine parameter.
 * Allows selection of subroutine implementations for vertex or fragment shaders.
 */
class ShaderSubroutine: BaseShaderParameter
{
    /// Shader type.
    ShaderType shaderType;

    /// Subroutine location and index.
    GLint location;

    /// Subroutine index.
    GLuint index;

    /// Parameter name.
    String _name;

    /// Subroutine name.
    String subroutineName;

    /// Creates a subroutine parameter for the given shader and type.
    this(Shader shader, ShaderType shaderType, string name)
    {
        super(shader, name);
        this.shaderType = shaderType;
        this._name = String(name);
        initUniform();
    }

    /// Creates a subroutine parameter with a specific subroutine name.
    this(Shader shader, ShaderType shaderType, string name, string subroutineName)
    {
        super(shader, name);
        this.shaderType = shaderType;
        this._name = String(name);
        this.subroutineName = String(subroutineName);
        initUniform();
    }
    
    /// Destructor. Frees all allocated resources.
    ~this()
    {
        _name.free();
        subroutineName.free();
    }

    /// Initializes the uniform location.
    override final void initUniform()
    {
        if (shaderType == ShaderType.Vertex)
        {
            location = glGetSubroutineUniformLocation(shader.program.program, GL_VERTEX_SHADER, _name.ptr);
            if (subroutineName.length)
                index = glGetSubroutineIndex(shader.program.program, GL_VERTEX_SHADER, subroutineName.ptr);
        }
        else if (shaderType == ShaderType.Fragment)
        {
            location = glGetSubroutineUniformLocation(shader.program.program, GL_FRAGMENT_SHADER, _name.ptr);
            if (subroutineName.length)
                index = glGetSubroutineIndex(shader.program.program, GL_FRAGMENT_SHADER, subroutineName.ptr);
        }
        else if (shaderType == ShaderType.Compute)
        {
            location = glGetSubroutineUniformLocation(shader.program.program, GL_COMPUTE_SHADER, _name.ptr);
            if (subroutineName.length)
                index = glGetSubroutineIndex(shader.program.program, GL_COMPUTE_SHADER, subroutineName.ptr);
        }
    }
    
    /// Gets the subroutine index for a given name.
    GLuint getIndex(string subrName)
    {
        auto name = String(subrName);
        GLuint ind;
        if (shaderType == ShaderType.Vertex)
            ind = glGetSubroutineIndex(shader.program.program, GL_VERTEX_SHADER, name.ptr);
        else if (shaderType == ShaderType.Fragment)
            ind = glGetSubroutineIndex(shader.program.program, GL_FRAGMENT_SHADER, name.ptr);
        else if (shaderType == ShaderType.Compute)
            ind = glGetSubroutineIndex(shader.program.program, GL_COMPUTE_SHADER, name.ptr);
        name.free();
        return ind;
    }

    /// Binds the subroutine.
    override void bind()
    {
        if (shaderType == ShaderType.Vertex)
        {
            if (location != -1)
                shader.vertexSubroutineIndices[location] = index;
        }
        else if (shaderType == ShaderType.Fragment)
        {
            if (location != -1)
                shader.fragmentSubroutineIndices[location] = index;
        }
        else if (shaderType == ShaderType.Compute)
        {
            if (location != -1)
                shader.computeSubroutineIndices[location] = index;
        }
    }

    /// Unbinds the subroutine (no-op).
    override void unbind()
    {
    }
}

/**
 * Represents a shader uniform parameter of type `T`.
 * Supports binding values, references, or callbacks for automatic updates.
 */
class ShaderParameter(T): BaseShaderParameter
    if (is(T == bool) ||
        is(T == int) ||
        is(T == float) ||
        is(T == Vector2f) ||
        is(T == Vector3f) ||
        is(T == Vector4f) ||
        is(T == Color4f) ||
        is(T == Matrix4x4f) ||
        is(T == Matrix3x3f))
{
    /// Pointer to a source value for dynamic updates.
    T* source;

    /// Current value if not using a source reference.
    T value;

    /// Callback for dynamic updates.
    T delegate() callback;
    
    /// Creates a parameter with a default value.
    this(Shader shader, string name)
    {
        super(shader, name);
        this.source = null;
        this.value = T.init;
        this.callback = null;
        initUniform();
    }

    /// Creates a parameter bound to a reference.
    this(Shader shader, string name, T* source)
    {
        super(shader, name);
        this.source = source;
        this.callback = null;
        initUniform();
    }

    /// Creates a parameter with a specific value.
    this(Shader shader, string name, T value)
    {
        super(shader, name);
        this.source = null;
        this.value = value;
        this.callback = null;
        initUniform();
    }

    /// Creates a parameter with a callback for dynamic updates.
    this(Shader shader, string name, T delegate() callback)
    {
        super(shader, name);
        this.source = null;
        this.callback = callback;
        initUniform();
    }
    
    /// Sets the parameter value.
    void set(T v)
    {
        value = v;
        source = null;
    }
    
    /// Sets the parameter reference.
    void set(T* src)
    {
        source = src;
    }
    
    /// Assigns a value to the parameter.
    void opAssign(T v)
    {
        value = v;
        source = null;
    }
    
    /// Assigns a reference to the parameter.
    void opAssign(T* src)
    {
        source = src;
    }

    /// Initializes the uniform location.
    final override void initUniform()
    {
        location = glGetUniformLocation(shader.program.program, toStringz(name));
    }

    /// Binds the parameter value to the shader.
    override void bind()
    {
        if (callback)
            value = callback();
        else if (source)
            value = *source;

        static if (is(T == bool) || is(T == int))
        {
            glUniform1i(location, value);
        }
        else static if (is(T == float))
        {
            glUniform1f(location, value);
        }
        else static if (is(T == Vector2f))
        {
            glUniform2fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Vector3f))
        {
            glUniform3fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Vector4f))
        {
            glUniform4fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Color4f))
        {
            glUniform4fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Matrix4x4f))
        {
            glUniformMatrix4fv(location, 1, GL_FALSE, value.arrayof.ptr);
        }
        else static if (is(T == Matrix3x3f))
        {
            glUniformMatrix3fv(location, 1, GL_FALSE, value.arrayof.ptr);
        }
    }

    /// Unbinds the parameter (no-op).
    override void unbind()
    {
    }
}

/**
 * Represents a std140 uniform block parameter (UBO) of type `T`
 * for passing arrays of structures to shaders.
 */
class UniformBlockParameter(T): BaseShaderParameter if (isStd140Compliant!T)
{
    /// Parameter name.
    String _name;

    /// Array of data elements.
    T[] data;

    /// OpenGL uniform buffer object handle.
    GLuint uniformBuffer;

    /// Uniform block index in the program.
    GLuint index;

    /// Uniform block binding point.
    GLuint binding;
    
    /// Creates a uniform block parameter with the given name, array length and binding point.
    this(Shader shader, string name, uint length, uint binding)
    {
        super(shader, name);
        this._name = String(name);
        this.data = New!(T[])(length);
        this.binding = binding;
        initUniform();
    }
    
    /// Destructor. Frees all allocated resources.
    ~this()
    {
        glDeleteBuffers(1, &uniformBuffer);
        _name.free();
        Delete(data);
    }
    
    /// Initializes the UBO and assigns a binding point to the uniform block.
    final override void initUniform()
    {
        glGenBuffers(1, &uniformBuffer);
        glBindBuffer(GL_UNIFORM_BUFFER, uniformBuffer);
        glBufferData(GL_UNIFORM_BUFFER, T.sizeof * data.length, data.ptr, GL_STATIC_DRAW);
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
        
        index = glGetUniformBlockIndex(shader.program.program, _name.ptr);
        glUniformBlockBinding(shader.program.program, index, binding);
    }

    /// Binds the parameter value to the shader.
    override void bind()
    {
        glBindBuffer(GL_UNIFORM_BUFFER, uniformBuffer);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, T.sizeof * data.length, data.ptr);
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
        glBindBufferBase(GL_UNIFORM_BUFFER, binding, uniformBuffer);
    }

    /// Unbinds the parameter (no-op).
    override void unbind()
    {
    }
}

/**
 * Basic shader class.
 *
 * Description:
 * Manages a shader program, uniform and subroutine parameters, and provides
 * methods for parameter creation, binding, and validation.
 */
class Shader: Owner
{
    /// Shader program to use.
    BaseShaderProgram program;

    /// List of shader parameters.
    MappedList!BaseShaderParameter parameters;

    /// Array of vertex shader subroutine indices.
    GLuint[] vertexSubroutineIndices;

    /// Array of fragment shader subroutine indices.
    GLuint[] fragmentSubroutineIndices;

    /// Array of compute shader subroutine indices.
    GLuint[] computeSubroutineIndices;

    /// In debug mode, enables or disables shader validation on bind.
    bool validationEnabled = true;

    /// Constructs a shader from a program.
    this(BaseShaderProgram program, Owner owner)
    {
        super(owner);
        this.program = program;
        this.parameters = New!(MappedList!BaseShaderParameter)(this);
    }

    /// Loads shader source code from a file, supporting `#include` directives.
    static String load(string filename)
    {
        auto fs = globalVFS();
        
        if (!fs.exists(filename))
        {
            exitWithError("Error: shader \"" ~ filename ~ "\" not found!");
        }
        
        auto istrm = fs.openForInput(filename);
        string inputText = readText(istrm);
        Delete(istrm);

        string includePath = "data/__internal/shaders/include/";
        String outputText;
        foreach(line; lineSplitter(inputText))
        {
            auto s = line.strip;
            if (s.startsWith("#include"))
            {
                char[64] buf;
                if (sscanf(s.ptr, "#include <%s>", buf.ptr) == 1)
                {
                    string includeFilename = cast(string)buf[0..strlen(buf.ptr)-1];
                    String includeFullPath = includePath;
                    includeFullPath ~= includeFilename;
                    if (fs.exists(includeFullPath))
                    {
                        istrm = fs.openForInput(includeFullPath.toString);
                        string includeText = readText(istrm);
                        Delete(istrm);
                        outputText ~= includeText;
                        outputText ~= "\n";
                        Delete(includeText);
                    }
                    includeFullPath.free();
                }
                else
                {
                    logError("Illegal \"#include\" directive in shader ", filename);
                    break;
                }
            }
            else
            {
                outputText ~= line;
                outputText ~= "\n";
            }
        }

        Delete(inputText);

        return outputText;
    }

    /// Creates a subroutine parameter.
    ShaderSubroutine createParameterSubroutine(string name, ShaderType shaderType)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderSubroutine)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            sp.shaderType = shaderType;
            sp.initUniform();
            return sp;
        }
        else
        {
            auto sp = New!ShaderSubroutine(this, shaderType, name);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a subroutine parameter with a specific subroutine name.
    ShaderSubroutine setParameterSubroutine(string name, ShaderType shaderType, string subroutineName)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderSubroutine)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            sp.shaderType = shaderType;
            sp.subroutineName.free();
            sp.subroutineName = String(subroutineName);
            sp.initUniform();
            return sp;
        }
        else
        {
            auto sp = New!ShaderSubroutine(this, shaderType, name, subroutineName);
            parameters.set(name, sp);
            return sp;
        }
    }
    
    /// Creates a uniform parameter of type `T`.
    ShaderParameter!T createParameter(T)(string name)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Creates a uniform block parameter of type `T`.
    UniformBlockParameter!T createBlockParameter(T)(string name, uint length, uint location)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(UniformBlockParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            return sp;
        }
        else
        {
            auto sp = New!(UniformBlockParameter!T)(this, name, length, location);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a uniform parameter of type `T` to a value.
    ShaderParameter!T setParameter(T)(string name, T val)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }

            sp.value = val;
            sp.source = null;
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name, val);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a uniform parameter of type `T` to a reference.
    ShaderParameter!T setParameterRef(T)(string name, ref T val)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }

            sp.source = &val;
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name, &val);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a uniform parameter of type `T` to a callback.
    ShaderParameter!T setParameterCallback(T)(string name, T delegate() val)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }

            sp.callback = val;
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name, val);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Gets a parameter by name.
    BaseShaderParameter getParameter(string name)
    {
        if (name in parameters.indices)
        {
            return parameters.get(name);
        }
        else
        {
            logWarning("Unknown shader parameter \"%s\"", name);
            return null;
        }
    }

    /// Gets the value of a parameter by name.
    T getParameterValue(T)(string name)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return T.init;
            }

            if (sp.source)
                return *sp.source;
            else
                return sp.value;
        }
        else
        {
            logWarning("Unknown shader parameter \"%s\"", name);
            return T.init;
        }
    }

    /// Validates the program.
    void validate()
    {
        if (validationEnabled)
        {
            if (!program.validate())
                exitWithError("Shader program validation failed");
        }
    }

    /// Binds all parameters.
    void bindParameters(GraphicsState* state)
    {
        if (program.numVertexSubroutines > 0 && 
            vertexSubroutineIndices.length == 0)
            vertexSubroutineIndices = New!(GLuint[])(program.numVertexSubroutines);
        
        if (program.numFragmentSubroutines > 0 && 
            fragmentSubroutineIndices.length == 0)
            fragmentSubroutineIndices = New!(GLuint[])(program.numFragmentSubroutines);
        
        if (program.numComputeSubroutines > 0 && 
            computeSubroutineIndices.length == 0)
            computeSubroutineIndices = New!(GLuint[])(program.numComputeSubroutines);
        
        foreach(v; parameters.data)
        {
            if (v.autoBind)
                v.bind();
        }

        if (vertexSubroutineIndices.length)
            glUniformSubroutinesuiv(GL_VERTEX_SHADER, cast(uint)vertexSubroutineIndices.length, vertexSubroutineIndices.ptr);

        if (fragmentSubroutineIndices.length)
            glUniformSubroutinesuiv(GL_FRAGMENT_SHADER, cast(uint)fragmentSubroutineIndices.length, fragmentSubroutineIndices.ptr);
        
        if (computeSubroutineIndices.length)
            glUniformSubroutinesuiv(GL_FRAGMENT_SHADER, cast(uint)computeSubroutineIndices.length, computeSubroutineIndices.ptr);
        
        debug validate();
    }

    /// Unbinds all parameters.
    void unbindParameters(GraphicsState* state)
    {
        foreach(v; parameters.data)
        {
            if (v.autoBind)
                v.unbind();
        }
    }

    /// Binds the underlying shader program.
    void bind()
    {
        program.bind();
    }

    /// Unbinds the underlying shader program.
    void unbind()
    {
        program.unbind();
    }

    /// Destructor. Releases allocated resources.
    ~this()
    {
        if (vertexSubroutineIndices.length)
            Delete(vertexSubroutineIndices);
        if (fragmentSubroutineIndices.length)
            Delete(fragmentSubroutineIndices);
        if (computeSubroutineIndices.length)
            Delete(computeSubroutineIndices);
    }
}
