/*
Copyright (c) 2018-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides classes and utilities for OpenGL shader management.
 *
 * The `dagon.graphics.shader` module defines the `Shader` class for managing
 * OpenGL shader programs, uniform and subroutine parameters, and binding logic.
 * The module also includes `ShaderProgram` for program compilation/linking,
 * `BaseShaderParameter` and `ShaderParameter` for uniform management, and
 * `ShaderSubroutine` for subroutine selection.
 *
 * Copyright: Timur Gafarov 2018-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.shader;

import core.stdc.string;
import std.stdio;
import std.stdio;
import std.string;
import std.algorithm;
import std.file;
import std.traits;

import dlib.core.ownership;
import dlib.core.memory;
import dlib.container.array;
import dlib.container.dict;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.utils: min2;
import dlib.image.color;
import dlib.filesystem.stdfs;
import dlib.text.str;

import dagon.core.application;
import dagon.core.bindings;
import dagon.core.logger;
import dagon.graphics.shaderloader;
import dagon.graphics.texture;
import dagon.graphics.state;

bool isFieldsOffsetAligned(T, alias numBytes)()
{
    static if (is(T == struct))
    {
        static foreach(f; T.tupleof)
        {
            static if (f.offsetof % numBytes != 0)
                return false;
        }
        
        return true;
    }
    else return false;
}

alias isStd140Compliant(T) = isFieldsOffsetAligned!(T, 16);

// TODO: move to separate module
class MappedList(T): Owner
{
    Array!T data;
    Dict!(size_t, string) indices;

    this(Owner o)
    {
        super(o);
        indices = New!(Dict!(size_t, string))();
    }

    void set(string name, T val)
    {
        data.append(val);
        indices[name] = data.length - 1;
    }

    T get(string name)
    {
        return data[indices[name]];
    }

    ~this()
    {
        data.free();
        Delete(indices);
    }
}

/**
 * A shader program class that can be shared between multiple `Shader` instances.
 * Handles compilation and linking of vertex and fragment shaders, and manages OpenGL program objects.
 */
class ShaderProgram: Owner
{
    // TODO: cache program binary

    immutable GLuint program;
    GLsizei numVertexSubroutines;
    GLsizei numFragmentSubroutines;

    /// Compiles and links a shader program from source.
    this(string vertexShaderSrc, string fragmentShaderSrc, Owner owner)
    {
        super(owner);

        GLuint vert = compileShader(vertexShaderSrc, ShaderStage.vertex);
        GLuint frag = compileShader(fragmentShaderSrc, ShaderStage.fragment);
        if (vert != 0 && frag != 0)
        {
            program = linkShaders(vert, frag);
            
            glGetProgramStageiv(program,
                GL_VERTEX_SHADER,
                GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS,
                &numVertexSubroutines);
            
            glGetProgramStageiv(program,
                GL_FRAGMENT_SHADER,
                GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS,
                &numFragmentSubroutines);
            
            /*
            // Get the size of the binary
            GLint binarySize = 0;
            glGetProgramiv(program, GL_PROGRAM_BINARY_LENGTH, &binarySize);
            
            // Allocate buffer for the binary, as well as the binary format
            size_t bufferSize = GLenum.sizeof + binarySize;
            ubyte[] binary = New!(ubyte[])[bufferSize];
            
            // Get the binary from the driver, saving the format
            GLenum binaryFormat;
            glGetProgramBinary(program, binarySize, null, &binaryFormat, binary.ptr + GLenum.sizeof);
            *(cast(GLenum*)binary.ptr) = binaryFormat;
            
            // TODO: save the binary to file
            */
        }
    }

    /// Binds the shader program for use.
    void bind()
    {
        glUseProgram(program);
    }

    /// Unbinds the shader program.
    void unbind()
    {
        glUseProgram(0);
    }
}

/**
 * Abstract base class for shader parameters (uniforms and subroutines).
 * Stores parameter name, location, and binding logic.
 */
abstract class BaseShaderParameter: Owner
{
    Shader shader;
    string name;
    GLint location;
    bool autoBind = true;

    /// Initializes the uniform location.
    this(Shader shader, string name)
    {
        super(shader);
        this.shader = shader;
        this.name = name;
    }

    /// Initializes the uniform location.
    void initUniform();

    /// Binds the parameter value to the shader.
    void bind();

    /// Unbinds the parameter.
    void unbind();
}

enum ShaderType
{
    Vertex,
    Fragment
}

/**
 * Represents a shader subroutine parameter.
 * Allows selection of subroutine implementations for vertex or fragment shaders.
 */
class ShaderSubroutine: BaseShaderParameter
{
    ShaderType shaderType;
    GLint location;
    GLuint index;
    String _name;
    String subroutineName;

    /// Creates a subroutine parameter for the given shader and type.
    this(Shader shader, ShaderType shaderType, string name)
    {
        super(shader, name);
        this.shaderType = shaderType;
        this._name = String(name);
        initUniform();
    }

    /// Creates a subroutine parameter with a specific subroutine name.
    this(Shader shader, ShaderType shaderType, string name, string subroutineName)
    {
        super(shader, name);
        this.shaderType = shaderType;
        this._name = String(name);
        this.subroutineName = String(subroutineName);
        initUniform();
    }
    
    /// Destructor. Frees all allocated resources.
    ~this()
    {
        _name.free();
        subroutineName.free();
    }

    override void initUniform()
    {
        if (shaderType == ShaderType.Vertex)
        {
            location = glGetSubroutineUniformLocation(shader.program.program, GL_VERTEX_SHADER, _name.ptr);
            if (subroutineName.length)
                index = glGetSubroutineIndex(shader.program.program, GL_VERTEX_SHADER, subroutineName.ptr);
        }
        else if (shaderType == ShaderType.Fragment)
        {
            location = glGetSubroutineUniformLocation(shader.program.program, GL_FRAGMENT_SHADER, _name.ptr);
            if (subroutineName.length)
                index = glGetSubroutineIndex(shader.program.program, GL_FRAGMENT_SHADER, subroutineName.ptr);
        }
    }
    
    /// Gets the subroutine index for a given name.
    GLuint getIndex(string subrName)
    {
        auto name = String(subrName);
        GLuint index;
        if (shaderType == ShaderType.Vertex)
            index = glGetSubroutineIndex(shader.program.program, GL_VERTEX_SHADER, name.ptr);
        else if (shaderType == ShaderType.Fragment)
            index = glGetSubroutineIndex(shader.program.program, GL_FRAGMENT_SHADER, name.ptr);
        name.free();
        return index;
    }

    /// Binds the subroutine index.
    override void bind()
    {
        if (shaderType == ShaderType.Vertex)
        {
            if (location != -1)
                shader.vertexSubroutineIndices[location] = index;
        }
        else if (shaderType == ShaderType.Fragment)
        {
            if (location != -1)
                shader.fragmentSubroutineIndices[location] = index;
        }
    }

    /// Unbinds the subroutine (no-op).
    override void unbind()
    {
    }
}

/**
 * Represents a shader uniform parameter of type `T`.
 * Supports binding values, references, or callbacks for automatic updates.
 */
class ShaderParameter(T): BaseShaderParameter
    if (is(T == bool) ||
        is(T == int) ||
        is(T == float) ||
        is(T == Vector2f) ||
        is(T == Vector3f) ||
        is(T == Vector4f) ||
        is(T == Color4f) ||
        is(T == Matrix4x4f) ||
        is(T == Matrix3x3f))
{
    T* source;
    T value;
    T delegate() callback;
    
    /// Creates a parameter with a default value.
    this(Shader shader, string name)
    {
        super(shader, name);
        this.source = null;
        this.value = T.init;
        this.callback = null;
        initUniform();
    }

    /// Creates a parameter bound to a reference.
    this(Shader shader, string name, T* source)
    {
        super(shader, name);
        this.source = source;
        this.callback = null;
        initUniform();
    }

    /// Creates a parameter with a specific value.
    this(Shader shader, string name, T value)
    {
        super(shader, name);
        this.source = null;
        this.value = value;
        this.callback = null;
        initUniform();
    }

    /// Creates a parameter with a callback for dynamic updates.
    this(Shader shader, string name, T delegate() callback)
    {
        super(shader, name);
        this.source = null;
        this.callback = callback;
        initUniform();
    }
    
    /// Sets the parameter value.
    void set(T v)
    {
        value = v;
        source = null;
    }
    
    /// Sets the parameter reference.
    void set(T* src)
    {
        source = src;
    }
    
    /// Assigns a value to the parameter.
    void opAssign(T v)
    {
        value = v;
        source = null;
    }
    
    /// Assigns a reference to the parameter.
    void opAssign(T* src)
    {
        source = src;
    }

    /// Initializes the uniform location.
    override void initUniform()
    {
        location = glGetUniformLocation(shader.program.program, toStringz(name));
    }

    /// Binds the parameter value to the shader.
    override void bind()
    {
        if (callback)
            value = callback();
        else if (source)
            value = *source;

        static if (is(T == bool) || is(T == int))
        {
            glUniform1i(location, value);
        }
        else static if (is(T == float))
        {
            glUniform1f(location, value);
        }
        else static if (is(T == Vector2f))
        {
            glUniform2fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Vector3f))
        {
            glUniform3fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Vector4f))
        {
            glUniform4fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Color4f))
        {
            glUniform4fv(location, 1, value.arrayof.ptr);
        }
        else static if (is(T == Matrix4x4f))
        {
            glUniformMatrix4fv(location, 1, GL_FALSE, value.arrayof.ptr);
        }
        else static if (is(T == Matrix3x3f))
        {
            glUniformMatrix3fv(location, 1, GL_FALSE, value.arrayof.ptr);
        }
    }

    /// Unbinds the parameter (no-op).
    override void unbind()
    {
    }
}

class UniformBlockParameter(T): BaseShaderParameter if (isStd140Compliant!T)
{
    String _name;
    T[] data;
    GLuint uniformBuffer;
    GLuint index;
    GLuint binding;
    
    this(Shader shader, string name, uint length, uint binding)
    {
        super(shader, name);
        this._name = String(name);
        this.data = New!(T[])(length);
        this.binding = binding;
        initUniform();
    }
    
    ~this()
    {
        glDeleteBuffers(1, &uniformBuffer);
        _name.free();
        Delete(data);
    }
    
    override void initUniform()
    {
        glGenBuffers(1, &uniformBuffer);
        glBindBuffer(GL_UNIFORM_BUFFER, uniformBuffer);
        glBufferData(GL_UNIFORM_BUFFER, T.sizeof * data.length, data.ptr, GL_STATIC_DRAW);
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
        
        index = glGetUniformBlockIndex(shader.program.program, _name.ptr);
        glUniformBlockBinding(shader.program.program, index, binding);
    }

    override void bind()
    {
        glBindBuffer(GL_UNIFORM_BUFFER, uniformBuffer);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, T.sizeof * data.length, data.ptr);
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
        glBindBufferBase(GL_UNIFORM_BUFFER, binding, uniformBuffer);
    }

    override void unbind()
    {
        
    }
}

/**
 * Base shader class.
 *
 * Description:
 * Manages a shader program, uniform and subroutine parameters, and provides
 * methods for parameter creation, binding, and validation.
 */
class Shader: Owner
{
    ShaderProgram program;
    MappedList!BaseShaderParameter parameters;
    GLuint[] vertexSubroutineIndices;
    GLuint[] fragmentSubroutineIndices;

    /// Constructs a shader from a program.
    this(ShaderProgram program, Owner owner)
    {
        super(owner);
        this.program = program;
        this.parameters = New!(MappedList!BaseShaderParameter)(this);
    }

    /// Loads shader source code from a file, supporting `#include` directives.
    static String load(string filename)
    {
        if (!exists(filename))
        {
            exitWithError("Error: shader \"" ~ filename ~ "\" not found!");
        }
        
        // TODO: use Application.vfs instead creating own FS
        auto fs = New!StdFileSystem();
        auto istrm = fs.openForInput(filename);
        string inputText = readText(istrm);
        Delete(istrm);

        string includePath = "data/__internal/shaders/include/";
        String outputText;
        foreach(line; lineSplitter(inputText))
        {
            auto s = line.strip;
            if (s.startsWith("#include"))
            {
                char[64] buf;
                if (sscanf(s.ptr, "#include <%s>", buf.ptr) == 1)
                {
                    string includeFilename = cast(string)buf[0..strlen(buf.ptr)-1];
                    String includeFullPath = includePath;
                    includeFullPath ~= includeFilename;
                    if (exists(includeFullPath))
                    {
                        istrm = fs.openForInput(includeFullPath.toString);
                        string includeText = readText(istrm);
                        Delete(istrm);
                        outputText ~= includeText;
                        outputText ~= "\n";
                        Delete(includeText);
                    }
                    includeFullPath.free();
                }
                else
                {
                    logError("Illegal \"#include\" directive in shader ", filename);
                    break;
                }
            }
            else
            {
                outputText ~= line;
                outputText ~= "\n";
            }
        }

        Delete(fs);
        Delete(inputText);

        return outputText;
    }
    
    /// Creates a subroutine parameter.
    ShaderSubroutine createParameterSubroutine(string name, ShaderType shaderType)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderSubroutine)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            sp.shaderType = shaderType;
            sp.initUniform();
            return sp;
        }
        else
        {
            auto sp = New!ShaderSubroutine(this, shaderType, name);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a subroutine parameter with a specific subroutine name.
    ShaderSubroutine setParameterSubroutine(string name, ShaderType shaderType, string subroutineName)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderSubroutine)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            sp.shaderType = shaderType;
            sp.subroutineName.free();
            sp.subroutineName = String(subroutineName);
            sp.initUniform();
            return sp;
        }
        else
        {
            auto sp = New!ShaderSubroutine(this, shaderType, name, subroutineName);
            parameters.set(name, sp);
            return sp;
        }
    }
    
    /// Creates a uniform parameter of type `T`.
    ShaderParameter!T createParameter(T)(string name)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Creates a uniform block parameter of type `T`.
    UniformBlockParameter!T createBlockParameter(T)(string name, uint length, uint location)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(UniformBlockParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }
            return sp;
        }
        else
        {
            auto sp = New!(UniformBlockParameter!T)(this, name, length, location);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a uniform parameter of type `T` to a value.
    ShaderParameter!T setParameter(T)(string name, T val)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }

            sp.value = val;
            sp.source = null;
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name, val);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a uniform parameter of type `T` to a reference.
    ShaderParameter!T setParameterRef(T)(string name, ref T val)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }

            sp.source = &val;
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name, &val);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Sets a uniform parameter of type `T` to a callback.
    ShaderParameter!T setParameterCallback(T)(string name, T delegate() val)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return null;
            }

            sp.callback = val;
            return sp;
        }
        else
        {
            auto sp = New!(ShaderParameter!T)(this, name, val);
            parameters.set(name, sp);
            return sp;
        }
    }

    /// Gets a parameter by name.
    BaseShaderParameter getParameter(string name)
    {
        if (name in parameters.indices)
        {
            return parameters.get(name);
        }
        else
        {
            logWarning("Unknown shader parameter \"%s\"", name);
            return null;
        }
    }

    /// Gets the value of a parameter by name.
    T getParameterValue(T)(string name)
    {
        if (name in parameters.indices)
        {
            auto sp = cast(ShaderParameter!T)parameters.get(name);
            if (sp is null)
            {
                logWarning("Type mismatch for shader parameter \"%s\"", name);
                return T.init;
            }

            if (sp.source)
                return *sp.source;
            else
                return sp.value;
        }
        else
        {
            logWarning("Unknown shader parameter \"%s\"", name);
            return T.init;
        }
    }

    /// Binds the underlying shader program.
    void bind()
    {
        program.bind();
    }

    /// Unbinds the underlying shader program.
    void unbind()
    {
        program.unbind();
    }

    /// Binds all parameters and subroutines.
    void bindParameters(GraphicsState* state)
    {
        if (program.numVertexSubroutines > 0 && 
            vertexSubroutineIndices.length == 0)
            vertexSubroutineIndices = New!(GLuint[])(program.numVertexSubroutines);
        
        if (program.numFragmentSubroutines > 0 && 
            fragmentSubroutineIndices.length == 0)
            fragmentSubroutineIndices = New!(GLuint[])(program.numFragmentSubroutines);
        
        foreach(v; parameters.data)
        {
            if (v.autoBind)
                v.bind();
        }

        if (vertexSubroutineIndices.length)
            glUniformSubroutinesuiv(GL_VERTEX_SHADER, cast(uint)vertexSubroutineIndices.length, vertexSubroutineIndices.ptr);

        if (fragmentSubroutineIndices.length)
            glUniformSubroutinesuiv(GL_FRAGMENT_SHADER, cast(uint)fragmentSubroutineIndices.length, fragmentSubroutineIndices.ptr);
        
        debug validate();
    }

    /// Unbinds all parameters.
    void unbindParameters(GraphicsState* state)
    {
        foreach(v; parameters.data)
        {
            if (v.autoBind)
                v.unbind();
        }
    }

    /// Validates the shader program.
    void validate()
    {
        glValidateProgram(program.program);
        
        GLint status;
        glGetProgramiv(program.program, GL_VALIDATE_STATUS, &status);
        
        if (status != GL_TRUE)
        {
            GLint infolen;
            glGetProgramiv(program.program, GL_INFO_LOG_LENGTH, &infolen);
            if (infolen > 0)
            {
                char[logMaxLen + 1] infobuffer = 0;
                glGetProgramInfoLog(program.program, logMaxLen, null, infobuffer.ptr);
                infolen = min2(infolen - 1, logMaxLen);
                char[] s = stripRight(infobuffer[0..infolen]);
                logError(s);
            }
        }
        assert(status == GL_TRUE, "Shader program validation failed");
    }
    
    /// Destructor. Releases allocated resources.
    ~this()
    {
        if (vertexSubroutineIndices.length)
            Delete(vertexSubroutineIndices);
        if (fragmentSubroutineIndices.length)
            Delete(fragmentSubroutineIndices);
    }
}
