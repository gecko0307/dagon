/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides a texture class and corresponding utilities.
 *
 * Description:
 * The `dagon.graphics.texture` module defines the `Texture` class
 * for managing 1D, 2D, 3D, and cubemap textures, supporting compressed
 * and uncompressed formats, mipmapping, filtering, and OpenGL resource management.
 * The module also includes enums for texture formats, cube faces, and utility
 * functions for texture creation, loading, and conversion.
 *
 * Copyright: Timur Gafarov 2017-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.texture;

import std.stdio;
import std.math;
import std.algorithm;
import std.traits;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.container.array;
import dlib.image.image;
import dlib.image.color;
import dlib.image.hdri;
import dlib.image.unmanaged;
import dlib.math.utils;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.transformation;

import dagon.core.bindings;
import dagon.core.logger;

/**
 * Specifies the dimension of a texture.
 */
enum TextureDimension
{
    /// Unknown
    Undefined,

    /// 1-dimensional texture
    D1,

    /// 2-dimensional texture
    D2,

    /// 3-dimensional texture
    D3
}

/**
 * Represents the size of a texture in pixels.
 */
struct TextureSize
{
    /// Width
    uint width;

    /// Height
    uint height;

    /// Depth
    uint depth;
}

/**
 * The faces of a cubemap texture.
 */
enum CubeFace: GLenum
{
    /// Positive-X face (right)
    PositiveX = GL_TEXTURE_CUBE_MAP_POSITIVE_X,

    /// Negative-X face (left)
    NegativeX = GL_TEXTURE_CUBE_MAP_NEGATIVE_X,

    /// Positive-Y face (top)
    PositiveY = GL_TEXTURE_CUBE_MAP_POSITIVE_Y,

    /// Negative-Y face (bottom)
    NegativeY = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,

    /// Positive-Z face (front)
    PositiveZ = GL_TEXTURE_CUBE_MAP_POSITIVE_Z,

    /// Negative-Z face (back)
    NegativeZ = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
}

/**
 * Bitmask for cubemap faces.
 */
enum CubeFaceBit
{
    None = 0,
    PositiveX = 1,
    NegativeX = 2,
    PositiveY = 4,
    NegativeY = 8,
    PositiveZ = 16,
    NegativeZ = 32,
    All = 0xffffffff
}

/**
 * Returns a corresponding `CubeFaceBit` for a given `CubeFace`
 */
CubeFaceBit cubeFaceBit(CubeFace face)
{
    CubeFaceBit cfb = CubeFaceBit.None;
    switch(face)
    {
        case CubeFace.PositiveX: cfb = CubeFaceBit.PositiveX; break;
        case CubeFace.NegativeX: cfb = CubeFaceBit.NegativeX; break;
        case CubeFace.PositiveY: cfb = CubeFaceBit.PositiveY; break;
        case CubeFace.NegativeY: cfb = CubeFaceBit.NegativeY; break;
        case CubeFace.PositiveZ: cfb = CubeFaceBit.PositiveZ; break;
        case CubeFace.NegativeZ: cfb = CubeFaceBit.NegativeZ; break;
        default: break;
    }
    return cfb;
}

/**
 * Describes the format and layout of a texture.
 */
struct TextureFormat
{
    /// OpenGL texture target (GL_TEXTURE_2D, etc).
    GLenum target;
    
    /// OpenGL texture format (GL_RGBA, etc).
    GLenum format;
    
    /// OpenGL internal format (GL_RGBA8, etc).
    GLint internalFormat;
    
    /// OpenGL pixel type (GL_UNSIGNED_BYTE, etc).
    GLenum pixelType;
    
    /**
     * For compressed formats, this should be the size of a 4x4 pixel block in bytes.
     * For uncompressed formats, this should be zero.
     */
    uint blockSize;

    /// Bitwise combination of `CubeFaceBit` members.
    uint cubeFaces;
    
    /// Returns the number of channels.
    uint numChannels() const @property
    {
        if (format in numChannelsFormat)
            return numChannelsFormat[format];
        else
            return 0;
    }
    
    /// Returns the size of a single channel in bytes.
    uint channelSize() const @property
    {
        uint s = 0;
        switch(pixelType)
        {
            case GL_UNSIGNED_BYTE:  s = 1; break;
            case GL_BYTE:           s = 1; break;
            case GL_UNSIGNED_SHORT: s = 2; break;
            case GL_SHORT:          s = 2; break;
            case GL_UNSIGNED_INT:   s = 4; break;
            case GL_INT:            s = 4; break;
            case GL_HALF_FLOAT:     s = 2; break;
            case GL_FLOAT:          s = 4; break;
            default:                s = 0; break;
        }
        return s;
    }
    
    /// Returns the size of a pixel in bytes.
    uint pixelSize() const @property
    {
        return numChannels * channelSize;
    }
    
    /// Returns `true` if the format is compressed.
    bool isCompressed() const @property
    {
        return compressedFormats.canFind(internalFormat);
    }
    
    /// Returns `true` if the format is a cubemap.
    bool isCubemap() const @property
    {
        return cubeFaces != CubeFaceBit.None;
    }
    
    /// Returns the texture dimension.
    TextureDimension dimension() const @property
    {
        if (target == GL_TEXTURE_1D)
            return TextureDimension.D1;
        else if (target == GL_TEXTURE_2D)
            return TextureDimension.D2;
        else if (target == GL_TEXTURE_3D)
            return TextureDimension.D3;
        else
            return TextureDimension.Undefined;
    }
}

enum uint[GLenum] numChannelsFormat = [
    // Uncompressed formats
    GL_RED: 1,
    GL_RG: 2,
    GL_RGB: 3,
    GL_BGR: 3,
    GL_RGBA: 4,
    GL_BGRA: 4,
    GL_RED_INTEGER: 1,
    GL_RG_INTEGER: 2,
    GL_RGB_INTEGER: 3,
    GL_BGR_INTEGER: 3,
    GL_RGBA_INTEGER: 4,
    GL_BGRA_INTEGER: 4,
    GL_STENCIL_INDEX: 1,
    GL_DEPTH_COMPONENT: 1,
    GL_DEPTH_STENCIL: 1,
    
    // Compressed formats
    GL_COMPRESSED_RED: 1,
    GL_COMPRESSED_RG: 2,
    GL_COMPRESSED_RGB: 3,
    GL_COMPRESSED_RGBA: 4,
    GL_COMPRESSED_SRGB: 3,
    GL_COMPRESSED_SRGB_ALPHA: 4,
    GL_COMPRESSED_RED_RGTC1: 1,
    GL_COMPRESSED_SIGNED_RED_RGTC1: 1,
    GL_COMPRESSED_RG_RGTC2: 2,
    GL_COMPRESSED_SIGNED_RG_RGTC2: 2,
    GL_COMPRESSED_RGB_S3TC_DXT1_EXT: 3,
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT: 4,
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT: 4,
    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB: 4,
    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB: 3,
    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB: 3,
    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB: 3,
    GL_COMPRESSED_RGBA_ASTC_4x4_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_5x4_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_5x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_6x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_6x6_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_8x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_8x6_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_8x8_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x6_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x8_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x10_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_12x10_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_12x12_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 4
];

enum GLint[] compressedFormats = [
    GL_COMPRESSED_RED,
    GL_COMPRESSED_RG,
    GL_COMPRESSED_RGB,
    GL_COMPRESSED_RGBA,
    GL_COMPRESSED_SRGB,
    GL_COMPRESSED_SRGB_ALPHA,
    GL_COMPRESSED_RED_RGTC1,
    GL_COMPRESSED_SIGNED_RED_RGTC1,
    GL_COMPRESSED_RG_RGTC2,
    GL_COMPRESSED_SIGNED_RG_RGTC2,
    GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB,
    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB,
    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB,
    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB,
    GL_COMPRESSED_RGBA_ASTC_4x4_KHR,
    GL_COMPRESSED_RGBA_ASTC_5x4_KHR,
    GL_COMPRESSED_RGBA_ASTC_5x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_6x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_6x6_KHR,
    GL_COMPRESSED_RGBA_ASTC_8x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_8x6_KHR,
    GL_COMPRESSED_RGBA_ASTC_8x8_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x6_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x8_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x10_KHR,
    GL_COMPRESSED_RGBA_ASTC_12x10_KHR,
    GL_COMPRESSED_RGBA_ASTC_12x12_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
];

/**
 * Intermediate texture data storage.
 * Used to create textures loaded from container formats,
 * such as DDS and KTX, from custom formats, or directly
 * from memory.
 */
struct TextureBuffer
{
    /// Format of a texture data.
    TextureFormat format;

    /// Size of a texture data.
    TextureSize size;

    /// Number of mip levels.
    uint mipLevels;

    /// Raw texture data (can be compressed).
    ubyte[] data;
}

/**
 * Represents an OpenGL texture object.
 *
 * Description:
 * Supports 1D, 2D, 3D, and cubemap textures, compressed/uncompressed
 * formats, mipmaps, and filtering. Provides methods for creation from
 * dlib images, buffers, and equirectangular maps, as well as OpenGL
 * resource management.
 */
class Texture: Owner
{
    GLuint texture;
    TextureFormat format;
    TextureSize size;
    bool generateMipmaps;
    uint mipLevels;
    GLint minFilter = GL_LINEAR;
    GLint magFilter = GL_LINEAR;
    GLint wrapS = GL_REPEAT;
    GLint wrapT = GL_REPEAT;
    GLint wrapR = GL_REPEAT;
    bool useAnisotropicFiltering = false;
    float anisotropy = 0.0f;
    float maxAnisotropy = 0.0f; // This is usually set automatically from Application.maxTexture.Anisotropy
    
    /**
     * Constructs a new texture object.
     *
     * Params:
     *   owner = The owner object.
     */
    this(Owner owner)
    {
        super(owner);
    }
    
    /// Destructor. Releases OpenGL resources.
    ~this()
    {
        release();
    }
    
    /**
     * Creates a blank texture with the specified parameters and fill color.
     */
    void createBlank(uint w, uint h, uint channels, uint bitDepth, bool genMipmaps, Color4f fillColor = Color4f(0.0f, 0.0f, 0.0f, 1.0f))
    {
        release();
        
        SuperImage img = unmanagedImage(w, h, channels, bitDepth);
        
        foreach(y; 0..img.height)
        foreach(x; 0..img.width)
        {
            img[x, y] = fillColor;
        }
        
        createFromImage(img, genMipmaps);
        
        Delete(img);
    }
    
    /**
     * Creates a texture from a 2D image.
     */
    void createFromImage(SuperImage img, bool genMipmaps)
    {
        release();
        
        this.generateMipmaps = genMipmaps;
        
        if (detectTextureFormat(img, this.format))
        {
            this.size = TextureSize(img.width, img.height, 1);
            this.mipLevels = 1;
            createTexture2D(img.data);
        }
        else
        {
            logError("Unsupported image format ", img.pixelFormat);
            createFallbackTexture();
        }
    }
    
    /**
     * Creates a 3D texture from a 2D image using SuperImage as input
     */
    void createFromImage3D(SuperImage img, uint size = 0)
    {
        if (size == 0)
        {
            size = cast(uint)cbrt(img.width * img.height);
        }
        else
        {
            if (img.width != img.height || img.width * img.height != size * size * size)
            {
                uint s = cast(uint)sqrt(cast(real)size * size * size);
                logError("Wrong image resolution for 3D texture size ", size, ": should be ", s, "x", s);
                return;
            }
        }
        
        TextureFormat format;
        detectTextureFormat(img, format);
        TextureBuffer buff;
        buff.format = format;
        buff.format.target = GL_TEXTURE_3D;
        buff.size = TextureSize(size, size, size);
        buff.mipLevels = 1;
        buff.data = img.data;
        createFromBuffer(buff, false);
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
    }
    
    /**
     * Creates a 3D texture from a 2D image using TextureBuffer as input
     */
    void createFromBuffer3D(TextureBuffer buff, uint size = 0)
    {
        if (size == 0)
        {
            size = cast(uint)cbrt(buff.size.width * buff.size.height);
        }
        else
        {
            if (buff.size.width != buff.size.height || buff.size.width * buff.size.height != size * size * size)
            {
                uint s = cast(uint)sqrt(cast(real)size * size * size);
                logError("Wrong image resolution for 3D texture size ", size, ": should be ", s, "x", s);
                return;
            }
        }
        
        TextureBuffer buff3d;
        buff3d.format = buff.format;
        buff3d.format.target = GL_TEXTURE_3D;
        buff3d.size = TextureSize(size, size, size);
        buff3d.mipLevels = 1;
        buff3d.data = buff.data;
        createFromBuffer(buff3d, false);
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
    }
    
    /**
     * Creates a texture from a buffer.
     */
    void createFromBuffer(TextureBuffer buff, bool genMipmaps)
    {
        release();
        
        this.generateMipmaps = genMipmaps;
        
        this.format = buff.format;
        this.size = buff.size;
        this.mipLevels = buff.mipLevels;
        
        if (isCubemap)
            createCubemap(buff.data);
        else if (format.target == GL_TEXTURE_1D)
            createTexture1D(buff.data);
        else if (format.target == GL_TEXTURE_2D)
            createTexture2D(buff.data);
        else if (format.target == GL_TEXTURE_3D)
            createTexture3D(buff.data);
        else
            logError("Texture creation failed: unsupported target ", format.target);
    }
    
    void createBlankCubemap(TextureFormat format, uint resolution)
    {
        release();
        
        this.generateMipmaps = false;
        this.format = format;
        this.size = TextureSize(resolution, resolution, 1);
        this.mipLevels = 1;
        
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
        
        uint pSize = pixelSize;
        uint faceDataSize = resolution * resolution * pSize;
        ubyte[] faceData = New!(ubyte[])(faceDataSize);
        
        foreach(cubeFace; EnumMembers!CubeFace)
        {
            glTexImage2D(cubeFace, 0, format.internalFormat, resolution, resolution, 0, format.format, format.pixelType, cast(void*)(faceData.ptr));
        }
        
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
        
        Delete(faceData);
    }
    
    /**
     * Creates a cubemap texture from a buffer.
     */
    protected void createCubemap(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
        
        if (isCompressed)
        {
            if (mipLevels > 1)
            {
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
            }
            
            uint offset = 0;
            
            foreach(cubeFace; EnumMembers!CubeFace)
            {
                uint w = size.width;
                uint h = size.height;
                
                if (mipLevels == 1)
                {
                    uint imageSize = ((w + 3) / 4) * ((h + 3) / 4) * format.blockSize;
                    glCompressedTexImage2D(cubeFace, 0, format.internalFormat, w, h, 0, imageSize, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                }
                else
                {
                    for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                    {
                        uint imageSize = ((w + 3) / 4) * ((h + 3) / 4) * format.blockSize;
                        glCompressedTexImage2D(cubeFace, mipLevel, format.internalFormat, w, h, 0, imageSize, cast(void*)(buffer.ptr + offset));
                        offset += imageSize;
                        w /= 2;
                        h /= 2;
                        if (offset > buffer.length)
                        {
                            logError("Incomplete texture buffer");
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            if (mipLevels > 1)
            {
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
            }
            
            uint pSize = pixelSize;
            uint offset = 0;
            
            foreach(cubeFace; EnumMembers!CubeFace)
            {
                uint w = size.width;
                uint h = size.height;
                
                if (mipLevels == 1)
                {
                    uint imageSize = w * h * pSize;
                    glTexImage2D(cubeFace, 0, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                }
                else
                {
                    for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                    {
                        uint alignedSize = ((w * pSize + 3) & ~3) * h;
                        glTexImage2D(cubeFace, mipLevel, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                        offset += alignedSize;
                        w /= 2;
                        h /= 2;
                        if (offset > buffer.length)
                        {
                            logError("Incomplete texture buffer");
                            break;
                        }
                    }
                }
            }
            
            if (mipLevels == 1 && generateMipmaps)
            {
                glGenerateMipmap(GL_TEXTURE_2D);
                mipLevels = 1 + cast(uint)floor(log2(cast(double)max(size.width, size.height)));
            }
        }
        
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
        
        if (mipLevels > 1)
        {
            minFilter = GL_LINEAR_MIPMAP_LINEAR;
            magFilter = GL_LINEAR;
        }
        else
        {
            minFilter = GL_LINEAR;
            magFilter = GL_LINEAR;
        }
    }
    
    /**
     * Creates an 1D texture from a buffer.
     */
    protected void createTexture1D(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_1D, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_REPEAT;
        wrapT = GL_REPEAT;
        wrapR = GL_REPEAT;
        
        uint w = size.width;
        
        if (isCompressed)
        {
            if (mipLevels == 1)
            {
                glCompressedTexImage1D(GL_TEXTURE_1D, 0, format.internalFormat, w, 0, cast(uint)buffer.length, cast(void*)buffer.ptr);
            }
            else
            {
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint offset = 0;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint imageSize = ((w + 3) / 4) * format.blockSize;
                    
                    glCompressedTexImage1D(GL_TEXTURE_1D, mipLevel, format.internalFormat, w, 0, imageSize, cast(void*)(buffer.ptr + offset));
                    
                    offset += imageSize;
                    w /= 2;
                }
            }
        }
        else
        {
            if (mipLevels == 1)
            {
                glTexImage1D(GL_TEXTURE_1D, 0, format.internalFormat, w, 0, format.format, format.pixelType, cast(void*)buffer.ptr);
                
                if (generateMipmaps)
                {
                    glGenerateMipmap(GL_TEXTURE_1D);
                    mipLevels = 1 + cast(uint)floor(log2(cast(double)w));
                }
                else
                    mipLevels = 1;
            }
        }
    }
    
    /**
     * Creates a 2D texture from a buffer.
     */
    protected void createTexture2D(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_REPEAT;
        wrapT = GL_REPEAT;
        wrapR = GL_REPEAT;
        
        uint w = size.width;
        uint h = size.height;
        
        if (isCompressed)
        {
            if (mipLevels == 1)
            {
                glCompressedTexImage2D(GL_TEXTURE_2D, 0, format.internalFormat, w, h, 0, cast(uint)buffer.length, cast(void*)buffer.ptr);
            }
            else
            {
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint offset = 0;
                
                const uint blockWidth = 4;
                const uint blockHeight = 4;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint imageSize = ((w + blockWidth - 1) / blockWidth) * ((h + blockHeight - 1) / blockHeight) * format.blockSize;
                    glCompressedTexImage2D(GL_TEXTURE_2D, mipLevel, format.internalFormat, w, h, 0, imageSize, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                    w /= 2;
                    h /= 2;
                    if (offset > buffer.length)
                    {
                        logError("Incomplete texture buffer");
                        break;
                    }
                }
            }
        }
        else
        {
            if (mipLevels == 1)
            {
                glTexImage2D(GL_TEXTURE_2D, 0, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)buffer.ptr);
                
                if (generateMipmaps)
                {
                    glGenerateMipmap(GL_TEXTURE_2D);
                    mipLevels = 1 + cast(uint)floor(log2(cast(double)max(w, h)));
                }
                else
                    mipLevels = 1;
            }
            else if (channelSize > 0)
            {
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint pSize = pixelSize;
                uint offset = 0;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint alignedSize = ((w * pSize + 3) & ~3) * h;
                    glTexImage2D(GL_TEXTURE_2D, mipLevel, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                    offset += alignedSize;
                    w /= 2;
                    h /= 2;
                    if (offset > buffer.length)
                    {
                        logError("Incomplete texture buffer");
                        break;
                    }
                }
            }
        }
        
        if (mipLevels > 1)
        {
            minFilter = GL_LINEAR_MIPMAP_LINEAR;
            magFilter = GL_LINEAR;
        }
        else
        {
            minFilter = GL_LINEAR;
            magFilter = GL_LINEAR;
        }
    }
    
    /**
     * Creates a 3D texture from a buffer.
     */
    protected void createTexture3D(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_3D, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_REPEAT;
        wrapT = GL_REPEAT;
        wrapR = GL_REPEAT;
        
        uint w = size.width;
        uint h = size.height;
        uint d = size.depth;
        
        if (isCompressed)
        {
            logError("Compressed 3D textures are not supported");
        }
        else
        {
            if (mipLevels == 1)
            {
                glTexImage3D(GL_TEXTURE_3D, 0, format.internalFormat, w, h, d, 0, format.format, format.pixelType, cast(void*)buffer.ptr);
                
                if (generateMipmaps)
                {
                    glGenerateMipmap(GL_TEXTURE_3D);
                    mipLevels = 1 + cast(uint)floor(log2(cast(double)max3(w, h, d)));
                }
                else
                    mipLevels = 1;
            }
            else if (channelSize > 0)
            {
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint pSize = pixelSize;
                uint offset = 0;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint rowSize = (w * pSize + 3) & ~3;
                    uint sliceSize = rowSize * h;
                    uint imageSize = sliceSize * d;
                    glTexImage3D(GL_TEXTURE_3D, mipLevel, format.internalFormat, w, h, d, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                    w /= 2;
                    h /= 2;
                    d /= 2;
                    if (offset > buffer.length)
                    {
                        logError("Incomplete texture buffer");
                        break;
                    }
                }
            }
        }
    }
    
    /**
     * Creates a cubemap texture from an equirectangular environment map on the CPU side.
     * Warning: this is slow! Use the GPU-accelerated generator (generateCubemap from dagon.graphics.texproc) if you do this regularly and don't cache the resulting cubemap.
     */
    void createFromEquirectangularMap(SuperImage envmap, uint resolution, bool generateMipmaps = true)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
        
        TextureFormat tf;
        if (detectTextureFormat(envmap, tf))
        {
            format.cubeFaces = CubeFaceBit.All;
            SuperImage faceImage = envmap.createSameFormat(resolution, resolution);
            
            foreach(i, face; EnumMembers!CubeFace)
            {
                Matrix4x4f dirTransform = cubeFaceMatrix(face);
                
                foreach(x; 0..resolution)
                foreach(y; 0..resolution)
                {
                    float cubex = (cast(float)x / cast(float)resolution) * 2.0f - 1.0f;
                    float cubey = (1.0f - cast(float)y / cast(float)resolution) * 2.0f - 1.0f;
                    Vector3f dir = Vector3f(cubex, cubey, 1.0f).normalized * dirTransform;
                    Vector2f uv = equirectProj(dir);
                    Color4f c = bilinearPixel(envmap, uv.x * envmap.width, uv.y * envmap.height);
                    faceImage[x, y] = c;
                }
                
                glTexImage2D(face, 0, tf.internalFormat, resolution, resolution, 0, tf.format, tf.pixelType, cast(void*)faceImage.data.ptr);
            }
            
            Delete(faceImage);
            
            if (generateMipmaps)
            {
                glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
                mipLevels = 1 + cast(uint)floor(log2(cast(double)resolution));
            }
            else
                mipLevels = 1;
        }
        else
        {
            logError("Unsupported pixel format %s", envmap.pixelFormat);
        }
        
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
    }
    
    /// Generates mipmaps for the texture.
    void generateMipmap()
    {
        if (valid)
        {
            bind();
            glGenerateMipmap(format.target);
            mipLevels = 1 + cast(uint)floor(log2(cast(double)max(size.width, size.height)));
            unbind();
            useMipmapFiltering(true);
        }
    }
    
    /// Generate a default texture; unimplemented
    void createFallbackTexture()
    {
        // TODO
    }
    
    /// Releases OpenGL resources.
    void release()
    {
        if (valid)
            glDeleteTextures(1, &texture);
    }
    
    /// Returns true if the texture is valid.
    bool valid()
    {
        return cast(bool)glIsTexture(texture);
    }
    
    /// Binds the texture to the current OpenGL texture unit.
    void bind()
    {
        if (valid)
        {
            if (isCubemap)
            {
                glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, wrapR);
                if (useAnisotropicFiltering)
                    glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
            }
            else if (dimension == TextureDimension.D1)
            {
                glBindTexture(GL_TEXTURE_1D, texture);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_R, wrapR);
            }
            else if (dimension == TextureDimension.D2)
            {
                glBindTexture(GL_TEXTURE_2D, texture);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, wrapR);
                if (useAnisotropicFiltering)
                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
            }
            else if (dimension == TextureDimension.D3)
            {
                glBindTexture(GL_TEXTURE_3D, texture);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, wrapR);
            }
        }
    }

    /// Unbinds the texture.
    void unbind()
    {
        if (isCubemap)
            glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
        else if (dimension == TextureDimension.D1)
            glBindTexture(GL_TEXTURE_1D, 0);
        else if (dimension == TextureDimension.D2)
            glBindTexture(GL_TEXTURE_2D, 0);
        else if (dimension == TextureDimension.D3)
            glBindTexture(GL_TEXTURE_3D, 0);
        if (useAnisotropicFiltering)
            glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 0.0f);
    }
    
    /// Returns the width of the texture.
    uint width() const @property
    {
        return size.width;
    }
    
    /// Returns the height of the texture.
    uint height() const @property
    {
        return size.height;
    }
    
    /// Returns the number of channels.
    uint numChannels() const @property
    {
        return format.numChannels;
    }
    
    /// Returns true if the texture has an alpha channel.
    bool hasAlpha() const @property
    {
        return (numChannels == 4);
    }
    
    /// Returns true if the texture is compressed.
    bool isCompressed() const @property
    {
        return format.isCompressed;
    }
    
    /// Returns true if the texture is a cubemap.
    bool isCubemap() const @property
    {
        return format.isCubemap;
    }
    
    /// Returns the texture dimension.
    TextureDimension dimension() const @property
    {
        return format.dimension;
    }
    
    /// Returns the size of a channel in bytes.
    uint channelSize() const @property
    {
        return format.channelSize;
    }
    
    /// Returns the size of a pixel in bytes.
    uint pixelSize() const @property
    {
        return format.pixelSize;
    }
    
    /// Returns `true` if mipmap filtering is enabled.
    bool useMipmapFiltering() const @property
    {
        return minFilter == GL_LINEAR_MIPMAP_LINEAR;
    }
    
    /// Switches mipmap filtering.
    void useMipmapFiltering(bool mode) @property
    {
        if (mode)
            minFilter = GL_LINEAR_MIPMAP_LINEAR;
        else
            minFilter = GL_LINEAR;
    }
    
    /// Enables or disables texture repeat on UV wrap.
    void enableRepeat(bool mode) @property
    {
        if (mode)
        {
            wrapS = GL_REPEAT;
            wrapT = GL_REPEAT;
            wrapR = GL_REPEAT;
        }
        else
        {
            wrapS = GL_CLAMP_TO_EDGE;
            wrapT = GL_CLAMP_TO_EDGE;
            wrapR = GL_CLAMP_TO_EDGE;
        }
    }
    
    /// Sets the bitmask for a cubemap face.
    void setFaceBit(CubeFace face)
    {
        format.cubeFaces = format.cubeFaces | cubeFaceBit(face);
    }
    
    /// Sets the image for a cubemap face.
    void setFaceImage(CubeFace face, SuperImage img)
    {
        if (img.width != img.height)
        {
            logError("Cubemap face image must be square");
            return;
        }
        
        TextureFormat tf;
        if (!detectTextureFormat(img, tf))
        {
            logError("Unsupported image format ", img.pixelFormat);
            return;
        }
        
        if (!valid)
        {
            format.target = GL_TEXTURE_CUBE_MAP;
            
            // TODO: store individual size and format for each face
            
            size.width = img.width;
            size.height = img.height;
            
            format.format = tf.format;
            format.internalFormat = tf.internalFormat;
            format.pixelType = tf.pixelType;
            format.blockSize = tf.blockSize;
            
            glGenTextures(1, &texture);
            
            minFilter = GL_LINEAR;
            magFilter = GL_LINEAR;
            wrapS = GL_CLAMP_TO_EDGE;
            wrapT = GL_CLAMP_TO_EDGE;
            wrapR = GL_CLAMP_TO_EDGE;
        }
        
        setFaceBit(face);
        
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        if (isCompressed)
        {
            uint dataSize = ((img.width + 3) / 4) * ((img.height + 3) / 4) * tf.blockSize;
            glCompressedTexImage2D(face, 0, tf.internalFormat, img.width, img.height, 0, dataSize, cast(void*)img.data.ptr);
        }
        else
        {
            glTexImage2D(face, 0, tf.internalFormat, img.width, img.height, 0, tf.format, tf.pixelType, cast(void*)img.data.ptr);
        }
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
    }
}

/**
 * Detects the supported texture format from a `SuperImage`.
 *
 * Params:
 *   img = The image to analyze.
 *   tf  = Output texture format.
 * Returns:
 *   true if the format was detected successfully.
 */
bool detectTextureFormat(SuperImage img, out TextureFormat tf)
{
    uint pixelFormat = img.pixelFormat;
    switch(pixelFormat)
    {
        case IntegerPixelFormat.L8:    tf.internalFormat = GL_R8;      tf.format = GL_RED;  tf.pixelType = GL_UNSIGNED_BYTE; break;
        case IntegerPixelFormat.LA8:   tf.internalFormat = GL_RG8;     tf.format = GL_RG;   tf.pixelType = GL_UNSIGNED_BYTE; break;
        case IntegerPixelFormat.RGB8:  tf.internalFormat = GL_RGB8;    tf.format = GL_RGB;  tf.pixelType = GL_UNSIGNED_BYTE; break;
        case IntegerPixelFormat.RGBA8: tf.internalFormat = GL_RGBA8;   tf.format = GL_RGBA; tf.pixelType = GL_UNSIGNED_BYTE; break;
        case FloatPixelFormat.RGBAF32: tf.internalFormat = GL_RGBA32F; tf.format = GL_RGBA; tf.pixelType = GL_FLOAT; break;
        default:
            return false;
    }
    
    tf.target = GL_TEXTURE_2D;
    tf.blockSize = 0;
    tf.cubeFaces = CubeFaceBit.None;
    
    return true;
}

/**
 * Returns the transformation matrix for a cubemap face.
 *
 * Params:
 *   cf = The cubemap face.
 * Returns:
 *   The transformation matrix.
 */
Matrix4x4f cubeFaceMatrix(CubeFace cf)
{
    switch(cf)
    {
        case CubeFace.PositiveX:
            return rotationMatrix(1, degtorad(-90.0f));
        case CubeFace.NegativeX:
            return rotationMatrix(1, degtorad(90.0f));
        case CubeFace.PositiveY:
            return rotationMatrix(0, degtorad(90.0f));
        case CubeFace.NegativeY:
            return rotationMatrix(0, degtorad(-90.0f));
        case CubeFace.PositiveZ:
            return rotationMatrix(1, degtorad(0.0f));
        case CubeFace.NegativeZ:
            return rotationMatrix(1, degtorad(180.0f));
        default:
            return Matrix4x4f.identity;
    }
}

/**
 * Returns the world space transformation matrix for a cubemap face at a given position.
 *
 * Params:
 *   cf  = The cubemap face.
 *   pos = The camera position in world space.
 * Returns:
 *   The camera matrix.
 */
Matrix4x4f cubeFaceCameraMatrix(CubeFace cf, Vector3f pos)
{
    Matrix4x4f m;
    switch(cf)
    {
        case CubeFace.PositiveX:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(90.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        case CubeFace.NegativeX:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(-90.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        case CubeFace.PositiveY:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(0.0f)) * rotationMatrix(0, degtorad(-90.0f));
            break;
        case CubeFace.NegativeY:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(0.0f)) * rotationMatrix(0, degtorad(90.0f));
            break;
        case CubeFace.PositiveZ:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(180.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        case CubeFace.NegativeZ:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(0.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        default:
            m = Matrix4x4f.identity; break;
    }
    return m;
}

/**
 * Projects a 3D direction vector to equirectangular UV coordinates.
 *
 * Params:
 *   dir = The direction vector.
 * Returns:
 *   The UV coordinates in [0,1] range.
 */
Vector2f equirectProj(Vector3f dir)
{
    float phi = acos(dir.y);
    float theta = atan2(dir.x, dir.z) + PI;
    return Vector2f(theta / (PI * 2.0f), phi / PI);
}
