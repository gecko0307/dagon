/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides a texture class and corresponding utilities.
 *
 * Description:
 * The `dagon.graphics.texture` module defines the `Texture` class
 * for managing 1D, 2D, 3D, and cube map textures, supporting compressed
 * and uncompressed formats, mipmapping, filtering, and OpenGL resource management.
 * The module also includes utility functions for texture format conversion.
 *
 * Copyright: Timur Gafarov 2017-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.texture;

import std.stdio;
import std.math;
import std.algorithm;
import std.traits;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.container.array;
import dlib.image.image;
import dlib.image.color;
import dlib.image.hdri;
import dlib.image.unmanaged;
import dlib.math.utils;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.transformation;

import dagon.core.bindings;
import dagon.core.dxgiformat;
import dagon.core.vkformat;
import dagon.core.logger;

/**
 * Specifies the dimension of a texture.
 */
enum TextureDimension
{
    /// Unknown
    Undefined,

    /// 1-dimensional texture
    D1,

    /// 2-dimensional texture
    D2,

    /// 3-dimensional texture
    D3
}

/**
 * Represents the size of a texture in pixels.
 */
struct TextureSize
{
    /// Width
    uint width;

    /// Height
    uint height;

    /// Depth
    uint depth;
}

/**
 * The faces of a cube map texture.
 */
enum CubeFace: GLenum
{
    /// Positive-X face (right)
    PositiveX = GL_TEXTURE_CUBE_MAP_POSITIVE_X,

    /// Negative-X face (left)
    NegativeX = GL_TEXTURE_CUBE_MAP_NEGATIVE_X,

    /// Positive-Y face (top)
    PositiveY = GL_TEXTURE_CUBE_MAP_POSITIVE_Y,

    /// Negative-Y face (bottom)
    NegativeY = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,

    /// Positive-Z face (front)
    PositiveZ = GL_TEXTURE_CUBE_MAP_POSITIVE_Z,

    /// Negative-Z face (back)
    NegativeZ = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
}

/**
 * Bitmask for cube map faces.
 */
enum CubeFaceBit
{
    None = 0,
    PositiveX = 1,
    NegativeX = 2,
    PositiveY = 4,
    NegativeY = 8,
    PositiveZ = 16,
    NegativeZ = 32,
    All = 0xffffffff
}

/**
 * Returns a corresponding `CubeFaceBit` for a given `CubeFace`
 */
CubeFaceBit cubeFaceBit(CubeFace face)
{
    CubeFaceBit cfb = CubeFaceBit.None;
    switch(face)
    {
        case CubeFace.PositiveX: cfb = CubeFaceBit.PositiveX; break;
        case CubeFace.NegativeX: cfb = CubeFaceBit.NegativeX; break;
        case CubeFace.PositiveY: cfb = CubeFaceBit.PositiveY; break;
        case CubeFace.NegativeY: cfb = CubeFaceBit.NegativeY; break;
        case CubeFace.PositiveZ: cfb = CubeFaceBit.PositiveZ; break;
        case CubeFace.NegativeZ: cfb = CubeFaceBit.NegativeZ; break;
        default: break;
    }
    return cfb;
}

/**
 * Describes the format and layout of a texture.
 */
struct TextureFormat
{
    /// OpenGL texture target (GL_TEXTURE_2D, etc).
    GLenum target;
    
    /// OpenGL texture format (GL_RGBA, etc).
    GLenum format;
    
    /// OpenGL internal format (GL_RGBA8, etc).
    GLint internalFormat;
    
    /// OpenGL pixel type (GL_UNSIGNED_BYTE, etc).
    GLenum pixelType;
    
    /**
     * For compressed formats, this should be the size of a 4x4 pixel block in bytes.
     * For uncompressed formats, this should be zero.
     */
    uint blockSize;

    /// Bitwise combination of `CubeFaceBit` members.
    uint cubeFaces;
    
    /// Returns the number of channels.
    uint numChannels() const @property
    {
        if (format in numChannelsFormat)
            return numChannelsFormat[format];
        else
            return 0;
    }
    
    /// Returns the size of a single channel in bytes.
    uint channelSize() const @property
    {
        uint s = 0;
        switch(pixelType)
        {
            case GL_UNSIGNED_BYTE:  s = 1; break;
            case GL_BYTE:           s = 1; break;
            case GL_UNSIGNED_SHORT: s = 2; break;
            case GL_SHORT:          s = 2; break;
            case GL_UNSIGNED_INT:   s = 4; break;
            case GL_INT:            s = 4; break;
            case GL_HALF_FLOAT:     s = 2; break;
            case GL_FLOAT:          s = 4; break;
            default:                s = 0; break;
        }
        return s;
    }
    
    /// Returns the size of a pixel in bytes.
    uint pixelSize() const @property
    {
        return numChannels * channelSize;
    }
    
    /// Returns `true` if the format is compressed.
    bool isCompressed() const @property
    {
        return compressedFormats.canFind(internalFormat);
    }
    
    /// Returns `true` if the format is a cube map.
    bool isCubemap() const @property
    {
        return cubeFaces != CubeFaceBit.None;
    }
    
    /// Returns the texture dimension.
    TextureDimension dimension() const @property
    {
        if (target == GL_TEXTURE_1D)
            return TextureDimension.D1;
        else if (target == GL_TEXTURE_2D)
            return TextureDimension.D2;
        else if (target == GL_TEXTURE_3D)
            return TextureDimension.D3;
        else
            return TextureDimension.Undefined;
    }
}

enum uint[GLenum] numChannelsFormat = [
    // Uncompressed formats
    GL_RED: 1,
    GL_RG: 2,
    GL_RGB: 3,
    GL_BGR: 3,
    GL_RGBA: 4,
    GL_BGRA: 4,
    GL_RED_INTEGER: 1,
    GL_RG_INTEGER: 2,
    GL_RGB_INTEGER: 3,
    GL_BGR_INTEGER: 3,
    GL_RGBA_INTEGER: 4,
    GL_BGRA_INTEGER: 4,
    GL_STENCIL_INDEX: 1,
    GL_DEPTH_COMPONENT: 1,
    GL_DEPTH_STENCIL: 1,
    
    // Compressed formats
    GL_COMPRESSED_RED: 1,
    GL_COMPRESSED_RG: 2,
    GL_COMPRESSED_RGB: 3,
    GL_COMPRESSED_RGBA: 4,
    GL_COMPRESSED_SRGB: 3,
    GL_COMPRESSED_SRGB_ALPHA: 4,
    GL_COMPRESSED_RED_RGTC1: 1,
    GL_COMPRESSED_SIGNED_RED_RGTC1: 1,
    GL_COMPRESSED_RG_RGTC2: 2,
    GL_COMPRESSED_SIGNED_RG_RGTC2: 2,
    GL_COMPRESSED_RGB_S3TC_DXT1_EXT: 3,
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT: 4,
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT: 4,
    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB: 4,
    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB: 3,
    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB: 3,
    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB: 3,
    GL_COMPRESSED_RGBA_ASTC_4x4_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_5x4_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_5x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_6x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_6x6_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_8x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_8x6_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_8x8_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x5_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x6_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x8_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_10x10_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_12x10_KHR: 4,
    GL_COMPRESSED_RGBA_ASTC_12x12_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 4
];

enum GLint[] compressedFormats = [
    GL_COMPRESSED_RED,
    GL_COMPRESSED_RG,
    GL_COMPRESSED_RGB,
    GL_COMPRESSED_RGBA,
    GL_COMPRESSED_SRGB,
    GL_COMPRESSED_SRGB_ALPHA,
    GL_COMPRESSED_RED_RGTC1,
    GL_COMPRESSED_SIGNED_RED_RGTC1,
    GL_COMPRESSED_RG_RGTC2,
    GL_COMPRESSED_SIGNED_RG_RGTC2,
    GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB,
    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB,
    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB,
    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB,
    GL_COMPRESSED_RGBA_ASTC_4x4_KHR,
    GL_COMPRESSED_RGBA_ASTC_5x4_KHR,
    GL_COMPRESSED_RGBA_ASTC_5x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_6x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_6x6_KHR,
    GL_COMPRESSED_RGBA_ASTC_8x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_8x6_KHR,
    GL_COMPRESSED_RGBA_ASTC_8x8_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x5_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x6_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x8_KHR,
    GL_COMPRESSED_RGBA_ASTC_10x10_KHR,
    GL_COMPRESSED_RGBA_ASTC_12x10_KHR,
    GL_COMPRESSED_RGBA_ASTC_12x12_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
];

/**
 * Intermediate texture data storage.
 * Used to create textures loaded from container formats,
 * such as DDS and KTX, from custom formats, or directly
 * from memory.
 */
struct TextureBuffer
{
    /// Format of a texture data.
    TextureFormat format;

    /// Size of a texture data.
    TextureSize size;

    /// Number of mip levels.
    uint mipLevels;

    /// Raw texture data (can be compressed).
    ubyte[] data;
}

/**
 * Represents an OpenGL texture object.
 *
 * Description:
 * Supports 1D, 2D, 3D, and cubemap textures, compressed/uncompressed
 * formats, mipmaps, and filtering. Provides methods for creation from
 * dlib images and buffers, as well as OpenGL resource management.
 */
class Texture: Owner
{
    GLuint texture;
    TextureFormat format;
    TextureSize size;
    bool generateMipmaps;
    uint mipLevels;
    GLint minFilter = GL_LINEAR;
    GLint magFilter = GL_LINEAR;
    GLint wrapS = GL_REPEAT;
    GLint wrapT = GL_REPEAT;
    GLint wrapR = GL_REPEAT;
    bool useAnisotropicFiltering = false;
    float anisotropy = 0.0f;
    float maxAnisotropy = 0.0f; // This is usually set automatically from Application.maxTexture.Anisotropy
    
    /**
     * Constructs a new texture object.
     *
     * Params:
     *   owner = The owner object.
     */
    this(Owner owner)
    {
        super(owner);
    }
    
    this(uint w, uint h, uint channels, uint bitDepth, Owner owner)
    {
        super(owner);
        createBlank(w, h, channels, bitDepth);
    }
    
    this(uint w, uint h, Owner owner)
    {
        super(owner);
        createBlank(w, h, 4, 8);
    }
    
    /// Destructor. Releases OpenGL resources.
    ~this()
    {
        release();
    }
    
    /**
     * Creates a blank texture with the specified parameters and fill color.
     */
    void createBlank(uint w, uint h, uint channels, uint bitDepth, bool genMipmaps, Color4f fillColor = Color4f(0.0f, 0.0f, 0.0f, 1.0f))
    {
        release();
        
        SuperImage img = unmanagedImage(w, h, channels, bitDepth);
        
        foreach(y; 0..img.height)
        foreach(x; 0..img.width)
        {
            img[x, y] = fillColor;
        }
        
        createFromImage(img, genMipmaps);
        
        Delete(img);
    }
    
    void createBlank(uint w, uint h, uint channels, uint bitDepth)
    {
        release();
        SuperImage img = unmanagedImage(w, h, channels, bitDepth);
        createFromImage(img, false);
        Delete(img);
    }
    
    /**
     * Creates a texture from a 2D image.
     */
    void createFromImage(SuperImage img, bool genMipmaps)
    {
        release();
        
        this.generateMipmaps = genMipmaps;
        
        if (detectTextureFormat(img, this.format))
        {
            this.size = TextureSize(img.width, img.height, 1);
            this.mipLevels = 1;
            createTexture2D(img.data);
        }
        else
        {
            logError("Unsupported image format ", img.pixelFormat);
            createFallbackTexture();
        }
    }
    
    /**
     * Creates a 3D texture from a 2D image using SuperImage as input
     */
    void createFromImage3D(SuperImage img, uint size = 0)
    {
        if (size == 0)
        {
            size = cast(uint)cbrt(img.width * img.height);
        }
        else
        {
            if (img.width != img.height || img.width * img.height != size * size * size)
            {
                uint s = cast(uint)sqrt(cast(real)size * size * size);
                logError("Wrong image resolution for 3D texture size ", size, ": should be ", s, "x", s);
                return;
            }
        }
        
        TextureFormat format;
        detectTextureFormat(img, format);
        TextureBuffer buff;
        buff.format = format;
        buff.format.target = GL_TEXTURE_3D;
        buff.size = TextureSize(size, size, size);
        buff.mipLevels = 1;
        buff.data = img.data;
        createFromBuffer(buff, false);
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
    }
    
    /**
     * Creates a 3D texture from a 2D image using TextureBuffer as input
     */
    void createFromBuffer3D(TextureBuffer buff, uint size = 0)
    {
        if (size == 0)
        {
            size = cast(uint)cbrt(buff.size.width * buff.size.height);
        }
        else
        {
            if (buff.size.width != buff.size.height || buff.size.width * buff.size.height != size * size * size)
            {
                uint s = cast(uint)sqrt(cast(real)size * size * size);
                logError("Wrong image resolution for 3D texture size ", size, ": should be ", s, "x", s);
                return;
            }
        }
        
        TextureBuffer buff3d;
        buff3d.format = buff.format;
        buff3d.format.target = GL_TEXTURE_3D;
        buff3d.size = TextureSize(size, size, size);
        buff3d.mipLevels = 1;
        buff3d.data = buff.data;
        createFromBuffer(buff3d, false);
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
    }
    
    /**
     * Creates a texture from a buffer.
     */
    void createFromBuffer(TextureBuffer buff, bool genMipmaps)
    {
        release();
        
        this.generateMipmaps = genMipmaps;
        
        this.format = buff.format;
        this.size = buff.size;
        this.mipLevels = buff.mipLevels;
        
        if (isCubemap)
            createCubemap(buff.data);
        else if (format.target == GL_TEXTURE_1D)
            createTexture1D(buff.data);
        else if (format.target == GL_TEXTURE_2D)
            createTexture2D(buff.data);
        else if (format.target == GL_TEXTURE_3D)
            createTexture3D(buff.data);
        else
            logError("Texture creation failed: unsupported target ", format.target);
    }
    
    /**
     * Generates a blank cubemap of a given resolution.
     */
    void createBlankCubemap(TextureFormat format, uint resolution)
    {
        release();
        
        this.generateMipmaps = false;
        this.format = format;
        this.size = TextureSize(resolution, resolution, 1);
        this.mipLevels = 1;
        
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
        
        uint pSize = pixelSize;
        uint faceDataSize = resolution * resolution * pSize;
        ubyte[] faceData = New!(ubyte[])(faceDataSize);
        
        foreach(cubeFace; EnumMembers!CubeFace)
        {
            glTexImage2D(cubeFace, 0, format.internalFormat, resolution, resolution, 0, format.format, format.pixelType, cast(void*)(faceData.ptr));
        }
        
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
        
        Delete(faceData);
    }
    
    /**
     * Creates a cubemap texture from a buffer.
     */
    protected void createCubemap(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
        
        if (isCompressed)
        {
            if (mipLevels > 1)
            {
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
            }
            
            uint offset = 0;
            
            foreach(cubeFace; EnumMembers!CubeFace)
            {
                uint w = size.width;
                uint h = size.height;
                
                if (mipLevels == 1)
                {
                    uint imageSize = ((w + 3) / 4) * ((h + 3) / 4) * format.blockSize;
                    glCompressedTexImage2D(cubeFace, 0, format.internalFormat, w, h, 0, imageSize, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                }
                else
                {
                    for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                    {
                        uint imageSize = ((w + 3) / 4) * ((h + 3) / 4) * format.blockSize;
                        glCompressedTexImage2D(cubeFace, mipLevel, format.internalFormat, w, h, 0, imageSize, cast(void*)(buffer.ptr + offset));
                        offset += imageSize;
                        w /= 2;
                        h /= 2;
                        if (offset > buffer.length)
                        {
                            logError("Incomplete texture buffer");
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            if (mipLevels > 1)
            {
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
            }
            
            uint pSize = pixelSize;
            uint offset = 0;
            
            foreach(cubeFace; EnumMembers!CubeFace)
            {
                uint w = size.width;
                uint h = size.height;
                
                if (mipLevels == 1)
                {
                    uint imageSize = w * h * pSize;
                    glTexImage2D(cubeFace, 0, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                }
                else
                {
                    for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                    {
                        uint alignedSize = ((w * pSize + 3) & ~3) * h;
                        glTexImage2D(cubeFace, mipLevel, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                        offset += alignedSize;
                        w /= 2;
                        h /= 2;
                        if (offset > buffer.length)
                        {
                            logError("Incomplete texture buffer");
                            break;
                        }
                    }
                }
            }
            
            if (mipLevels == 1 && generateMipmaps)
            {
                glGenerateMipmap(GL_TEXTURE_2D);
                mipLevels = 1 + cast(uint)floor(log2(cast(double)max(size.width, size.height)));
            }
        }
        
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
        
        if (mipLevels > 1)
        {
            minFilter = GL_LINEAR_MIPMAP_LINEAR;
            magFilter = GL_LINEAR;
        }
        else
        {
            minFilter = GL_LINEAR;
            magFilter = GL_LINEAR;
        }
    }
    
    /**
     * Creates an 1D texture from a buffer.
     */
    protected void createTexture1D(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_1D, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_REPEAT;
        wrapT = GL_REPEAT;
        wrapR = GL_REPEAT;
        
        uint w = size.width;
        
        if (isCompressed)
        {
            if (mipLevels == 1)
            {
                glCompressedTexImage1D(GL_TEXTURE_1D, 0, format.internalFormat, w, 0, cast(uint)buffer.length, cast(void*)buffer.ptr);
            }
            else
            {
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint offset = 0;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint imageSize = ((w + 3) / 4) * format.blockSize;
                    
                    glCompressedTexImage1D(GL_TEXTURE_1D, mipLevel, format.internalFormat, w, 0, imageSize, cast(void*)(buffer.ptr + offset));
                    
                    offset += imageSize;
                    w /= 2;
                }
            }
        }
        else
        {
            if (mipLevels == 1)
            {
                glTexImage1D(GL_TEXTURE_1D, 0, format.internalFormat, w, 0, format.format, format.pixelType, cast(void*)buffer.ptr);
                
                if (generateMipmaps)
                {
                    glGenerateMipmap(GL_TEXTURE_1D);
                    mipLevels = 1 + cast(uint)floor(log2(cast(double)w));
                }
                else
                    mipLevels = 1;
            }
        }
    }
    
    /**
     * Creates a 2D texture from a buffer.
     */
    protected void createTexture2D(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_REPEAT;
        wrapT = GL_REPEAT;
        wrapR = GL_REPEAT;
        
        uint w = size.width;
        uint h = size.height;
        
        if (isCompressed)
        {
            if (mipLevels == 1)
            {
                glCompressedTexImage2D(GL_TEXTURE_2D, 0, format.internalFormat, w, h, 0, cast(uint)buffer.length, cast(void*)buffer.ptr);
            }
            else
            {
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint offset = 0;
                
                const uint blockWidth = 4;
                const uint blockHeight = 4;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint imageSize = ((w + blockWidth - 1) / blockWidth) * ((h + blockHeight - 1) / blockHeight) * format.blockSize;
                    glCompressedTexImage2D(GL_TEXTURE_2D, mipLevel, format.internalFormat, w, h, 0, imageSize, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                    w /= 2;
                    h /= 2;
                    if (offset > buffer.length)
                    {
                        logError("Incomplete texture buffer");
                        break;
                    }
                }
            }
        }
        else
        {
            if (mipLevels == 1)
            {
                glTexImage2D(GL_TEXTURE_2D, 0, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)buffer.ptr);
                
                if (generateMipmaps)
                {
                    glGenerateMipmap(GL_TEXTURE_2D);
                    mipLevels = 1 + cast(uint)floor(log2(cast(double)max(w, h)));
                }
                else
                    mipLevels = 1;
            }
            else if (channelSize > 0)
            {
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint pSize = pixelSize;
                uint offset = 0;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint alignedSize = ((w * pSize + 3) & ~3) * h;
                    glTexImage2D(GL_TEXTURE_2D, mipLevel, format.internalFormat, w, h, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                    offset += alignedSize;
                    w /= 2;
                    h /= 2;
                    if (offset > buffer.length)
                    {
                        logError("Incomplete texture buffer");
                        break;
                    }
                }
            }
        }
        
        if (mipLevels > 1)
        {
            minFilter = GL_LINEAR_MIPMAP_LINEAR;
            magFilter = GL_LINEAR;
        }
        else
        {
            minFilter = GL_LINEAR;
            magFilter = GL_LINEAR;
        }
    }
    
    /**
     * Creates a 3D texture from a buffer.
     */
    protected void createTexture3D(ubyte[] buffer)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_3D, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_REPEAT;
        wrapT = GL_REPEAT;
        wrapR = GL_REPEAT;
        
        uint w = size.width;
        uint h = size.height;
        uint d = size.depth;
        
        if (isCompressed)
        {
            logError("Compressed 3D textures are not supported");
        }
        else
        {
            if (mipLevels == 1)
            {
                glTexImage3D(GL_TEXTURE_3D, 0, format.internalFormat, w, h, d, 0, format.format, format.pixelType, cast(void*)buffer.ptr);
                
                if (generateMipmaps)
                {
                    glGenerateMipmap(GL_TEXTURE_3D);
                    mipLevels = 1 + cast(uint)floor(log2(cast(double)max3(w, h, d)));
                }
                else
                    mipLevels = 1;
            }
            else if (channelSize > 0)
            {
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BASE_LEVEL, 0);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAX_LEVEL, mipLevels - 1);
                
                uint pSize = pixelSize;
                uint offset = 0;
                
                for (uint mipLevel = 0; mipLevel < mipLevels; mipLevel++)
                {
                    uint rowSize = (w * pSize + 3) & ~3;
                    uint sliceSize = rowSize * h;
                    uint imageSize = sliceSize * d;
                    glTexImage3D(GL_TEXTURE_3D, mipLevel, format.internalFormat, w, h, d, 0, format.format, format.pixelType, cast(void*)(buffer.ptr + offset));
                    offset += imageSize;
                    w /= 2;
                    h /= 2;
                    d /= 2;
                    if (offset > buffer.length)
                    {
                        logError("Incomplete texture buffer");
                        break;
                    }
                }
            }
        }
    }
    
    /**
     * Creates a cubemap texture from an equirectangular environment map on the CPU side.
     * Warning: this is very slow! Use the GPU-accelerated generator (generateCubemap from
     * dagon.graphics.texproc) if you do this regularly and don't cache the resulting cubemap.
     */
    deprecated("use dagon.graphics.texproc.generateCubemap instead")
    void createFromEquirectangularMap(SuperImage envmap, uint resolution, bool generateMipmaps = true)
    {
        glGenTextures(1, &texture);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        
        minFilter = GL_LINEAR;
        magFilter = GL_LINEAR;
        wrapS = GL_CLAMP_TO_EDGE;
        wrapT = GL_CLAMP_TO_EDGE;
        wrapR = GL_CLAMP_TO_EDGE;
        
        TextureFormat tf;
        if (detectTextureFormat(envmap, tf))
        {
            format.cubeFaces = CubeFaceBit.All;
            SuperImage faceImage = envmap.createSameFormat(resolution, resolution);
            
            foreach(i, face; EnumMembers!CubeFace)
            {
                Matrix4x4f dirTransform = cubeFaceMatrix(face);
                
                foreach(x; 0..resolution)
                foreach(y; 0..resolution)
                {
                    float cubex = (cast(float)x / cast(float)resolution) * 2.0f - 1.0f;
                    float cubey = (1.0f - cast(float)y / cast(float)resolution) * 2.0f - 1.0f;
                    Vector3f dir = Vector3f(cubex, cubey, 1.0f).normalized * dirTransform;
                    Vector2f uv = equirectProj(dir);
                    Color4f c = bilinearPixel(envmap, uv.x * envmap.width, uv.y * envmap.height);
                    faceImage[x, y] = c;
                }
                
                glTexImage2D(face, 0, tf.internalFormat, resolution, resolution, 0, tf.format, tf.pixelType, cast(void*)faceImage.data.ptr);
            }
            
            Delete(faceImage);
            
            if (generateMipmaps)
            {
                glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
                mipLevels = 1 + cast(uint)floor(log2(cast(double)resolution));
            }
            else
                mipLevels = 1;
        }
        else
        {
            logError("Unsupported pixel format %s", envmap.pixelFormat);
        }
        
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
    }
    
    /// Generates mipmaps for the texture.
    void generateMipmap()
    {
        if (valid)
        {
            bind();
            glGenerateMipmap(format.target);
            mipLevels = 1 + cast(uint)floor(log2(cast(double)max(size.width, size.height)));
            unbind();
            useMipmapFiltering(true);
        }
    }
    
    /// Generate a default texture (unimplemented).
    void createFallbackTexture()
    {
        // TODO
    }
    
    /// Releases OpenGL resources.
    void release()
    {
        if (valid)
            glDeleteTextures(1, &texture);
    }
    
    /// Returns true if the texture is valid.
    bool valid()
    {
        return cast(bool)glIsTexture(texture);
    }
    
    /// Binds the texture to the current OpenGL texture unit.
    void bind()
    {
        if (valid)
        {
            if (isCubemap)
            {
                glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, wrapR);
                if (useAnisotropicFiltering)
                    glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
            }
            else if (dimension == TextureDimension.D1)
            {
                glBindTexture(GL_TEXTURE_1D, texture);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_R, wrapR);
            }
            else if (dimension == TextureDimension.D2)
            {
                glBindTexture(GL_TEXTURE_2D, texture);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, wrapR);
                if (useAnisotropicFiltering)
                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
            }
            else if (dimension == TextureDimension.D3)
            {
                glBindTexture(GL_TEXTURE_3D, texture);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, minFilter);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, magFilter);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, wrapS);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, wrapT);
                glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, wrapR);
            }
        }
    }

    /// Unbinds the texture.
    void unbind()
    {
        if (isCubemap)
            glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
        else if (dimension == TextureDimension.D1)
            glBindTexture(GL_TEXTURE_1D, 0);
        else if (dimension == TextureDimension.D2)
            glBindTexture(GL_TEXTURE_2D, 0);
        else if (dimension == TextureDimension.D3)
            glBindTexture(GL_TEXTURE_3D, 0);
        if (useAnisotropicFiltering)
            glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 0.0f);
    }
    
    /// Returns the width of the texture.
    uint width() const @property
    {
        return size.width;
    }
    
    /// Returns the height of the texture.
    uint height() const @property
    {
        return size.height;
    }
    
    /// Returns the number of channels.
    uint numChannels() const @property
    {
        return format.numChannels;
    }
    
    /// Returns true if the texture has an alpha channel.
    bool hasAlpha() const @property
    {
        return (numChannels == 4);
    }
    
    /// Returns true if the texture is compressed.
    bool isCompressed() const @property
    {
        return format.isCompressed;
    }
    
    /// Returns true if the texture is a cubemap.
    bool isCubemap() const @property
    {
        return format.isCubemap;
    }
    
    /// Returns the texture dimension.
    TextureDimension dimension() const @property
    {
        return format.dimension;
    }
    
    /// Returns the size of a channel in bytes.
    uint channelSize() const @property
    {
        return format.channelSize;
    }
    
    /// Returns the size of a pixel in bytes.
    uint pixelSize() const @property
    {
        return format.pixelSize;
    }
    
    /// Returns `true` if mipmap filtering is enabled.
    bool useMipmapFiltering() const @property
    {
        return minFilter == GL_LINEAR_MIPMAP_LINEAR;
    }
    
    /// Switches mipmap filtering.
    void useMipmapFiltering(bool mode) @property
    {
        if (mode)
            minFilter = GL_LINEAR_MIPMAP_LINEAR;
        else
            minFilter = GL_LINEAR;
    }
    
    /// Enables or disables texture repeat on UV wrap.
    void enableRepeat(bool mode) @property
    {
        if (mode)
        {
            wrapS = GL_REPEAT;
            wrapT = GL_REPEAT;
            wrapR = GL_REPEAT;
        }
        else
        {
            wrapS = GL_CLAMP_TO_EDGE;
            wrapT = GL_CLAMP_TO_EDGE;
            wrapR = GL_CLAMP_TO_EDGE;
        }
    }
    
    /// Sets the bitmask for a cubemap face.
    void setFaceBit(CubeFace face)
    {
        format.cubeFaces = format.cubeFaces | cubeFaceBit(face);
    }
    
    /// Sets the image for a cubemap face.
    void setFaceImage(CubeFace face, SuperImage img)
    {
        if (img.width != img.height)
        {
            logError("Cubemap face image must be square");
            return;
        }
        
        TextureFormat tf;
        if (!detectTextureFormat(img, tf))
        {
            logError("Unsupported image format ", img.pixelFormat);
            return;
        }
        
        if (!valid)
        {
            format.target = GL_TEXTURE_CUBE_MAP;
            
            // TODO: store individual size and format for each face
            
            size.width = img.width;
            size.height = img.height;
            
            format.format = tf.format;
            format.internalFormat = tf.internalFormat;
            format.pixelType = tf.pixelType;
            format.blockSize = tf.blockSize;
            
            glGenTextures(1, &texture);
            
            minFilter = GL_LINEAR;
            magFilter = GL_LINEAR;
            wrapS = GL_CLAMP_TO_EDGE;
            wrapT = GL_CLAMP_TO_EDGE;
            wrapR = GL_CLAMP_TO_EDGE;
        }
        
        setFaceBit(face);
        
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, texture);
        if (isCompressed)
        {
            uint dataSize = ((img.width + 3) / 4) * ((img.height + 3) / 4) * tf.blockSize;
            glCompressedTexImage2D(face, 0, tf.internalFormat, img.width, img.height, 0, dataSize, cast(void*)img.data.ptr);
        }
        else
        {
            glTexImage2D(face, 0, tf.internalFormat, img.width, img.height, 0, tf.format, tf.pixelType, cast(void*)img.data.ptr);
        }
        glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
    }
    
    void lodBias(float bias) @property
    {
        bind();
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, bias);
        unbind();
    }
}

/**
 * Detects the supported texture format from a `SuperImage`.
 *
 * Params:
 *   img = The image to analyze.
 *   tf  = Output texture format.
 * Returns:
 *   true if the format was detected successfully.
 */
bool detectTextureFormat(SuperImage img, out TextureFormat tf)
{
    uint pixelFormat = img.pixelFormat;
    switch(pixelFormat)
    {
        case IntegerPixelFormat.L8:    tf.internalFormat = GL_R8;      tf.format = GL_RED;  tf.pixelType = GL_UNSIGNED_BYTE; break;
        case IntegerPixelFormat.LA8:   tf.internalFormat = GL_RG8;     tf.format = GL_RG;   tf.pixelType = GL_UNSIGNED_BYTE; break;
        case IntegerPixelFormat.RGB8:  tf.internalFormat = GL_RGB8;    tf.format = GL_RGB;  tf.pixelType = GL_UNSIGNED_BYTE; break;
        case IntegerPixelFormat.RGBA8: tf.internalFormat = GL_RGBA8;   tf.format = GL_RGBA; tf.pixelType = GL_UNSIGNED_BYTE; break;
        case FloatPixelFormat.RGBAF32: tf.internalFormat = GL_RGBA32F; tf.format = GL_RGBA; tf.pixelType = GL_FLOAT; break;
        default:
            return false;
    }
    
    tf.target = GL_TEXTURE_2D;
    tf.blockSize = 0;
    tf.cubeFaces = CubeFaceBit.None;
    
    return true;
}

/**
 * Returns the transformation matrix for a cubemap face.
 *
 * Params:
 *   cf = The cubemap face.
 * Returns:
 *   The transformation matrix.
 */
Matrix4x4f cubeFaceMatrix(CubeFace cf)
{
    switch(cf)
    {
        case CubeFace.PositiveX:
            return rotationMatrix(1, degtorad(-90.0f));
        case CubeFace.NegativeX:
            return rotationMatrix(1, degtorad(90.0f));
        case CubeFace.PositiveY:
            return rotationMatrix(0, degtorad(90.0f));
        case CubeFace.NegativeY:
            return rotationMatrix(0, degtorad(-90.0f));
        case CubeFace.PositiveZ:
            return rotationMatrix(1, degtorad(0.0f));
        case CubeFace.NegativeZ:
            return rotationMatrix(1, degtorad(180.0f));
        default:
            return Matrix4x4f.identity;
    }
}

/**
 * Returns the world space transformation matrix for a cubemap face at a given position.
 *
 * Params:
 *   cf  = The cubemap face.
 *   pos = The camera position in world space.
 * Returns:
 *   The camera matrix.
 */
Matrix4x4f cubeFaceCameraMatrix(CubeFace cf, Vector3f pos)
{
    Matrix4x4f m;
    switch(cf)
    {
        case CubeFace.PositiveX:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(90.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        case CubeFace.NegativeX:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(-90.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        case CubeFace.PositiveY:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(0.0f)) * rotationMatrix(0, degtorad(-90.0f));
            break;
        case CubeFace.NegativeY:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(0.0f)) * rotationMatrix(0, degtorad(90.0f));
            break;
        case CubeFace.PositiveZ:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(180.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        case CubeFace.NegativeZ:
            m = rotationMatrix(1, degtorad(90.0f)) * translationMatrix(pos) * rotationMatrix(1, degtorad(0.0f)) * rotationMatrix(2, degtorad(180.0f));
            break;
        default:
            m = Matrix4x4f.identity; break;
    }
    return m;
}

/**
 * Projects a 3D direction vector to equirectangular UV coordinates.
 *
 * Params:
 *   dir = The direction vector.
 * Returns:
 *   The UV coordinates in [0,1] range.
 */
Vector2f equirectProj(Vector3f dir)
{
    float phi = acos(dir.y);
    float theta = atan2(dir.x, dir.z) + PI;
    return Vector2f(theta / (PI * 2.0f), phi / PI);
}

/**
 * Converts DirectX texture format to OpenGL texture format.
 *
 * Params:
 *   fmt = DirectX texture format.
 *   tf = Output TextureFormat
 * Returns:
 *   true if format is supported, false otherwise
 */
bool dxgiFormatToGLFormat(DXGIFormat fmt, out TextureFormat tf)
{
    switch(fmt)
    {
        case DXGIFormat.R8_UNORM:
            tf.format = GL_RED;
            tf.internalFormat = GL_R8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        case DXGIFormat.R8G8_UNORM:
            tf.format = GL_RG;
            tf.internalFormat = GL_RG8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        case DXGIFormat.R8G8B8A8_UNORM:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        case DXGIFormat.R32G32B32A32_FLOAT:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA32F;
            tf.pixelType = GL_FLOAT;
            break;
        case DXGIFormat.R16G16B16A16_FLOAT:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA16F;
            tf.pixelType = GL_HALF_FLOAT;
            break;
        case DXGIFormat.BC1_UNORM:
            tf.internalFormat = GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
            tf.blockSize = 8;
            break;
        case DXGIFormat.BC2_UNORM:
            tf.internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC3_UNORM:
            tf.internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC4_UNORM:
            tf.internalFormat = GL_COMPRESSED_RED_RGTC1;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC4_SNORM:
            tf.internalFormat = GL_COMPRESSED_SIGNED_RED_RGTC1;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC5_UNORM:
            tf.internalFormat = GL_COMPRESSED_RG_RGTC2;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC5_SNORM:
            tf.internalFormat = GL_COMPRESSED_SIGNED_RG_RGTC2;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC6H_SF16:
            tf.internalFormat = GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC6H_UF16:
            tf.internalFormat = GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB;
            tf.blockSize = 16;
            break;
        case DXGIFormat.BC7_UNORM, DXGIFormat.BC7_UNORM_SRGB:
            tf.internalFormat = GL_COMPRESSED_RGBA_BPTC_UNORM_ARB;
            tf.blockSize = 16;
            break;
        case DXGIFormat.ASTC_4X4_UNORM, DXGIFormat.ASTC_4X4_UNORM_SRGB:
            tf.internalFormat = GL_COMPRESSED_RGBA_ASTC_4x4_KHR;
            tf.blockSize = 16;
            break;
        // TODO: other ASTC formats
        default:
            logWarning("Unsupported DXGIFormat");
            return false;
    }
    
    return true;
}

/**
 * Converts Vulkan texture format to OpenGL texture format.
 *
 * Params:
 *   vkFormat = Vulkan texture format.
 *   tf = Output TextureFormat
 * Returns:
 *   true if format is supported, false otherwise
 */
bool vkFormatToGLFormat(VkFormat vkFormat, out TextureFormat tf)
{
    tf.format = 0;
    tf.internalFormat = 0;
    tf.pixelType = 0;
    tf.blockSize = 0;
    
    switch(vkFormat)
    {
        case VkFormat.R8_UNORM:
            tf.format = GL_RED;
            tf.internalFormat = GL_R8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R8_SNORM:
            tf.format = GL_RED;
            tf.internalFormat = GL_R8;
            tf.pixelType = GL_BYTE;
            break;
        
        case VkFormat.R8G8_UNORM:
            tf.format = GL_RG;
            tf.internalFormat = GL_RG8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R8G8_SNORM:
            tf.format = GL_RG;
            tf.internalFormat = GL_RG8;
            tf.pixelType = GL_BYTE;
            break;
        
        case VkFormat.R8G8B8A8_UNORM, VkFormat.R8G8B8A8_SRGB:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R8G8B8_UNORM, VkFormat.R8G8B8_SRGB:
            tf.format = GL_RGB;
            tf.internalFormat = GL_RGB8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R32G32B32A32_SFLOAT:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA32F;
            tf.pixelType = GL_FLOAT;
            break;
        
        case VkFormat.R16G16B16A16_SFLOAT:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA16F;
            tf.pixelType = GL_HALF_FLOAT;
            break;
        
        case VkFormat.BC1_RGB_UNORM_BLOCK, VkFormat.BC1_RGB_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
            tf.blockSize = 8;
            break;
        
        case VkFormat.BC2_UNORM_BLOCK, VkFormat.BC2_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC3_UNORM_BLOCK, VkFormat.BC3_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC4_UNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RED_RGTC1;
            tf.blockSize = 8;
            break;
        
        case VkFormat.BC4_SNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_SIGNED_RED_RGTC1;
            tf.blockSize = 8;
            break;
        
        case VkFormat.BC5_UNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RG_RGTC2;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC5_SNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_SIGNED_RG_RGTC2;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC6H_SFLOAT_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC6H_UFLOAT_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC7_UNORM_BLOCK, VkFormat.BC7_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_BPTC_UNORM_ARB;
            tf.blockSize = 16;
            break;
        
        case VkFormat.ASTC_4x4_UNORM_BLOCK, VkFormat.ASTC_4x4_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_ASTC_4x4_KHR;
            tf.blockSize = 16;
            break;
        
        default:
            logWarning("Unsupported VkFormat");
            return false;
    }
    
    return true;
}

/**
 * Converts OpenGL internal format to Vulkan texture format.
 *
 * Params:
 *   internalFormat = OpenGL internal format.
 * Returns:
 *   corresponding Vulkan texture format, or VkFormat.UNDEFINED if conversion fails.
 */
VkFormat glFormatToVkFormat(GLenum internalFormat)
{
    switch(internalFormat)
    {
        // Uncompressed formats
        case GL_R8:               return VkFormat.R8_UNORM;
        case GL_R8_SNORM:         return VkFormat.R8_SNORM;
        case GL_R8UI:             return VkFormat.R8_UINT;
        case GL_R8I:              return VkFormat.R8_SINT;

        case GL_RG8:              return VkFormat.R8G8_UNORM;
        case GL_RG8_SNORM:        return VkFormat.R8G8_SNORM;
        case GL_RG8UI:            return VkFormat.R8G8_UINT;
        case GL_RG8I:             return VkFormat.R8G8_SINT;

        case GL_RGB8:             return VkFormat.R8G8B8_UNORM;
        case GL_RGB8_SNORM:       return VkFormat.R8G8B8_SNORM;
        case GL_RGB8UI:           return VkFormat.R8G8B8_UINT;
        case GL_RGB8I:            return VkFormat.R8G8B8_SINT;

        case GL_RGBA8:            return VkFormat.R8G8B8A8_UNORM;
        case GL_SRGB8_ALPHA8:     return VkFormat.R8G8B8A8_SRGB;
        case GL_RGBA8_SNORM:      return VkFormat.R8G8B8A8_SNORM;
        case GL_RGBA8UI:          return VkFormat.R8G8B8A8_UINT;
        case GL_RGBA8I:           return VkFormat.R8G8B8A8_SINT;

        case GL_RGB10_A2:         return VkFormat.A2R10G10B10_UNORM_PACK32;
        case GL_RGB10_A2UI:       return VkFormat.A2R10G10B10_UINT_PACK32;

        case GL_R16F:             return VkFormat.R16_SFLOAT;
        case GL_RG16F:            return VkFormat.R16G16_SFLOAT;
        case GL_RGB16F:           return VkFormat.R16G16B16_SFLOAT;
        case GL_RGBA16F:          return VkFormat.R16G16B16A16_SFLOAT;

        case GL_R32F:             return VkFormat.R32_SFLOAT;
        case GL_RG32F:            return VkFormat.R32G32_SFLOAT;
        case GL_RGB32F:           return VkFormat.R32G32B32_SFLOAT;
        case GL_RGBA32F:          return VkFormat.R32G32B32A32_SFLOAT;

        // DXTn
        case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:        return VkFormat.BC1_RGB_UNORM_BLOCK;
        case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:       return VkFormat.BC1_RGBA_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:       return VkFormat.BC1_RGB_SRGB_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: return VkFormat.BC1_RGBA_SRGB_BLOCK;

        case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:       return VkFormat.BC2_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: return VkFormat.BC2_SRGB_BLOCK;

        case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:       return VkFormat.BC3_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: return VkFormat.BC3_SRGB_BLOCK;

        // RGTC1, RGTC2
        case GL_COMPRESSED_RED_RGTC1:                return VkFormat.BC4_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_RED_RGTC1:         return VkFormat.BC4_SNORM_BLOCK;
        case GL_COMPRESSED_RG_RGTC2:                 return VkFormat.BC5_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_RG_RGTC2:          return VkFormat.BC5_SNORM_BLOCK;

        // BPTC
        case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB: return VkFormat.BC6H_UFLOAT_BLOCK;
        case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:   return VkFormat.BC6H_SFLOAT_BLOCK;
        case GL_COMPRESSED_RGBA_BPTC_UNORM_ARB:         return VkFormat.BC7_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB:   return VkFormat.BC7_SRGB_BLOCK;

        // ETC2/EAC
        case GL_COMPRESSED_RGB8_ETC2:                return VkFormat.ETC2_R8G8B8_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ETC2:               return VkFormat.ETC2_R8G8B8_SRGB_BLOCK;
        case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                                                     return VkFormat.ETC2_R8G8B8A1_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                                                     return VkFormat.ETC2_R8G8B8A1_SRGB_BLOCK;
        case GL_COMPRESSED_RGBA8_ETC2_EAC:           return VkFormat.ETC2_R8G8B8A8_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:    return VkFormat.ETC2_R8G8B8A8_SRGB_BLOCK;

        case GL_COMPRESSED_R11_EAC:                  return VkFormat.EAC_R11_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_R11_EAC:           return VkFormat.EAC_R11_SNORM_BLOCK;
        case GL_COMPRESSED_RG11_EAC:                 return VkFormat.EAC_R11G11_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_RG11_EAC:          return VkFormat.EAC_R11G11_SNORM_BLOCK;

        // ASTC
        case GL_COMPRESSED_RGBA_ASTC_4x4_KHR:        return VkFormat.ASTC_4x4_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
                                                     return VkFormat.ASTC_4x4_SRGB_BLOCK;
        case GL_COMPRESSED_RGBA_ASTC_8x8_KHR:        return VkFormat.ASTC_8x8_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
                                                     return VkFormat.ASTC_8x8_SRGB_BLOCK;

        default:
            return VkFormat.UNDEFINED;
    }
}
