/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * A particle system.
 *
 * Description:
 * The `dagon.graphics.particles` module defines the `ParticleSystem` class
 * for simulating and rendering particles, as well as supporting
 * components such as `Emitter` (for spawning particles) and various
 * `ForceField` types (for affecting particle motion and color). The system
 * supports attractors, deflectors, vortices, black holes, and
 * color changers, as well as per-particle properties like position,
 * velocity, acceleration, color, scale, rotation, and lifetime.
 * Particle systems are useful for effects such as fire, smoke, sparks,
 * magic, and environmental phenomena.
 *
 * Copyright: Timur Gafarov 2017-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.particles;

import std.math;
import std.random;
import std.algorithm;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.quaternion;
import dlib.math.transformation;
import dlib.math.interpolation;
import dlib.math.utils;
import dlib.image.color;
import dlib.container.array;

import dagon.core.time;
import dagon.core.event;
import dagon.core.bindings;
import dagon.graphics.entity;
import dagon.graphics.texture;
import dagon.graphics.state;
import dagon.graphics.material;
import dagon.graphics.mesh;

/**
 * Represents a single particle with properties for simulation and rendering.
 */
struct Particle
{
    Color4f startColor;
    Color4f color;
    Vector3f position;
    Vector3f positionPrev;
    Vector3f acceleration;
    Vector3f velocity;
    Vector3f gravityVector;
    Vector3f scale;
    float rotation;
    float rotationDirection;
    double lifetime;
    double time;
    bool move;
    bool active;
}

/**
 * Abstract base class for force fields that affect particles.
 * Force fields can modify particle acceleration, velocity, or color.
 */
abstract class ForceField: EntityComponent
{
    /// If true, the force field is active.
    bool active = true;

    /**
     * Constructs a force field and registers it with the particle system.
     *
     * Params:
     *   hostEntity       = The entity this force field is attached to.
     *   particleSystem = The particle system to affect.
     */
    this(Entity hostEntity, ParticleSystem particleSystem)
    {
        super(particleSystem.eventManager, hostEntity);
        particleSystem.addForceField(this);
    }

    /**
     * Applies the force field's effect to a particle.
     *
     * Params:
     *   p = The reference to a particle to affect.
     */
    void affect(ref Particle p);
}

/**
 * Attractor force field that pulls particles toward its position.
 */
class Attractor: ForceField
{
    float g;

    this(Entity hostEntity, ParticleSystem particleSystem, float magnitude)
    {
        super(hostEntity, particleSystem);
        g = magnitude;
    }

    override void affect(ref Particle p)
    {
        Vector3f r = p.position - entity.position;
        float d = max(EPSILON, r.length);
        p.acceleration += r * -g / (d * d);
    }
}

/**
 * Deflector force field that pushes particles away from its position.
 */
class Deflector: ForceField
{
    float g;

    this(Entity hostEntity, ParticleSystem particleSystem, float magnitude)
    {
        super(hostEntity, particleSystem);
        g = magnitude;
    }

    override void affect(ref Particle p)
    {
        Vector3f r = p.position - entity.position;
        float d = max(EPSILON, r.length);
        p.acceleration += r * g / (d * d);
    }
}

/**
 * Vortex force field that imparts tangential and normal forces to particles.
 */
class Vortex: ForceField
{
    float g1;
    float g2;

    this(Entity hostEntity, ParticleSystem particleSystem, float tangentMagnitude, float normalMagnitude)
    {
        super(hostEntity, particleSystem);
        g1 = tangentMagnitude;
        g2 = normalMagnitude;
    }

    override void affect(ref Particle p)
    {
        if (!active) return;

        Vector3f direction = entity.transformation.forward;
        float proj = dot(p.position, direction);
        Vector3f pos = entity.position + direction * proj;
        Vector3f r = p.position - pos;
        float d = max(EPSILON, r.length);
        Vector3f t = lerp(r, cross(r, direction), 0.25f);
        p.acceleration += direction * g2 - t * g1 / (d * d);
    }
}

/**
 * Black hole force field that absorbs particles within a threshold distance.
 */
class BlackHole: ForceField
{
    float g;
    float threshold = 0.01f;

    this(Entity hostEntity, ParticleSystem particleSystem, float magnitude)
    {
        super(hostEntity, particleSystem);
        g = magnitude;
    }

    override void affect(ref Particle p)
    {
        if (!active) return;

        Vector3f r = p.position - entity.position;
        float d = r.length;
        if (d <= threshold)
        {
            p.acceleration = Vector3f(0, 0, 0);
            p.velocity = Vector3f(0, 0, 0);
            p.time = p.lifetime;
            p.active = false;
        }
        else
            p.acceleration += r * -g / (d * d);
    }
}

/**
 * Force field that changes the color of particles within a radius.
 */
class ColorChanger: ForceField
{
    Color4f color;
    float outerRadius;
    float innerRadius;

    this(Entity hostEntity, ParticleSystem particleSystem, Color4f color, float outerRadius, float innerRadius)
    {
        super(hostEntity, particleSystem);
        this.color = color;
        this.outerRadius = outerRadius;
        this.innerRadius = innerRadius;
    }

    override void affect(ref Particle p)
    {
        if (!active) return;
        
        Vector3f r = p.position - entity.position;
        float t = clamp((r.length - innerRadius) / outerRadius, 0.0f, 1.0f);
        p.color = lerp(color, p.color, t);
    }
}

/**
 * Component that emits and manages a set of particles.
 * Controls emission parameters, initial particle properties, and material.
 */
class Emitter: EntityComponent
{
    /// An array of particles that belong to this emitter.
    Particle[] particles;

    /// Minimum lifetime for emitted particles.
    double minLifetime = 1.0;

    /// Maximum lifetime for emitted particles.
    double maxLifetime = 3.0;

    /// Minimum scale for emitted particles.
    float minSize = 0.25f;

    /// Maximum scale for emitted particles.
    float maxSize = 1.0f;

    /// Scaling speed for emitted particles.
    Vector3f scaleStep = Vector3f(0, 0, 0);

    /// Angular speed for emitted particles.
    float rotationStep = 0.0f;

    /// Randomization factor for initial offset for emitted particles.
    float initialPositionRandomRadius = 0.0f;

    /// Minimum initial speed for emitted particles.
    float minInitialSpeed = 1.0f;

    /// Maximum initial speed for emitted particles.
    float maxInitialSpeed = 5.0f;

    /// Initial direction for emitted particles.
    Vector3f initialDirection = Vector3f(0, 1, 0);

    /// Randomization factor for initial direction for emitted particles.
    float initialDirectionRandomFactor = 1.0f;

    /// Start color for emitted particles.
    Color4f startColor = Color4f(1, 1, 1, 1);

    /// Final color for emitted particles.
    Color4f endColor = Color4f(1, 1, 1, 0);

    /// Damping factor for slowing out particles.
    float airFrictionDamping = 0.98f;

    /// If true, particles are emitted.
    bool emitting = true;

    /// Material for emitted particles.
    Material material;

    /// An entity that should be used for emitted particles instead of the quad (currently not supported).
    Entity particleEntity;

    /**
     * Constructs an emitter with a given number of particles.
     *
     * Params:
     *   hostEntity     = The entity this emitter is attached to.
     *   particleSystem = The particle system to register with.
     *   numParticles   = Number of particles to manage.
     */
    this(Entity hostEntity, ParticleSystem particleSystem, uint numParticles)
    {
        super(particleSystem.eventManager, hostEntity);

        particleSystem.addEmitter(this);

        particles = New!(Particle[])(numParticles);
        foreach(ref p; particles)
        {
            resetParticle(p);
        }
    }

    ~this()
    {
        Delete(particles);
    }

    /// Resets a particle to its initial state.
    void resetParticle(ref Particle p)
    {
        Vector3f posAbsolute = entity.positionAbsolute;

        if (initialPositionRandomRadius > 0.0f)
        {
            float randomDist = uniform(0.0f, initialPositionRandomRadius);
            p.position = posAbsolute + randomUnitVector3!float * randomDist;
        }
        else
            p.position = posAbsolute;

        p.positionPrev = p.position;

        Vector3f r = randomUnitVector3!float;

        float initialSpeed;
        if (maxInitialSpeed > minInitialSpeed)
            initialSpeed = uniform(minInitialSpeed, maxInitialSpeed);
        else
            initialSpeed = maxInitialSpeed;
        p.velocity = lerp(initialDirection, r, initialDirectionRandomFactor) * initialSpeed;

        if (maxLifetime > minLifetime)
            p.lifetime = uniform(minLifetime, maxLifetime);
        else
            p.lifetime = maxLifetime;
        p.gravityVector = Vector3f(0, -1, 0);

        float s;
        if (maxSize > maxSize)
            s = uniform(maxSize, maxSize);
        else
            s = maxSize;

        p.rotation = uniform(0.0f, 2.0f * PI);
        p.rotationDirection = choice([1.0f, -1.0f]);
        p.scale = Vector3f(s, s, s);
        p.time = 0.0f;
        p.move = true;
        p.startColor = startColor;
        p.color = p.startColor;
    }
}

/**
 * Particle system component for simulating and rendering particles.
 *
 * Description:
 * Manages a set of emitters and force fields, updates particles each frame,
 * and renders them as camera-facing billboards.
 */
class ParticleSystem: EntityComponent
{
    /// Event manager.
    EventManager eventManager;

    /// A list of emitters.
    Array!Emitter emitters;
    
    /// A list of force fields.
    Array!ForceField forceFields;

    /// Vertex buffer for rendering a particle quad.
    Vector3f[4] vertices;
    
    /// Texture coordinate buffer for rendering a particle quad.
    Vector2f[4] texcoords;
    
    /// Vertex indices forming a particle quad.
    uint[3][2] indices;

    /// OpenGL vertex array object for the particle quad.
    GLuint vao = 0;
    
    /// OpenGL vertex buffer object for the particle quad.
    GLuint vbo = 0;
    
    /// OpenGL texture coordinate buffer object for the particle quad.
    GLuint tbo = 0;
    
    /// OpenGL element array buffer object for the particle quad.
    GLuint eao = 0;

    /// If true, the system has active particles.
    bool haveParticlesToDraw = false;

    /// If true, the screen-space velocity is computed for particles to render motion blur.
    bool useMotionBlur = true;

    /**
     * Constructs a particle system for the given entity.
     *
     * Params:
     *   eventManager = The event manager.
     *   hostEntity   = The entity to attach to.
     */
    this(EventManager eventManager, Entity hostEntity)
    {
        super(eventManager, hostEntity);
        this.eventManager = eventManager;

        vertices[0] = Vector3f(-0.5f, 0.5f, 0);
        vertices[1] = Vector3f(-0.5f, -0.5f, 0);
        vertices[2] = Vector3f(0.5f, -0.5f, 0);
        vertices[3] = Vector3f(0.5f, 0.5f, 0);

        texcoords[0] = Vector2f(0, 0);
        texcoords[1] = Vector2f(0, 1);
        texcoords[2] = Vector2f(1, 1);
        texcoords[3] = Vector2f(1, 0);

        indices[0][0] = 0;
        indices[0][1] = 1;
        indices[0][2] = 2;

        indices[1][0] = 0;
        indices[1][1] = 2;
        indices[1][2] = 3;

        glGenBuffers(1, &vbo);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBufferData(GL_ARRAY_BUFFER, vertices.length * float.sizeof * 3, vertices.ptr, GL_STATIC_DRAW);

        glGenBuffers(1, &tbo);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glBufferData(GL_ARRAY_BUFFER, texcoords.length * float.sizeof * 2, texcoords.ptr, GL_STATIC_DRAW);

        glGenBuffers(1, &eao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.length * uint.sizeof * 3, indices.ptr, GL_STATIC_DRAW);

        glGenVertexArrays(1, &vao);
        glBindVertexArray(vao);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);

        glEnableVertexAttribArray(VertexAttrib.Vertices);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glVertexAttribPointer(VertexAttrib.Vertices, 3, GL_FLOAT, GL_FALSE, 0, null);

        glEnableVertexAttribArray(VertexAttrib.Texcoords);
        glBindBuffer(GL_ARRAY_BUFFER, tbo);
        glVertexAttribPointer(VertexAttrib.Texcoords, 2, GL_FLOAT, GL_FALSE, 0, null);

        glBindVertexArray(0);
    }

    ~this()
    {
        emitters.free();
        forceFields.free();
    }

    /// Adds a force field to the system.
    void addForceField(ForceField ff)
    {
        forceFields.append(ff);
    }

    /// Adds an emitter to the system.
    void addEmitter(Emitter em)
    {
        emitters.append(em);
    }

    /// Updates a single particle.
    void updateParticle(Emitter e, ref Particle p, double dt)
    {
        p.time += dt;

        float t = p.time / p.lifetime;
        p.color = lerp(e.startColor, e.endColor, t);
        p.scale = p.scale + e.scaleStep * dt;
        p.rotation = p.rotation + e.rotationStep * p.rotationDirection * dt;

        if (p.move)
        {
            p.acceleration = Vector3f(0, 0, 0);

            foreach(ref ff; forceFields)
            {
                ff.affect(p);
            }

            p.velocity += p.acceleration * dt;
            p.velocity = p.velocity * e.airFrictionDamping;

            p.positionPrev = p.position;
            p.position += p.velocity * dt;
        }

        p.color.a = lerp(e.startColor.a, e.endColor.a, t);
    }

    /// Updates all particles and emitters.
    override void update(Time t)
    {
        haveParticlesToDraw = false;

        foreach(e; emitters)
        foreach(ref p; e.particles)
        {
            if (p.active)
            {
                if (p.time < p.lifetime)
                {
                    updateParticle(e, p, t.delta);
                    haveParticlesToDraw = true;
                }
                else
                    p.active = false;
            }
            else if (e.emitting)
            {
                e.resetParticle(p);
                p.active = true;
            }
        }
    }

    /// Renders all active particles as billboards.
    override void render(GraphicsState* state)
    {
        if (haveParticlesToDraw)
        {
            foreach(e; emitters)
            if (e.entity.visible)
            {
                bool shouldRender = true;

                if (shouldRender)
                {
                    if (e.material)
                        e.entity.material = e.material;

                    foreach(ref p; e.particles)
                    if (p.time < p.lifetime)
                    {
                        renderBillboardParticle(e, p, state);
                    }
                }
            }
        }
    }

    /// Renders a single billboard particle.
    void renderBillboardParticle(Emitter e, ref Particle p, GraphicsState* state)
    {
        Matrix4x4f trans = translationMatrix(p.position);
        Matrix4x4f prevTrans = translationMatrix(p.positionPrev);

        Matrix4x4f modelViewMatrix =
            state.viewMatrix *
            translationMatrix(p.position) *
            state.invViewRotationMatrix *
            rotationMatrix(Axis.z, p.rotation) *
            scaleMatrix(Vector3f(p.scale.x, p.scale.y, 1.0f));

        GraphicsState stateLocal = *state;
        stateLocal.modelViewMatrix = modelViewMatrix;

        if (useMotionBlur)
            stateLocal.prevModelViewMatrix = stateLocal.prevViewMatrix * prevTrans;
        else
            stateLocal.prevModelViewMatrix = stateLocal.viewMatrix * trans;

        if (e.material)
        {
            e.material.baseColorFactor = p.color;
            e.material.bind(&stateLocal);
        }

        if (stateLocal.shader)
        {
            stateLocal.shader.bindParameters(&stateLocal);
        }

        glBindVertexArray(vao);
        glDrawElements(GL_TRIANGLES, cast(uint)indices.length * 3, GL_UNSIGNED_INT, cast(void*)0);
        glBindVertexArray(0);

        if (stateLocal.shader)
        {
            stateLocal.shader.unbindParameters(&stateLocal);
        }

        if (e.material)
        {
            e.material.unbind(&stateLocal);
        }
    }
}

/**
 * Utility function to check if an entity is a particle system.
 *
 * Params:
 *   entity = The entity to check.
 * Returns:
 *   `true` if the entity contains a `ParticleSystem` component.
 */
bool entityIsParticleSystem(Entity entity)
{
    foreach(comp; entity.components.data)
    {
        ParticleSystem psys = cast(ParticleSystem)comp;
        if (psys)
            return true;
    }
    return false;
}
