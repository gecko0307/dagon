/*
Copyright (c) 2019-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Provides the scene graph node and component system.
 *
 * Description:
 * The `dagon.graphics.entity` module provides the `Entity` class, which represents
 * a node in the scene graph and supports hierarchical transformations, components,
 * tweening, and rendering. Entities can be dynamic or static, cast shadows,
 * and interact with the rendering system through various flags and material parameters.
 * The module also defines the `EntityComponent` base class for attachable logic/rendering
 * components, the `EntityGroup` interface for entity collections, and utility
 * functions for transformation math.
 *
 * Copyright: Timur Gafarov 2019-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.graphics.entity;

import std.math;

import dlib.core.ownership;
import dlib.core.memory;
import dlib.container.array;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.quaternion;
import dlib.math.transformation;
import dlib.math.utils;
import dlib.geometry.aabb;

import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;
import dagon.graphics.updateable;
import dagon.graphics.drawable;
import dagon.graphics.mesh;
import dagon.graphics.terrain;
import dagon.graphics.material;
import dagon.graphics.shader;
import dagon.graphics.tween;
import dagon.graphics.world;
import dagon.graphics.pose;

/**
 * Specifies the logical layer of an entity in the scene.
 */
enum EntityLayer: int
{
    /// Background layer.
    Background = 0,

    /// Main spatial layer (default).
    Spatial = 1,

    /// Foreground layer.
    Foreground = 2
}

/**
 * Specifies the type of an entity.
 */
enum EntityType: int
{
    /// General-purpose entity.
    General = 0,

    /// Terrain entity.
    Terrain = 1
}

/**
 * Specifies the transformation mode for an entity.
 */
enum TransformMode: int
{
    /// Use translation, rotation, scaling (separate).
    TRS = 0,

    /// Use a local transformation matrix directly.
    Matrix = 1
}

/**
 * Represents a node in the scene graph.
 *
 * Description:
 * Entities are spatially transformable objects that may have children,
 * components, and a visual representation (via `Drawable`). They can be
 * dynamic or static, cast shadows, and interact with the rendering system
 * through various flags and material parameters.
 * Entities form a hierarchical structure and are updated each frame
 * as part of the world update cycle.
 */
class Entity: Owner, Updateable
{
   public:
    /// The logical layer of this entity.
    EntityLayer layer = EntityLayer.Spatial;

    /// The type of this entity.
    EntityType type = EntityType.General;
    
    /// The render layer index for sorting or batching.
    int renderLayer = 0;
    
    /// If false, the entity is not rendered.
    bool visible = true;

    /// If true, the entity casts shadows.
    bool castShadow = true;

    /// Whether the entity should be treated as a solid object (for physics/collision).
    bool solid = false;

    /// Indicates whether the entity can move.
    bool dynamic = true;

    /// If true, the entity is treated as a decal.
    bool decal = false;

    /// If true, the entity is treated as an environment probe volume (for lighting/reflections).
    bool probe = false;

    /// The extents of the probe volume.
    Vector3f probeExtents = Vector3f(1.0f, 1.0f, 1.0f);

    /// The falloff margin for the probe.
    float probeFalloffMargin = 0.1f;

    /// If true, enable box projection for the probe volume
    bool probeUseBoxProjection = false;

    /// If true, the entity is treated as transparent.
    bool transparent = false;

    /// Opacity factor for rendering (0.0 = fully transparent, 1.0 = fully opaque).
    float opacity = 1.0f;

   /**
    * G-buffer mask value for deferred rendering.
    * This value is treated as an alpha channel when rendering
    * the entity to the G-buffer.
    */
    float gbufferMask = 1.0f;

   /**
    * Motion blur mask value.
    * This value is treated as an alpha channel when rendering
    * the entity to the screen-space velocity buffer.
    */
    float blurMask = 1.0f;

   /**
    * If `true`, shader parameters will be bound automatically
    * in the `RenderPass` before rendering the entity.
    * Otherwise the derived render pass should bind shader
    * parameters.
    */
    bool bindShaderParameters = true;

    /// The world this entity belongs to.
    World world;

    /// Optional parent entity in the scene graph.
    Entity parent = null;

    /// List of child entities.
    Array!Entity children;

    /// The attached components.
    Array!EntityComponent components;

    /// Active tweens used to animate this entity.
    Array!Tween tweens;

    /// Optional drawable object (visual representation) for this entity.
    Drawable drawable;

    /// Optional material used for rendering.
    Material material;

    /// Local position.
    Vector3f position;

    /// Local rotation (quaternion).
    Quaternionf rotation;

    /// Local scaling.
    Vector3f scaling;

    /// Local transformation matrix.
    Matrix4x4f transformation;

    /// Inverse of the local transformation matrix.
    Matrix4x4f invTransformation;

    /// Final transformation matrix relative to world root.
    Matrix4x4f absoluteTransformation;

    /// Inverse of the absolute transformation matrix.
    Matrix4x4f invAbsoluteTransformation;

    /// Previous frame's local transformation (for motion blur).
    Matrix4x4f prevTransformation;

    /// Previous frame's absolute transformation.
    Matrix4x4f prevAbsoluteTransformation;

    /// The size of the entity's bounding box.
    Vector3f boundingBoxSize;
    
    /// Transformation mode (TRS or Matrix).
    TransformMode transformMode = TransformMode.TRS;
    
    /// Optional pose (for skinning).
    Pose pose;

   protected:

    /// The axis-aligned bounding box.
    AABB aabb;

   public:

    /**
     * Constructs an entity and adds it to the world if provided.
     *
     * Params:
     *   owner = The owner object.
     */
    this(Owner owner)
    {
        super(owner);

        World w = cast(World)owner;
        if (w)
        {
            world = w;
            world.add(this);
        }

        position = Vector3f(0, 0, 0);
        rotation = Quaternionf.identity;
        scaling = Vector3f(1, 1, 1);

        transformation = Matrix4x4f.identity;
        invTransformation = Matrix4x4f.identity;

        absoluteTransformation = Matrix4x4f.identity;
        invAbsoluteTransformation = Matrix4x4f.identity;

        prevTransformation = Matrix4x4f.identity;
        prevAbsoluteTransformation = Matrix4x4f.identity;

        tweens.reserve(10);

        boundingBoxSize = Vector3f(1.0f, 1.0f, 1.0f);
        aabb = AABB(position, boundingBoxSize);
    }

    /**
     * Sets the parent entity in the scene graph.
     *
     * Params:
     *   parentEntity = The new parent entity.
     */
    void setParent(Entity parentEntity)
    {
        if (parent)
            parent.removeChild(this);

        parent = parentEntity;
        parent.addChild(this);
    }

    /**
     * Adds a child entity.
     *
     * Params:
     *   childEntity = The child entity to add.
     */
    void addChild(Entity childEntity)
    {
        if (childEntity.parent)
            childEntity.parent.removeChild(childEntity);
        children.append(childEntity);
        childEntity.parent = this;
    }

    /**
     * Removes a child entity.
     *
     * Params:
     *   childEntity = The child entity to remove.
     */
    void removeChild(Entity childEntity)
    {
        children.removeFirst(childEntity);
        childEntity.parent = null;
    }

    /**
     * Adds a component to this entity.
     *
     * Params:
     *   component = The component to add.
     */
    void addComponent(EntityComponent component)
    {
        components.append(component);
    }

    /**
     * Removes a component from this entity.
     *
     * Params:
     *   component = The component to remove.
     */
    void removeComponent(EntityComponent component)
    {
        components.removeFirst(component);
    }
    
    /// Updates the absolute transformation matrix.
    void updateAbsoluteTransformation()
    {
        invTransformation = transformation.inverse;
        
        if (parent)
        {
            absoluteTransformation = parent.absoluteTransformation * transformation;
            invAbsoluteTransformation = invTransformation * parent.invAbsoluteTransformation;
            prevAbsoluteTransformation = parent.prevAbsoluteTransformation * prevTransformation;
        }
        else if (world !is null)
        {
            absoluteTransformation = world.rootTransformation * transformation;
            invAbsoluteTransformation = invTransformation * world.rootInvTransformation;
            prevAbsoluteTransformation = world.prevRootTransformation * prevTransformation;
        }
        else
        {
            absoluteTransformation = transformation;
            invAbsoluteTransformation = invTransformation;
            prevAbsoluteTransformation = prevTransformation;
        }

        aabb = AABB(absoluteTransformation.translation, boundingBoxSize);
    }

    /**
     * Updates the local and absolute transformation matrices.
     * If `transformMode` is `TransformMode.Matrix`,
     * the transformation matrix should be updated manually when needed
     */
    void updateTransformation()
    {
        prevTransformation = transformation;
        
        if (transformMode == TransformMode.TRS)
        {
            transformation =
                translationMatrix(position) *
                rotation.toMatrix4x4 *
                scaleMatrix(scaling);
        }
        
        updateAbsoluteTransformation();
    }
    
    /// Updates transformations top-down through the hierarchy (from parent to children).
    void updateTransformationTopDown()
    {
        updateTransformation();
        
        foreach(child; children)
        {
            child.updateTransformationTopDown();
        }
    }

    /// Updates transformations bottom-up through the hierarchy (from child to parent).
    void updateTransformationBottomUp()
    {
        if (parent)
            parent.updateTransformationBottomUp();
        updateTransformation();
    }

    /**
     * Updates the entity and its components for the current frame.
     *
     * Params:
     *   t = The current frame's timing information.
     */
    void update(Time t)
    {
        foreach(i, ref tween; tweens.data)
        {
            tween.update(t.delta);
        }

        updateTransformation();

        foreach(c; components)
        {
            c.update(t);
        }
    }

    /// Releases all resources and detaches from parent and children.
    void release()
    {
        if (parent)
            parent.removeChild(this);

        for (size_t i = 0; i < children.data.length; i++)
            children.data[i].parent = null;

        children.free();
        components.free();
        tweens.free();
    }

    /// Returns the absolute position of the entity.
    Vector3f positionAbsolute()
    {
        return absoluteTransformation.translation;
    }

    /// Returns the absolute rotation of the entity.
    Quaternionf rotationAbsolute()
    {
        if (parent)
            return parent.rotationAbsolute * rotation;
        else
            return rotation;
    }

    /// Translates the entity by the given vector.
    void translate(Vector3f v)
    {
        position += v;
    }

    /// Translates the entity by the given vector components.
    void translate(float vx, float vy, float vz)
    {
        position += Vector3f(vx, vy, vz);
    }

    /// Moves the entity forward by the given speed.
    void move(float speed)
    {
        position += transformation.forward * speed;
    }

    /// Moves the entity toward a point at the given speed.
    void moveToPoint(Vector3f p, float speed)
    {
        Vector3f dir = (p - position).normalized;
        float d = distance(p, position);
        if (d > speed)
            position += dir * speed;
        else
            position += dir * d;
    }

    /// Strafes (moves to the right) by the given speed.
    void strafe(float speed)
    {
        position += transformation.right * speed;
    }

    /// Lifts (moves up) by the given speed.
    void lift(float speed)
    {
        position += transformation.up * speed;
    }

    /// Sets the rotation using Euler angles (degrees).
    void angles(Vector3f v)
    {
        rotation =
            rotationQuaternion!float(Axis.x, degtorad(v.x)) *
            rotationQuaternion!float(Axis.y, degtorad(v.y)) *
            rotationQuaternion!float(Axis.z, degtorad(v.z));
    }

    /// Sets the rotation using Euler angles (degrees).
    void setRotation(float x, float y, float z)
    {
        angles = Vector3f(x, y, z);
    }

    /// Rotates the entity by the given Euler angles (degrees).
    void rotate(Vector3f v)
    {
        auto r =
            rotationQuaternion!float(Axis.x, degtorad(v.x)) *
            rotationQuaternion!float(Axis.y, degtorad(v.y)) *
            rotationQuaternion!float(Axis.z, degtorad(v.z));
        rotation *= r;
    }

    /// Rotates the entity by the given Euler angles (degrees).
    void rotate(float x, float y, float z)
    {
        rotate(Vector3f(x, y, z));
    }

    /// Rotates the entity around the local X axis.
    void pitch(float angle)
    {
        rotation *= rotationQuaternion!float(Axis.x, degtorad(angle));
    }

    /// Rotates the entity around the local Y axis.
    void turn(float angle)
    {
        rotation *= rotationQuaternion!float(Axis.y, degtorad(angle));
    }

    /// Rotates the entity around the local Z axis.
    void roll(float angle)
    {
        rotation *= rotationQuaternion!float(Axis.z, degtorad(angle));
    }

    /// Scales the entity uniformly.
    void scale(float s)
    {
        scaling += Vector3f(s, s, s);
    }

    /// Scales the entity non-uniformly by the given vector.
    void scale(Vector3f s)
    {
        scaling += s;
    }

    /// Scales the entity along the local X axis.
    void scaleX(float s)
    {
        scaling.x += s;
    }

    /// Scales the entity along the local Y axis.
    void scaleY(float s)
    {
        scaling.y += s;
    }

    /// Scales the entity along the Z axis.
    void scaleZ(float s)
    {
        scaling.z += s;
    }

    /// Returns the local forward vector.
    Vector3f direction() const @property
    {
        return transformation.forward;
    }

     /// Returns the local right vector.
    Vector3f right() const @property
    {
        return transformation.right;
    }

    /// Returns the local up vector.
    Vector3f up() const @property
    {
        return transformation.up;
    }

    /// Returns the absolute forward vector.
    Vector3f directionAbsolute() const @property
    {
        return absoluteTransformation.forward;
    }

    /// Returns the absolute right vector.
    Vector3f rightAbsolute() const @property
    {
        return absoluteTransformation.right;
    }

    /// Returns the absolute up vector.
    Vector3f upAbsolute() const @property
    {
        return absoluteTransformation.up;
    }

    /// Returns a pointer to an inactive tween, or null if none.
    Tween* getInactiveTween()
    {
        Tween* inactiveTween = null;
        foreach(i, ref t; tweens.data)
        {
            if (!t.active)
            {
                inactiveTween = &tweens.data[i];
                break;
            }
        }
        return inactiveTween;
    }

    /**
     * Starts a position tween from one point to another.
     *
     * Params:
     *   pointFrom = Starting position.
     *   pointTo   = Ending position.
     *   duration  = Duration in seconds.
     *   easing    = Easing function (default: Linear).
     * Returns:
     *   Pointer to the tween.
     */
    Tween* moveFromTo(Vector3f pointFrom, Vector3f pointTo, double duration, Easing easing = Easing.Linear)
    {
        Tween* existingTween = getInactiveTween();

        if (existingTween)
        {
            *existingTween = Tween(this, TweenType.Position, pointFrom, pointTo, duration, easing);
            return existingTween;
        }
        else
        {
            Tween t = Tween(this, TweenType.Position, pointFrom, pointTo, duration, easing);
            tweens.append(t);
            return &tweens.data[$-1];
        }
    }

    /**
     * Starts a rotation tween from one set of angles to another.
     *
     * Params:
     *   anglesFrom = Starting angles (degrees).
     *   anglesTo   = Ending angles (degrees).
     *   duration   = Duration in seconds.
     *   easing     = Easing function (default: Linear).
     * Returns:
     *   Pointer to the tween.
     */
    Tween* rotateFromTo(Vector3f anglesFrom, Vector3f anglesTo, double duration, Easing easing = Easing.Linear)
    {
        Tween* existingTween = getInactiveTween();

        if (existingTween)
        {
            *existingTween = Tween(this, TweenType.Rotation, anglesFrom, anglesTo, duration, easing);
            return existingTween;
        }
        else
        {
            Tween t = Tween(this, TweenType.Rotation, anglesFrom, anglesTo, duration, easing);
            tweens.append(t);
            return &tweens.data[$-1];
        }
    }

    /**
     * Starts a scaling tween from one scale to another.
     *
     * Params:
     *   sFrom   = Starting scale.
     *   sTo     = Ending scale.
     *   duration = Duration in seconds.
     *   easing   = Easing function (default: Linear).
     * Returns:
     *   Pointer to the tween.
     */
    Tween* scaleFromTo(Vector3f sFrom, Vector3f sTo, double duration, Easing easing = Easing.Linear)
    {
        Tween* existingTween = getInactiveTween();

        if (existingTween)
        {
            *existingTween = Tween(this, TweenType.Scaling, sFrom, sTo, duration, easing);
            return existingTween;
        }
        else
        {
            Tween t = Tween(this, TweenType.Scaling, sFrom, sTo, duration, easing);
            tweens.append(t);
            return &tweens.data[$-1];
        }
    }
    
    Tween* opacityFromTo(float opFrom, float opTo, double duration, Easing easing = Easing.Linear)
    {
        Tween* existingTween = getInactiveTween();

        if (existingTween)
        {
            *existingTween = Tween(this, TweenType.Alpha, opFrom, opTo, duration, easing);
            return existingTween;
        }
        else
        {
            Tween t = Tween(this, TweenType.Alpha, opFrom, opTo, duration, easing);
            tweens.append(t);
            return &tweens.data[$-1];
        }
    }
    
    Tween* fadeIn(double duration, Easing easing = Easing.Linear)
    {
        return opacityFromTo(0.0f, 1.0f, duration, easing);
    }

    Tween* fadeOut(double duration, Easing easing = Easing.Linear)
    {
        return opacityFromTo(1.0f, 0.0f, duration, easing);
    }

    /**
     * Returns the entity's bounding box in world space.
     */
    AABB boundingBox() const @property
    {
        if (drawable)
        {
            Mesh mesh = cast(Mesh)drawable;
            Terrain terrain = cast(Terrain)drawable;

            if (terrain)
            {
                mesh = terrain.mesh;
            }

            if (mesh)
            {
                auto bb = mesh.boundingBox;
                // TODO: transform bb with absoluteTransformation
                return AABB(absoluteTransformation.translation + bb.center, bb.size * matrixScale(absoluteTransformation));
            }
            else
                return aabb;
        }
        else
            return aabb;
    }

    /// Destructor. Releases all resources.
    ~this()
    {
        release();
    }

    /// Processes events for all attached components.
    void processEvents()
    {
        foreach(c; components)
        {
            c.processEvents();
        }
    }
    
    void hide()
    {
        visible = false;
        foreach(e; children)
        {
            e.hide();
        }
    }
    
    void show()
    {
        visible = true;
        foreach(e; children)
        {
            e.show();
        }
    }
    
    Shader shader() @property
    {
        if (material)
            return material.shader;
        else
            return null;
    }
}

/**
 * Base class for attachable entity components.
 *
 * Description:
 * Components can implement update and render logic, and are attached to entities.
 */
class EntityComponent: EventListener, Updateable, Drawable
{
    /// The entity this component is attached to.
    Entity entity;

    /// If false, the component is not rendered.
    bool visible = true;

    /**
     * Constructs an entity component and attaches it to the given entity.
     *
     * Params:
     *   eventManager = The event manager.
     *   hostEntity   = The entity to attach to.
     */
    this(EventManager eventManager, Entity hostEntity)
    {
        super(eventManager, hostEntity);
        entity = hostEntity;
        entity.addComponent(this);
    }

    /// Override to implement per-frame update logic.
    void update(Time t)
    {
    }

    /// Override to implement rendering logic.
    void render(GraphicsState* state)
    {
    }
}

/**
 * Interface for a group of entities.
 * Provides an opApply for iteration.
 */
interface EntityGroup
{
    /// Iterates over all entities in the group.
    int opApply(scope int delegate(Entity) dg);
}

/**
 * Computes the scale vector from a transformation matrix.
 *
 * Params:
 *   m = The transformation matrix.
 * Returns:
 *   The scale as a Vector3f.
 */
Vector3f matrixScale(Matrix4x4f m)
{
    float sx = Vector3f(m.a11, m.a12, m.a13).length;
    float sy = Vector3f(m.a21, m.a22, m.a23).length;
    float sz = Vector3f(m.a31, m.a32, m.a33).length;
    return Vector3f(sx, sy, sz);
}
