/*
Copyright (c) 2017-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * A first-person camera control component.
 *
 * Description:
 * The `dagon.ui.firstpersonview` module defines the `FirstPersonViewComponent`
 * class, which enables first-person camera kinematics using mouse input.
 * The component supports relative and absolute mouse modes, pitch/turn limits,
 * and configurable sensitivities. It provides methods for moving forward/backward
 * and strafing left/right, as well as handling window focus events.
 *
 * Copyright: Timur Gafarov 2017-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.ui.firstpersonview;

import std.math;

import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.quaternion;
import dlib.math.transformation;
import dlib.math.utils;

import dagon.core.event;
import dagon.core.keycodes;
import dagon.core.time;
import dagon.graphics.entity;

/**
 * First-person camera control component for entities.
 *
 * Description:
 * Enables mouse and keyboard-based camera orientation and movement,
 * supporting both relative and absolute mouse modes.
 * Handles pitch and turn limits and configurable sensitivities.
 */
class FirstPersonViewComponent: EntityComponent
{
    protected bool _active = true;
    protected bool _useRelativeMouseMode = true;
    
    /// True if mouse input is active.
    bool mouseActive = true;
    
    /// Mouse sensitivity factor.
    float mouseSensitivity = 0.2f;

    /// Sensitivity for virtual axes (controlled via keyboard or gamepad).
    float axisSensitivity = 2.0f;
    
    /// Lower threshold of controller axis value.
    float axisDeadzone = 0.075f;
    
    /// Maximum pitch angle (degrees).
    float pitchLimitMax = 60.0f;

    /// Minimum pitch angle (degrees).
    float pitchLimitMin = -60.0f;
    
    /// Previous mouse X coordinate.
    int prevMouseX = 0;

    /// Previous mouse Y coordinate.
    int prevMouseY = 0;
    
    /// Camera pitch angle (degrees).
    float pitch = 0.0f;

    /// Camera turn angle (degrees).
    float turn = 0.0f;
    
    /// Vertical orientation quaternion.
    Quaternionf orientationV = Quaternionf.identity;

    /// Horizontal orientation quaternion.
    Quaternionf orientationH = Quaternionf.identity;
    
    /// Base orientation quaternion.
    Quaternionf baseOrientation = Quaternionf.identity;
    
    /// Current forward direction vector.
    Vector3f direction = Vector3f(0.0f, 0.0f, 1.0f);

    /// Forward direction ignoring pitch.
    Vector3f directionHorizontal = Vector3f(0.0f, 0.0f, 1.0f);

    /// Right direction vector.
    Vector3f right = Vector3f(1.0f, 0.0f, 0.0f);

    /// Up direction vector.
    Vector3f up = Vector3f(0.0f, 1.0f, 0.0f);
    
    /**
     * Constructs a first-person view component for the given entity.
     *
     * Params:
     *   eventManager = Event manager.
     *   hostEntity   = Entity to attach the component to (usually a `Camera` object).
     */
    this(EventManager eventManager, Entity hostEntity)
    {
        super(eventManager, hostEntity);
        active = true;
        useRelativeMouseMode = true;
        reset();
    }
    
    /// Enables or disables the component.
    void active(bool mode) @property
    {
        _active = mode;
        prevMouseX = eventManager.mouseX;
        prevMouseY = eventManager.mouseY;
        eventManager.setRelativeMouseMode(_useRelativeMouseMode && _active);
        if (!_active)
        {
            eventManager.setMouseToCenter();
        }
    }
    
    /// Returns whether the component is active.
    bool active() const @property
    {
        return _active;
    }
    
    /// Enables or disables relative mouse mode.
    void useRelativeMouseMode(bool mode) @property
    {
        _useRelativeMouseMode = mode;
        eventManager.setRelativeMouseMode(_useRelativeMouseMode && _active);
    }
    
    /// Returns whether relative mouse mode is enabled.
    bool useRelativeMouseMode() const @property
    {
        return _useRelativeMouseMode;
    }
    
    /// Resets pitch, turn, and mouse state.
    void reset()
    {
        pitch = 0.0f;
        turn = 0.0f;
        if (!useRelativeMouseMode)
            eventManager.setMouseToCenter();
        prevMouseX = eventManager.mouseX;
        prevMouseY = eventManager.mouseY;
    }
    
    /// Updates the component each frame (handles input and orientation).
    override void update(Time time)
    {
        processEvents();
        
        if (_active & mouseActive)
        {
            float mouseRelH = 0.0f;
            float mouseRelV = 0.0f;
            if (useRelativeMouseMode)
            {
                mouseRelH = eventManager.mouseRelX * mouseSensitivity;
                mouseRelV = eventManager.mouseRelY * mouseSensitivity;
            }
            else
            {
                mouseRelH =  (eventManager.mouseX - prevMouseX) * mouseSensitivity;
                mouseRelV = (eventManager.mouseY - prevMouseY) * mouseSensitivity;
            }
            
            float hAxis = inputManager.getAxis("horizontal");
            float vAxis = inputManager.getAxis("vertical");
            if (abs(hAxis) < axisDeadzone) hAxis = 0.0f;
            if (abs(vAxis) < axisDeadzone) vAxis = 0.0f;
            
            pitch -= mouseRelV + vAxis * axisSensitivity;
            turn -= mouseRelH + hAxis * axisSensitivity;
            
            if (pitch > pitchLimitMax)
            {
                pitch = pitchLimitMax;
            }
            else if (pitch < pitchLimitMin)
            {
                pitch = pitchLimitMin;
            }
            
            if (!useRelativeMouseMode)
                eventManager.setMouseToCenter();
            
            prevMouseX = eventManager.mouseX;
            prevMouseY = eventManager.mouseY;
        }
        
        orientationV = rotationQuaternion(Vector3f(1.0f, 0.0f, 0.0f), degtorad(pitch));
        orientationH = rotationQuaternion(Vector3f(0.0f, 1.0f, 0.0f), degtorad(turn));
        
        Quaternionf orientation = baseOrientation * orientationH * orientationV;
        
        entity.transformation =
            (translationMatrix(entity.position) *
            orientation.toMatrix4x4 *
            scaleMatrix(entity.scaling));
        
        entity.invTransformation = entity.transformation.inverse;
        
        if (entity.parent)
        {
            entity.absoluteTransformation = entity.parent.absoluteTransformation * entity.transformation;
            entity.invAbsoluteTransformation = entity.invTransformation * entity.parent.invAbsoluteTransformation;
            entity.prevAbsoluteTransformation = entity.parent.prevAbsoluteTransformation * entity.prevTransformation;
        }
        else
        {
            entity.absoluteTransformation = entity.transformation;
            entity.invAbsoluteTransformation = entity.invTransformation;
            entity.prevAbsoluteTransformation = entity.prevTransformation;
        }
        
        direction = orientation.rotate(Vector3f(0.0f, 0.0f, 1.0f));
        directionHorizontal = orientationH.rotate(Vector3f(0.0f, 0.0f, 1.0f));
        right = orientationH.rotate(Vector3f(1.0f, 0.0f, 0.0f));
        up = orientationH.rotate(Vector3f(01.0f, 1.0f, 0.0f));
    }
    
    /// Called when the application gains focus.
    override void onFocusGain()
    {
        mouseActive = true;
    }
    
    /// Called when the application loses focus.
    override void onFocusLoss()
    {
        mouseActive = false;
    }
    
    /// Moves the entity forward by the given speed.
    void moveForward(float speed)
    {
        entity.position -= entity.transformation.forward.normalized * speed;
    }
    
    /// Moves the entity backward by the given speed.
    void moveBack(float speed)
    {
        entity.position += entity.transformation.forward.normalized * speed;
    }
    
    /// Strafes the entity right by the given speed.
    void strafeRight(float speed)
    {
        entity.position += entity.transformation.right.normalized * speed;
    }
    
    /// Strafes the entity left by the given speed.
    void strafeLeft(float speed)
    {
        entity.position -= entity.transformation.right.normalized * speed;
    }
}
