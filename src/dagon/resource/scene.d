/*
Copyright (c) 2019-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Scene class.
 *
 * The `dagon.resource.scene` module defines the `Scene` class, which provides
 * asset manager, world, and environment for a 3D scene.
 * The `Scene` class provides methods for adding and managing assets (textures,
 * meshes, materials, etc.), creating entities, cameras, lights, and decals,
 * and handling scene loading, updating, and event processing. The scene supports
 * threaded asset loading, progress callbacks, and hooks for custom loading
 * and update logic.
 *
 * Copyright: Timur Gafarov 2019-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.resource.scene;

import std.path;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.vector;

import dagon.core.application;
import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;

import dagon.graphics.entity;
import dagon.graphics.camera;
import dagon.graphics.light;
import dagon.graphics.environment;
import dagon.graphics.shapes;
import dagon.graphics.material;
import dagon.graphics.world;

import dagon.resource.asset;
import dagon.resource.obj;
import dagon.resource.gltf;
import dagon.resource.texture;
import dagon.resource.text;
import dagon.resource.binary;

/**
 * Manages the application context, assets, world,
 * and environment for a 3D scene.
 *
 * The `Scene` class provides methods for adding assets
 * (textures, OBJ, GLTF, text, binary), creating entities,
 * cameras, lights, and decals, and handling scene loading
 * and update logic. It supports threaded asset loading,
 * progress reporting, and customizable hooks for loading
 * and update events.
 */
class Scene: EventListener
{
    /// The application.
    Application application;
    
    protected AssetManager assetManagerInternal;
    protected World worldInternal;
    protected Environment environmentInternal;
    
    /// The asset manager for this scene.
    AssetManager assetManager;

    /// The world containing all entities.
    World world;

    /// The environment settings for the scene.
    Environment environment;

    /// Default shape for decals.
    ShapeBox decalShape;

    /// True if loading has started.
    bool startedLoading = false;

    /// True if assets are currently loading.
    bool isLoading = false;

    /// True if loading is complete.
    bool loaded = false;

    /// True if the scene is ready to render.
    bool canRender = false;

    /// True if the scene is focused.
    bool focused = true;

    /// True if the scene is paused.
    bool paused = false;

    /**
     * Constructs a new scene with the given application.
     *
     * Params:
     *   application = The application instance.
     */
    this(Application application)
    {
        super(application.eventManager, application);
        this.application = application;
        
        assetManagerInternal = New!AssetManager(eventManager, this);
        assetManager = assetManagerInternal;
        assetManager.application = application;
        
        worldInternal = New!World(this);
        world = worldInternal;

        environmentInternal = New!Environment(this);
        environment = environmentInternal;
        
        decalShape = New!ShapeBox(Vector3f(1, 1, 1), this);
    }

    /**
     * Adds an asset to the scene's asset manager.
     *
     * Params:
     *   asset    = The asset to add.
     *   filename = The asset filename.
     *   preload  = If true, preload the asset immediately.
     * Returns:
     *   The added asset.
     */
    Asset addAsset(Asset asset, string filename, bool preload = false)
    {
        if (preload)
            assetManager.preloadAsset(asset, filename);
        else
            assetManager.addAsset(asset, filename);
        return asset;
    }

    /**
     * Adds an asset of type `T` by filename, optionally preloading.
     *
     * Params:
     *   filename = The asset filename.
     *   preload  = If true, preload the asset immediately.
     * Returns:
     *   The loaded or newly created asset of type `T`.
     */
    T addAssetAs(T)(string filename, bool preload = false)
    {
        T newAsset;
        if (assetManager.assetExists(filename))
        {
            newAsset = cast(T)assetManager.getAsset(filename);
        }
        else
        {
            newAsset = New!T(assetManager);
            addAsset(newAsset, filename, preload);
        }
        return newAsset;
    }

    /// Adds a texture asset by filename.
    alias addTextureAsset = addAssetAs!TextureAsset;

    /// Adds an OBJ mesh asset by filename.
    alias addOBJAsset = addAssetAs!OBJAsset;

    /// Adds a GLTF mesh asset by filename.
    alias addGLTFAsset = addAssetAs!GLTFAsset;

    /// Adds a text asset by filename.
    alias addTextAsset = addAssetAs!TextAsset;

    /// Adds a binary asset by filename.
    alias addBinaryAsset = addAssetAs!BinaryAsset;

    /// Creates and adds a new material.
    Material addMaterial()
    {
        return New!Material(assetManager);
    }

    /// Creates and adds a new decal material (transparent, no depth write, no culling).
    Material addDecalMaterial()
    {
        auto mat = addMaterial();
        mat.blendMode = Transparent;
        mat.depthWrite = false;
        mat.useCulling = false;
        return mat;
    }

    /// Creates and adds a new entity, optionally with a parent.
    Entity addEntity(Entity parent = null)
    {
        Entity e = New!Entity(world);
        if (parent)
            e.setParent(parent);
        return e;
    }

    /// Adds an existing entity to the world.
    Entity useEntity(Entity e)
    {
        world.add(e);
        return e;
    }

    /// Creates and adds a new HUD entity (foreground layer), optionally with a parent.
    Entity addEntityHUD(Entity parent = null)
    {
        Entity e = New!Entity(world);
        e.layer = EntityLayer.Foreground;
        if (parent)
            e.setParent(parent);
        return e;
    }

    /// Creates and adds a new camera, optionally with a parent.
    Camera addCamera(Entity parent = null)
    {
        Camera c = New!Camera(world);
        if (parent)
            c.setParent(parent);
        return c;
    }

    /// Creates and adds a new light of the given type, optionally with a parent.
    Light addLight(LightType type, Entity parent = null)
    {
        Light light = New!Light(world);
        if (parent)
            light.setParent(parent);
        light.type = type;
        return light;
    }

    /// Creates and adds a new decal entity, optionally with a parent.
    Entity addDecal(Entity parent = null)
    {
        Entity e = New!Entity(world);
        e.decal = true;
        e.drawable = decalShape;
        if (parent)
            e.setParent(parent);
        return e;
    }

    /// Override to perform actions before loading assets.
    void beforeLoad()
    {
    }

    /**
     * Override to handle loading progress.
     *
     * Params:
     *   t        = Frame timing information.
     *   progress = Loading progress (0..1).
     */
    void onLoad(Time t, float progress)
    {
    }

    /// Override to perform actions after loading is complete.
    void afterLoad()
    {
    }

    /**
     * Override to update scene logic each frame.
     *
     * Params:
     *   t = Frame timing information.
     */
    void onUpdate(Time t)
    {
    }
    
    /// Override to handle scene reset.
    void onReset()
    {
    }

    /**
     * Updates the scene, processes events, and updates all entities.
     *
     * Params:
     *   t = Frame timing information.
     */
    void update(Time t)
    {
        processEvents(focused && loaded);
        
        if (paused)
            return;
        
        if (!startedLoading)
        {
            startedLoading = true;
            beforeLoad();
            isLoading = true;
            assetManager.loadThreadSafePart();
        }
        else if (isLoading)
        {
            onLoad(t, assetManager.nextLoadingPercentage);
            isLoading = assetManager.isLoading;
        }
        else
        {
            if (!loaded)
            {
                assetManager.loadThreadUnsafePart();
                loaded = true;
                afterLoad();
                onLoad(t, 1.0f);
                canRender = true;
            }
            
            onUpdate(t);

            foreach(e; world)
            {
                e.update(t);
            }
        }
    }
}
