/*
Copyright (c) 2021-2025 Timur Gafarov, Denis Feklushkin

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * GLTF 2.0 decoder.
 *
 * Description:
 * The `dagon.resource.gltf.decoder` module defines the `GLTFAsset` class
 * for parsing and managing GLTF 2.0 scenes, meshes, materials,
 * textures, skins, and animations. The loader supports threaded loading,
 * base64 and bufferView image decoding, PBR material parsing, node hierarchy,
 * skinning, and animation channels. The module also provides utility
 * functions for converting JSON values to Dagon math types, and for querying
 * loaded GLTF resources by names.
 *
 * Copyright: Timur Gafarov, Denis Feklushkin 2021-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov, Denis Feklushkin
 */
module dagon.resource.gltf.decoder;

import std.stdio;
import std.math;
import std.path;
import std.algorithm;
import std.base64;
import dlib.core.memory;
import dlib.core.ownership;
import dlib.core.stream;
import dlib.filesystem.filesystem;
import dlib.container.array;
import dlib.serialization.json;
import dlib.text.str;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.transformation;
import dlib.math.quaternion;
import dlib.geometry.triangle;
import dlib.image.color;
import dlib.image.image;

import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;
import dagon.core.logger;
import dagon.resource.asset;
import dagon.resource.texture;
import dagon.graphics.texture;
import dagon.graphics.material;
import dagon.graphics.mesh;
import dagon.graphics.entity;

import dagon.resource.gltf.buffer;
import dagon.resource.gltf.bufferview;
import dagon.resource.gltf.accessor;
import dagon.resource.gltf.meshprimitive;
import dagon.resource.gltf.mesh;
import dagon.resource.gltf.node;
import dagon.resource.gltf.skin;
import dagon.resource.gltf.animation;

/**
 * Converts a JSON array value to a `Vector3f`.
 *
 * Params:
 *   value = The JSON value.
 * Returns:
 *   The corresponding vector.
 */
Vector3f asVector(JSONValue value)
{
    Vector3f vec = Vector3f(0.0f, 0.0f, 0.0f);
    foreach(i, v; value.asArray)
        vec[i] = v.asNumber;
    return vec;
}

/**
 * Converts a JSON array value to a `Matrix4x4f`.
 *
 * Params:
 *   value = The JSON value.
 * Returns:
 *   The corresponding matrix.
 */
Matrix4x4f asMatrix(JSONValue value)
{
    Matrix4x4f mat = Matrix4x4f.identity;
    foreach(i, v; value.asArray)
        mat[i] = v.asNumber;
    return mat;
}

/**
 * Converts a JSON array value to a `Quaternionf`.
 *
 * Params:
 *   value = The JSON value.
 * Returns:
 *   The corresponding quaternion.
 */
Quaternionf asQuaternion(JSONValue value)
{
    Quaternionf q = Quaternionf.identity;
    foreach(i, v; value.asArray)
        q[i] = v.asNumber;
    return q;
}

/**
 * Converts a JSON array value to a `Color4f`.
 *
 * Params:
 *   value = The JSON value.
 * Returns:
 *   The corresponding color.
 */
Color4f asColor(JSONValue value)
{
    Color4f col = Color4f(1.0f, 1.0f, 1.0f, 1.0f);
    foreach(i, v; value.asArray)
        col[i] = v.asNumber;
    return col;
}

/**
 * Represents a GLTF scene, containing a set of root nodes.
 */
class GLTFScene: Owner
{
    /// Scene name.
    string name;

    /// Root nodes in the scene.
    Array!GLTFNode nodes;
    
    this(Owner o)
    {
        super(o);
    }
    
    ~this()
    {
        nodes.free();
    }
}

/**
 * Asset class for loading and managing GLTF 2.0 resources.
 *
 * Description:
 * Loads buffers, buffer views, accessors, images, textures,
 * materials, meshes, nodes, skins, animations, and scenes
 * from a *.gltf + *.bin pair.
 * *.glb files are not supported.
 */
class GLTFAsset: Asset, TriangleSet
{
    AssetManager assetManager;
    String str;
    JSONDocument doc;
    Array!GLTFBuffer buffers;
    Array!GLTFBufferView bufferViews;
    Array!GLTFAccessor accessors;
    Array!GLTFMesh meshes;
    Array!TextureAsset images;
    Array!Texture textures;
    Array!Material materials;
    Array!GLTFNode nodes;
    Array!GLTFSkin skins;
    Array!GLTFAnimation animations;
    Array!GLTFScene scenes;
    Entity rootEntity;
    
    this(Owner o)
    {
        super(o);
    }
    
    ~this()
    {
        release();
    }
    
    /**
     * Loads the thread-safe part of the GLTF asset (parsing JSON, loading buffers, images, etc.).
     *
     * Params:
     *   filename = The GLTF filename.
     *   istrm    = Input stream for the GLTF file.
     *   fs       = File system.
     *   mngr     = Asset manager.
     * Returns:
     *   true if loading succeeded.
     */
    override bool loadThreadSafePart(string filename, InputStream istrm, ReadOnlyFileSystem fs, AssetManager mngr)
    {
        debug logDebug("Loading ", filename);
        assetManager = mngr;
        rootEntity = New!Entity(this);
        string rootDir = dirName(filename);
        str = String(istrm);
        doc = New!JSONDocument(str.toString);
        loadBuffers(doc.root, fs, rootDir);
        loadBufferViews(doc.root);
        loadAccessors(doc.root);
        loadImages(doc.root, fs, rootDir);
        loadTextures(doc.root);
        loadMaterials(doc.root);
        loadMeshes(doc.root);
        loadNodes(doc.root);
        loadSkins(doc.root);
        loadAnimations(doc.root);
        loadScenes(doc.root);
        return true;
    }
    
    void loadBuffers(JSONValue root, ReadOnlyFileSystem fs, string rootDir)
    {
        debug logDebug("Loading buffers...");
        if ("buffers" in root.asObject)
        {
            foreach(buffer; root.asObject["buffers"].asArray)
            {
                auto buf = buffer.asObject;
                if ("uri" in buf)
                {
                    string uri = buf["uri"].asString;
                    string base64Prefix = "data:application/octet-stream;base64,";
                    
                    GLTFBuffer b = New!GLTFBuffer(this);
                    
                    if (uri.startsWith(base64Prefix))
                    {
                        auto encoded = uri[base64Prefix.length..$];
                        b.fromBase64(encoded);
                    }
                    else
                    {
                        String bufFilename = String(rootDir);
                        bufFilename ~= "/";
                        bufFilename ~= buf["uri"].asString;
                        b.fromFile(fs, bufFilename.toString);
                        bufFilename.free();
                    }
                    
                    buffers.insertBack(b);
                }
            }
        }
    }
    
    void loadBufferViews(JSONValue root)
    {
        debug logDebug("Loading bufferViews...");
        if ("bufferViews" in root.asObject)
        {
            foreach(bufferView; root.asObject["bufferViews"].asArray)
            {
                auto bv = bufferView.asObject;
                uint bufferIndex = 0;
                uint byteOffset = 0;
                uint byteLength = 0;
                uint byteStride = 0;
                GLenum target = GL_ARRAY_BUFFER;
                
                if ("buffer" in bv)
                    bufferIndex = cast(uint)bv["buffer"].asNumber;
                if ("byteOffset" in bv)
                    byteOffset = cast(uint)bv["byteOffset"].asNumber;
                if ("byteLength" in bv)
                    byteLength = cast(uint)bv["byteLength"].asNumber;
                if ("byteStride" in bv)
                    byteStride = cast(uint)bv["byteStride"].asNumber;
                if ("target" in bv)
                    target = cast(GLenum)bv["target"].asNumber;
                
                if (bufferIndex < buffers.length)
                {
                    GLTFBufferView bufv = New!GLTFBufferView(buffers[bufferIndex], byteOffset, byteLength, byteStride, target, this);
                    bufferViews.insertBack(bufv);
                }
                else
                {
                    logError("Can't create buffer view for nonexistent buffer ", bufferIndex);
                    GLTFBufferView bufv = New!GLTFBufferView(null, 0, 0, 0, 0, this);
                    bufferViews.insertBack(bufv);
                }
            }
        }
    }
    
    void loadAccessors(JSONValue root)
    {
        debug logDebug("Loading accessors...");
        if ("accessors" in root.asObject)
        {
            foreach(i, accessor; root.asObject["accessors"].asArray)
            {
                auto acc = accessor.asObject;
                uint bufferViewIndex = 0;
                GLenum componentType = GL_FLOAT;
                string type;
                uint count = 0;
                uint byteOffset = 0;
                
                if ("bufferView" in acc)
                    bufferViewIndex = cast(uint)acc["bufferView"].asNumber;
                if ("componentType" in acc)
                    componentType = cast(GLenum)acc["componentType"].asNumber;
                if ("type" in acc)
                    type = acc["type"].asString;
                if ("count" in acc)
                    count = cast(uint)acc["count"].asNumber;
                if ("byteOffset" in acc)
                    byteOffset = cast(uint)acc["byteOffset"].asNumber;
                
                GLTFDataType dataType = GLTFDataType.Undefined;
                if (type == "SCALAR")
                    dataType = GLTFDataType.Scalar;
                else if (type == "VEC2")
                    dataType = GLTFDataType.Vec2;
                else if (type == "VEC3")
                    dataType = GLTFDataType.Vec3;
                else if (type == "VEC4")
                    dataType = GLTFDataType.Vec4;
                else if (type == "MAT2")
                    dataType = GLTFDataType.Mat2;
                else if (type == "MAT3")
                    dataType = GLTFDataType.Mat3;
                else if (type == "MAT4")
                    dataType = GLTFDataType.Mat4;
                else
                    logError("Unsupported data type for accessor ", i);
                
                if (bufferViewIndex < bufferViews.length)
                {
                    GLTFAccessor ac = New!GLTFAccessor(bufferViews[bufferViewIndex], dataType, componentType, count, byteOffset, this);
                    accessors.insertBack(ac);
                }
                else
                {
                    logError("Can't create accessor for nonexistent buffer view ", bufferViewIndex);
                    GLTFAccessor ac = New!GLTFAccessor(null, dataType, componentType, count, byteOffset, this);
                    accessors.insertBack(ac);
                }
            }
        }
    }
    
    void loadImages(JSONValue root, ReadOnlyFileSystem fs, string rootDir)
    {
        debug logDebug("Loading images...");
        if ("images" in root.asObject)
        {
            foreach(i, img; root.asObject["images"].asArray)
            {
                auto im = img.asObject;
                
                if ("uri" in im)
                {
                    string uri = im["uri"].asString;
                    TextureAsset textureAsset = New!TextureAsset(assetManager);
                    
                    ImageFormatInfo info = assetManager.detectBase64Image(uri);
                    if (info.format.length)
                    {
                        auto encoded = uri[info.prefix.length..$];
                        auto decodedLength = Base64.decodeLength(encoded.length);
                        auto array = New!(ubyte[])(decodedLength);
                        auto decoded = Base64.decode(encoded, array);
                        bool res = assetManager.loadAssetThreadSafePart(textureAsset, decoded, info.dummyFilename);
                        if (!res)
                            logError("Failed to load Base64-encoded image");
                        Delete(array);
                    }
                    else
                    {
                        String imgFilename = String(rootDir);
                        imgFilename ~= "/";
                        imgFilename ~= uri;
                        string assetFilename = imgFilename.toString;
                        
                        FileStat fstat;
                        if (fs.stat(assetFilename, fstat))
                        {
                            bool res = assetManager.loadAssetThreadSafePart(textureAsset, assetFilename);
                            if (!res)
                                logError("Failed to load \"", imgFilename, "\"");
                        }
                        else
                            logError("Image file \"", imgFilename, "\" not found");
                        
                        imgFilename.free();
                    }
                    
                    images.insertBack(textureAsset);
                }
                else if ("bufferView" in im)
                {
                    uint bufferViewIndex = cast(uint)im["bufferView"].asNumber;
                    
                    auto textureAsset = New!TextureAsset(this);
                    
                    if (bufferViewIndex < bufferViews.length)
                    {
                        auto bv = bufferViews[bufferViewIndex];
                        string mimeType = "";
                        if ("mimeType" in im)
                            mimeType = im["mimeType"].asString;
                        if (mimeType == "")
                            logError("Image MIME type missing");
                        else
                        {
                            string name = nameFromMimeType(mimeType);
                            if (name == "")
                                logError("Unsupported image MIME type ", mimeType);
                            else
                            {
                                
                                bool res = assetManager.loadAssetThreadSafePart(textureAsset, bv.slice, name);
                                if (!res)
                                    logError("Failed to load image");
                            }
                        }
                    }
                    else
                    {
                        logError("Can't create image from nonexistent buffer view ", bufferViewIndex);
                    }
                    
                    images.insertBack(textureAsset);
                }
            }
        }
    }
    
    // TODO: loadSamplers
    
    void loadTextures(JSONValue root)
    {
        debug logDebug("Loading textures...");
        if ("textures" in root.asObject)
        {
            foreach(i, tex; root.asObject["textures"].asArray)
            {
                auto te = tex.asObject;
                
                if ("source" in te)
                {
                    uint imageIndex = cast(uint)te["source"].asNumber;
                    TextureAsset img;
                    if (imageIndex < images.length)
                        img = images[imageIndex];
                    else
                        logError("Can't create texture for nonexistent image ", imageIndex);
                    
                    if (img !is null)
                    {
                        Texture texture = img.texture;
                        textures.insertBack(texture);
                    }
                    else
                    {
                        Texture texture;
                        textures.insertBack(texture);
                    }
                }
                
                // TODO: sampler
            }
        }
    }
    
    void loadMaterials(JSONValue root)
    {
        debug logDebug("Loading materials...");
        if ("materials" in root.asObject)
        {
            foreach(i, mat; root.asObject["materials"].asArray)
            {
                auto ma = mat.asObject;
                
                Material material = New!Material(this);
                
                if ("name" in ma)
                {
                    material.name = ma["name"].asString;
                }
                
                if ("pbrMetallicRoughness" in ma)
                {
                    auto pbr = ma["pbrMetallicRoughness"].asObject;
                    
                    Color4f baseColorFactor = Color4f(1.0f, 1.0f, 1.0f, 1.0f);
                    if (pbr && "baseColorFactor" in pbr)
                    {
                        baseColorFactor = pbr["baseColorFactor"].asColor;
                        
                        if (baseColorFactor.a < 1.0f)
                            material.blendMode = Transparent;
                        
                        material.baseColorFactor = baseColorFactor;
                    }
                    
                    if (pbr && "baseColorTexture" in pbr)
                    {
                        auto bct = pbr["baseColorTexture"].asObject;
                        if ("index" in bct)
                        {
                            uint baseColorTexIndex = cast(uint)bct["index"].asNumber;
                            if (baseColorTexIndex < textures.length)
                            {
                                Texture baseColorTex = textures[baseColorTexIndex];
                                if (baseColorTex)
                                {
                                    material.baseColorTexture = baseColorTex;
                                }
                            }
                        }
                        
                        material.opacity = baseColorFactor.a;
                    }
                    
                    if (pbr && "metallicRoughnessTexture" in pbr)
                    {
                        uint metallicRoughnessTexIndex = cast(uint)pbr["metallicRoughnessTexture"].asObject["index"].asNumber;
                        if (metallicRoughnessTexIndex < textures.length)
                        {
                            Texture metallicRoughnessTex = textures[metallicRoughnessTexIndex];
                            if (metallicRoughnessTex)
                                material.roughnessMetallicTexture = metallicRoughnessTex;
                        }
                    }
                    else
                    {
                        if (pbr && "metallicFactor" in pbr)
                            material.metallicFactor = pbr["metallicFactor"].asNumber;
                        else
                            material.metallicFactor = 1.0f;
                        
                        if (pbr && "roughnessFactor" in pbr)
                            material.roughnessFactor = pbr["roughnessFactor"].asNumber;
                        else
                            material.roughnessFactor = 1.0f;
                    }
                }
                else if ("extensions" in ma)
                {
                    auto extensions = ma["extensions"].asObject;
                    
                    if ("KHR_materials_pbrSpecularGlossiness" in extensions)
                    {
                        auto pbr = extensions["KHR_materials_pbrSpecularGlossiness"].asObject;
                        
                        if (pbr && "diffuseTexture" in pbr)
                        {
                            auto dt = pbr["diffuseTexture"].asObject;
                            if ("index" in dt)
                            {
                                uint diffuseTexIndex = cast(uint)dt["index"].asNumber;
                                if (diffuseTexIndex < textures.length)
                                {
                                    Texture diffuseTex = textures[diffuseTexIndex];
                                    if (diffuseTex)
                                        material.baseColorTexture = diffuseTex;
                                }
                            }
                        }
                    }
                }
                
                if ("normalTexture" in ma)
                {
                    uint normalTexIndex = cast(uint)ma["normalTexture"].asObject["index"].asNumber;
                    if (normalTexIndex < textures.length)
                    {
                        Texture normalTex = textures[normalTexIndex];
                        if (normalTex)
                            material.normalTexture = normalTex;
                    }
                }
                
                if ("emissiveTexture" in ma)
                {
                    uint emissiveTexIndex = cast(uint)ma["emissiveTexture"].asObject["index"].asNumber;
                    if (emissiveTexIndex < textures.length)
                    {
                        Texture emissiveTex = textures[emissiveTexIndex];
                        if (emissiveTex)
                            material.emissionTexture = emissiveTex;
                    }
                }
                
                if ("emissiveFactor" in ma)
                {
                    Color4f emissiveFactor = ma["emissiveFactor"].asColor;
                    material.emissionFactor = emissiveFactor;
                }
                
                if ("extensions" in ma)
                {
                    auto extensions = ma["extensions"].asObject;
                    
                    if ("KHR_materials_emissive_strength" in extensions)
                    {
                        auto khrEmissiveStrength = extensions["KHR_materials_emissive_strength"].asObject;
                        if (khrEmissiveStrength && "emissiveStrength" in khrEmissiveStrength)
                            material.emissionEnergy = khrEmissiveStrength["emissiveStrength"].asNumber;
                    }
                }
                
                if ("doubleSided" in ma)
                {
                    uint doubleSided = cast(uint)ma["doubleSided"].asNumber;
                    if (doubleSided > 0)
                        material.useCulling = false;
                    else
                        material.useCulling = true;
                }
                else
                    material.useCulling = true;
                
                if ("alphaMode" in ma)
                {
                    auto alphaMode = ma["alphaMode"].asString;
                    if (alphaMode == "BLEND")
                        material.blendMode = Transparent;
                }
                
                if ("alphaCutoff" in ma)
                    material.alphaTestThreshold = ma["alphaCutoff"].asNumber;
                
                materials.insertBack(material);
            }
        }
    }
    
    void loadMeshes(JSONValue root)
    {
        debug logDebug("Loading meshes...");
        if ("meshes" in root.asObject)
        {
            foreach(i, mesh; root.asObject["meshes"].asArray)
            {
                auto m = mesh.asObject;
                
                GLTFMesh me = New!GLTFMesh(this);
                
                if ("name" in m)
                    me.name = m["name"].asString;
                
                if ("primitives" in m)
                {
                    foreach(prim; m["primitives"].asArray)
                    {
                        auto p = prim.asObject;
                        
                        GLTFAccessor positionAccessor;
                        GLTFAccessor normalAccessor;
                        GLTFAccessor texCoord0Accessor;
                        GLTFAccessor joints0Accessor;
                        GLTFAccessor weights0Accessor;
                        GLTFAccessor indexAccessor;
                        
                        if ("attributes" in p)
                        {
                            auto attributes = p["attributes"].asObject;
                            
                            if ("POSITION" in attributes)
                            {
                                uint positionsAccessorIndex = cast(uint)attributes["POSITION"].asNumber;
                                if (positionsAccessorIndex < accessors.length)
                                    positionAccessor = accessors[positionsAccessorIndex];
                                else
                                    logError("Can't create position attributes for nonexistent accessor ", positionsAccessorIndex);
                            }
                            
                            if ("NORMAL" in attributes)
                            {
                                uint normalsAccessorIndex = cast(uint)attributes["NORMAL"].asNumber;
                                if (normalsAccessorIndex < accessors.length)
                                    normalAccessor = accessors[normalsAccessorIndex];
                                else
                                    logError("Can't create normal attributes for nonexistent accessor ", normalsAccessorIndex);
                            }
                            
                            if ("TEXCOORD_0" in attributes)
                            {
                                uint texCoord0AccessorIndex = cast(uint)attributes["TEXCOORD_0"].asNumber;
                                if (texCoord0AccessorIndex < accessors.length)
                                    texCoord0Accessor = accessors[texCoord0AccessorIndex];
                                else
                                    logError("Can't create texCoord0 attributes for nonexistent accessor ", texCoord0AccessorIndex);
                            }
                            
                            if ("JOINTS_0" in attributes)
                            {
                                uint joints0AccessorIndex = cast(uint)attributes["JOINTS_0"].asNumber;
                                if (joints0AccessorIndex < accessors.length)
                                    joints0Accessor = accessors[joints0AccessorIndex];
                                else
                                    logError("Can't create joints0 attributes for nonexistent accessor ", joints0AccessorIndex);
                            }
                            
                            if ("WEIGHTS_0" in attributes)
                            {
                                uint weights0AccessorIndex = cast(uint)attributes["WEIGHTS_0"].asNumber;
                                if (weights0AccessorIndex < accessors.length)
                                    weights0Accessor = accessors[weights0AccessorIndex];
                                else
                                    logError("Can't create weights0 attributes for nonexistent accessor ", weights0AccessorIndex);
                            }
                        }
                        
                        if ("indices" in p)
                        {
                            uint indicesAccessorIndex = cast(uint)p["indices"].asNumber;
                            if (indicesAccessorIndex < accessors.length)
                                indexAccessor = accessors[indicesAccessorIndex];
                            else
                                logError("Can't create indices for nonexistent accessor ", indicesAccessorIndex);
                        }
                        
                        Material material;
                        if ("material" in p)
                        {
                            uint materialIndex = cast(uint)p["material"].asNumber;
                            if (materialIndex < materials.length)
                                material = materials[materialIndex];
                            else
                                logError("Nonexistent material ", materialIndex);
                        }
                        
                        if (positionAccessor is null)
                            logWarning("Mesh ", i, " lacks vertex position attributes");
                        
                        if (normalAccessor is null)
                            logWarning("Mesh ", i, " lacks vertex normal attributes");
                        
                        if (texCoord0Accessor is null)
                            logWarning("Mesh ", i, " lacks vertex texCoord0 attributes");
                        
                        if (indexAccessor is null)
                            logWarning("Mesh ", i, " lacks indices");
                        
                        GLTFMeshPrimitive pr = New!GLTFMeshPrimitive(this);
                        pr.positionAccessor = positionAccessor;
                        pr.normalAccessor = normalAccessor;
                        pr.texCoord0Accessor = texCoord0Accessor;
                        pr.joints0Accessor = joints0Accessor;
                        pr.weights0Accessor = weights0Accessor;
                        pr.indexAccessor = indexAccessor;
                        pr.material = material;
                        
                        me.primitives.insertBack(pr);
                    }
                }
                
                meshes.insertBack(me);
            }
        }
    }
    
    void loadNodes(JSONValue root)
    {
        debug logDebug("Loading nodes...");
        if ("nodes" in root.asObject)
        {
            foreach(i, n; root.asObject["nodes"].asArray)
            {
                auto node = n.asObject;
                
                GLTFNode nodeObj = New!GLTFNode(this);
                nodeObj.entity.setParent(rootEntity);
                
                if ("name" in node)
                    nodeObj.name = node["name"].asString;
                
                if ("mesh" in node)
                {
                    uint meshIndex = cast(uint)node["mesh"].asNumber;
                    if (meshIndex < meshes.length)
                    {
                        GLTFMesh mesh = meshes[meshIndex];
                        nodeObj.mesh = mesh;
                        nodeObj.entity.drawable = mesh;
                    }
                    else
                        logError("Mesh ", meshIndex, " doesn't exist");
                }
                
                if ("extensions" in node)
                {
                    auto nodeExt = node["extensions"].asObject;
                    if ("KHR_lights_punctual" in nodeExt)
                    {
                        logWarning("KHR_lights_punctual is not supported");
                    }
                }
                
                if ("matrix" in node)
                {
                    nodeObj.transformMode = TransformMode.Matrix;
                    nodeObj.localTransform = node["matrix"].asMatrix;
                    nodeObj.bindPoseTransform = nodeObj.localTransform;
                    
                    nodeObj.entity.transformMode = TransformMode.Matrix;
                    nodeObj.entity.transformation = nodeObj.localTransform;
                }
                else
                {
                    nodeObj.transformMode = TransformMode.TRS;
                    
                    Vector3f position = Vector3f(0.0f, 0.0f, 0.0f);
                    Quaternionf rotation = Quaternionf.identity;
                    Vector3f scaling = Vector3f(1.0f, 1.0f, 1.0f);
                    
                    if ("translation" in node)
                        position = node["translation"].asVector;
                    if ("rotation" in node)
                        rotation = node["rotation"].asQuaternion;
                    if ("scale" in node)
                        scaling = node["scale"].asVector;
                    
                    nodeObj.bindPosePosition = position;
                    nodeObj.bindPoseRotation = rotation;
                    nodeObj.bindPoseScaling = scaling;
                    nodeObj.updateBindPoseTransform();
                    
                    nodeObj.position = position;
                    nodeObj.rotation = rotation;
                    nodeObj.scaling = scaling;
                    nodeObj.updateLocalTransform();
                    
                    nodeObj.entity.transformMode = TransformMode.TRS;
                    nodeObj.entity.position = position;
                    nodeObj.entity.rotation = rotation;
                    nodeObj.entity.scaling = scaling;
                }
                
                if ("children" in node)
                {
                    auto children = node["children"].asArray;
                    nodeObj.childrenIndices = New!(size_t[])(children.length);
                    
                    foreach(ci, c; children)
                    {
                        uint childIndex = cast(uint)c.asNumber;
                        nodeObj.childrenIndices[ci] = childIndex;
                    }
                }
                
                if ("skin" in node)
                    nodeObj.skinIndex = cast(int)node["skin"].asNumber;
                
                nodeObj.index = nodes.length;
                
                nodes.insertBack(nodeObj);
            }
        }
        
        foreach(node; nodes)
        {
            if (node.childrenIndices.length)
            {
                node.children = New!(GLTFNode[])(node.childrenIndices.length);
                
                foreach(i, childIndex; node.childrenIndices)
                {
                    GLTFNode child = nodes[childIndex];
                    child.parent = node;
                    node.children[i] = child;
                    node.entity.addChild(child.entity);
                }
            }
        }
        
        rootEntity.updateTransformationTopDown();
    }
    
    void loadSkins(JSONValue root)
    {
        debug logDebug("Loading skins...");
        if ("skins" in root.asObject)
        {
            foreach(i, s; root.asObject["skins"].asArray)
            {
                auto skin = s.asObject;
                
                GLTFSkin skinObj = New!GLTFSkin(this);
                
                if ("name" in skin)
                    skinObj.name = skin["name"].asString;
                
                if ("joints" in skin)
                {
                    foreach(ni, n; skin["joints"].asArray)
                    {
                        uint nodeIndex = cast(uint)n.asNumber;
                        if (nodeIndex < nodes.length)
                            skinObj.joints.insertBack(nodes[nodeIndex]);
                    }
                }
                
                if ("inverseBindMatrices" in skin)
                {
                    GLTFAccessor invBindMatricesAccessor;
                    uint invBindMatricesAccessorIndex = cast(uint)skin["inverseBindMatrices"].asNumber;
                    if (invBindMatricesAccessorIndex < accessors.length)
                        invBindMatricesAccessor = accessors[invBindMatricesAccessorIndex];
                    else
                        logError("Nonexistent accessor ", invBindMatricesAccessorIndex);
                    
                    skinObj.invBindMatricesAccessor = invBindMatricesAccessor;
                    
                    if (skinObj.invBindMatricesAccessor.count > 0)
                        skinObj.invBindMatrices = skinObj.invBindMatricesAccessor.getSlice!Matrix4x4f;
                }
                
                skins.insertBack(skinObj);
            }
        }
        
        foreach(node; nodes)
        {
            if (node.skinIndex >= 0)
            {
                node.skin = skins[cast(size_t)node.skinIndex];
                
                if (node.parent !is null)
                {
                    logWarning("A node with a skinned mesh should be a root node");
                }
            }
        }
    }
    
    void loadAnimations(JSONValue root)
    {
        debug logDebug("Loading animations...");
        
        auto animationsArr = ("animations" in root.asObject);

        if (animationsArr !is null)
        {
            foreach(i, animation; animationsArr.asArray)
            {
                auto animationObj = New!GLTFAnimation(this);
                scope(exit) animations.insertBack(animationObj);
                
                auto name = ("name" in animation.asObject);
                if (name !is null)
                    animationObj.name = name.asString;

                auto samplers = ("samplers" in animation.asObject);
                if (samplers !is null)
                {
                    foreach(i, s; samplers.asArray)
                    {
                        auto sampler = s.asObject;
                        GLTFAnimationSampler samplerObj = New!GLTFAnimationSampler(this);
                        auto interp = "interpolation" in sampler;
                        if (interp !is null)
                            samplerObj.interpolation = cast(InterpolationType)interp.asString;
                        else
                            samplerObj.interpolation = InterpolationType.Linear;
                        checkAndGetAccessor(samplerObj.input, sampler["input"].asUint);
                        checkAndGetAccessor(samplerObj.output, sampler["output"].asUint);
                        animationObj.samplers.insertBack(samplerObj);
                    }
                }

                auto channels = ("channels" in animation.asObject);
                if (channels !is null)
                {
                    foreach(i, ch; channels.asArray)
                    {
                        auto channelObj = New!GLTFAnimationChannel(this);
                        scope(exit) animationObj.channels.insertBack(channelObj);

                        auto channel = ch.asObject;

                        const samplerIdx = channel["sampler"].asUint;
                        if (samplerIdx < animationObj.samplers.length)
                            channelObj.sampler = animationObj.samplers[samplerIdx];
                        else
                            logError("Nonexistent animation sampler ", samplerIdx);

                        auto target = ("target" in channel);
                        if (target is null)
                            logError("Nonexistent animation target object");
                        else
                        {
                            channelObj.targetPath = cast(TRSType)target.asObject["path"].asString;

                            auto node = ("node" in target.asObject);
                            if (node !is null)
                            {
                                const idx = (*node).asUint;

                                if (idx < nodes.length)
                                    channelObj.targetNode = nodes[idx];
                                else
                                    logError("Nonexistent target node");
                            }
                        }
                    }
                }
            }
        }
    }

    private void checkAndGetAccessor(ref GLTFAccessor a, uint idx)
    {
        if (idx < accessors.length)
            a = accessors[idx];
        else
            logError("Nonexistent accessor ", idx);
    }

    void loadScenes(JSONValue root)
    {
        debug logDebug("Loading scenes...");
        if ("scenes" in root.asObject)
        {
            foreach(i, s; root.asObject["scenes"].asArray)
            {
                auto scene = s.asObject;
                
                GLTFScene sceneObj = New!GLTFScene(this);
                
                if ("name" in scene)
                    sceneObj.name = scene["name"].asString;
                
                if ("nodes" in scene)
                {
                    foreach(ni, n; scene["nodes"].asArray)
                    {
                        uint nodeIndex = cast(uint)n.asNumber;
                        if (nodeIndex < nodes.length)
                            sceneObj.nodes.insertBack(nodes[nodeIndex]);
                    }
                }
                
                scenes.insertBack(sceneObj);
            }
        }
    }
    
    /// Loads the thread-unsafe part (OpenGL resource creation).
    override bool loadThreadUnsafePart()
    {
        foreach(me; meshes)
        {
            foreach(p; me.primitives)
                p.prepareVAO();
        }
        
        foreach(img; images)
        {
            img.loadThreadUnsafePart();
        }
        
        return true;
    }
    
    /// Marks entities as transparent if their material uses transparency.
    void markTransparentEntities()
    {
        foreach(node; nodes)
        {
            if (node.mesh)
            {
                foreach(primitive; node.mesh.primitives)
                {
                    Material material = primitive.material;
                    if (material)
                    {
                        if (material.blendMode == Transparent)
                            node.entity.transparent = true;
                    }
                }
            }
        }
    }
    
    /// Releases all resources associated with the asset.
    override void release()
    {
        foreach(b; buffers)
            deleteOwnedObject(b);
        buffers.free();
        
        foreach(bv; bufferViews)
            deleteOwnedObject(bv);
        bufferViews.free();
        
        foreach(ac; accessors)
            deleteOwnedObject(ac);
        accessors.free();
        
        foreach(me; meshes)
            deleteOwnedObject(me);
        meshes.free();
        
        foreach(im; images)
            deleteOwnedObject(im);
        images.free();
        
        foreach(no; nodes)
            deleteOwnedObject(no);
        nodes.free();
        
        foreach(sko; skins)
            deleteOwnedObject(sko);
        skins.free();
        
        foreach(sc; scenes)
            deleteOwnedObject(sc);
        scenes.free();
        
        foreach(an; animations)
            deleteOwnedObject(an);
        animations.free();

        textures.free();
        materials.free();
        
        Delete(doc);
        str.free();
    }
    
    /**
     * Iterates over all triangles in the nodes.
     *
     * Params:
     *   dg = Delegate to call for each triangle.
     * Returns:
     *   0 if completed, nonzero if interrupted.
     */
    int opApply(scope int delegate(Triangle t) dg)
    {
        int result = 0;
        
        foreach(node; nodes)
        {
            if (node.mesh)
            {
                foreach(primitive; node.mesh.primitives)
                {
                    GLTFAccessor pa = primitive.positionAccessor;
                    GLTFAccessor na = primitive.normalAccessor;
                    GLTFAccessor ia = primitive.indexAccessor;
                    
                    Vector3f* positions = cast(Vector3f*)(pa.bufferView.slice.ptr + pa.byteOffset);
                    size_t numPositions = pa.count;
                    
                    Vector3f* normals = cast(Vector3f*)(na.bufferView.slice.ptr + na.byteOffset);
                    size_t numNormals = na.count;
                    
                    ubyte* indicesStart = ia.bufferView.slice.ptr + ia.byteOffset;
                    size_t numTriangles = ia.count / 3;

                    size_t indexStride;
                    if (ia.componentType == GL_UNSIGNED_BYTE)
                        indexStride = 1;
                    else if (ia.componentType == GL_UNSIGNED_SHORT)
                        indexStride = 2;
                    else if (ia.componentType == GL_UNSIGNED_INT)
                        indexStride = 4;
                    
                    foreach(i; 0..numTriangles)
                    {
                        ubyte* ptr = indicesStart + i * 3 * indexStride;
                        
                        size_t[3] indices;
                        if (ia.componentType == GL_UNSIGNED_BYTE)
                        {
                            indices[0] = ptr[0];
                            indices[1] = ptr[1];
                            indices[2] = ptr[2];
                        }
                        else if (ia.componentType == GL_UNSIGNED_SHORT)
                        {
                            indices[0] = *cast(ushort*)ptr;
                            indices[1] = *cast(ushort*)(ptr+2);
                            indices[2] = *cast(ushort*)(ptr+4);
                        }
                        else if (ia.componentType == GL_UNSIGNED_INT)
                        {
                            indices[0] = *cast(uint*)ptr;
                            indices[1] = *cast(uint*)(ptr+4);
                            indices[2] = *cast(uint*)(ptr+8);
                        }

                        auto mat = node.entity.absoluteTransformation;

                        Triangle tri;
                        tri.v[0] = positions[indices[0]] * mat;
                        tri.v[1] = positions[indices[1]] * mat;
                        tri.v[2] = positions[indices[2]] * mat;
                        tri.n[0] = mat.rotate(normals[indices[0]]);
                        tri.n[1] = mat.rotate(normals[indices[1]]);
                        tri.n[2] = mat.rotate(normals[indices[2]]);
                        tri.normal = (tri.n[0] + tri.n[1] + tri.n[2]) / 3.0f;
                        
                        result = dg(tri);
                        if (result)
                            return result;
                    }
                }
            }
        }
        
        return result;
    }
    
    /// Finds a node by name.
    GLTFNode node(string name)
    {
        GLTFNode res;
        
        foreach(i, node; nodes)
        {
            if (node.name == name)
            {
                res = node;
                break;
            }
        }
        
        return res;
    }
    
    /// Finds a material by name.
    Material material(string name)
    {
        Material res;
        
        foreach(i, mat; materials)
        {
            if (mat.name == name)
            {
                res = mat;
                break;
            }
        }
        
        return res;
    }
    
    /// Finds a mesh by name.
    GLTFMesh mesh(string name)
    {
        GLTFMesh res;
        
        foreach(i, mesh; meshes)
        {
            if (mesh.name == name)
            {
                res = mesh;
                break;
            }
        }
        
        return res;
    }
    
    /// Finds a skin by name.
    GLTFSkin skin(string name)
    {
        GLTFSkin res;
        
        foreach(i, skin; skins)
        {
            if (skin.name == name)
            {
                res = skin;
                break;
            }
        }
        
        return res;
    }
    
    /// Finds an animation by name.
    GLTFAnimation animation(string name)
    {
        GLTFAnimation res;
        
        foreach(i, anim; animations)
        {
            if (anim.name == name)
            {
                res = anim;
                break;
            }
        }
        
        return res;
    }
    
    /// Finds a scene by name.
    GLTFScene scene(string name)
    {
        GLTFScene res;
        
        foreach(i, scene; scenes)
        {
            if (scene.name == name)
            {
                res = scene;
                break;
            }
        }
        
        return res;
    }
}

private uint asUint(in JSONValue j)
{
    return cast(uint) j.asNumber;
}

// TODO: generate random name instead of "undefined"
string nameFromMimeType(string mime)
{
    string name;
    switch(mime)
    {
        case "image/jpeg": name = "undefined.jpg"; break;
        case "image/png": name = "undefined.png"; break;
        case "image/tga": name = "undefined.tga"; break;
        case "image/targa": name = "undefined.tga"; break;
        case "image/bmp": name = "undefined.bmp"; break;
        case "image/vnd.radiance": name = "undefined.hdr"; break;
        case "image/x-hdr": name = "undefined.hdr"; break;
        case "image/x-dds": name = "undefined.dds"; break;
        default: name = ""; break;
    }
    return name;
}

/*
void decomposeMatrix(
    Matrix4x4f m,
    out Vector3f position,
    out Quaternionf rotation,
    out Vector3f scale)
{
    position = Vector3f(m[12], m[13], m[14]);
    
    float sx = sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    float sy = sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    float sz = sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);

    if (m.determinant < 0)
        sx = -sx;
    
    scale = Vector3f(sx, sy, sz);
    
    float invSx = 1.0f / sx;
    float invSy = 1.0f / sy;
    float invSz = 1.0f / sz;
    
    Matrix3x3f rotationMatrix = matrixf(
        m[0] * invSx, m[4] * invSy, m[8] * invSz,
        m[1] * invSx, m[5] * invSy, m[9] * invSz,
        m[2] * invSx, m[6] * invSy, m[10] * invSz
    );
    
    rotation = Quaternionf.fromMatrix(matrix3x3to4x4(rotationMatrix));
}
*/
