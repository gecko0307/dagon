/*
Copyright (c) 2021-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * GLTF mesh primitive.
 *
 * Description:
 * The `dagon.resource.gltf.meshprimitive` module defines the `GLTFMeshPrimitive`
 * class, which represents a single mesh primitive in a GLTF mesh.
 * This class manages accessors for vertex attributes (positions, normals,
 * texcoords, joints, weights, indices), OpenGL buffer and VAO creation,
 * and rendering logic. Mesh primitives are used to draw geometry with a specific
 * material and attribute layout, supporting both indexed and non-indexed rendering.
 *
 * Copyright: Timur Gafarov 2021-2025
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dagon.resource.gltf.meshprimitive;

import std.stdio;

import dlib.core.ownership;

import dagon.core.bindings;
import dagon.graphics.drawable;
import dagon.graphics.material;
import dagon.graphics.mesh;
import dagon.graphics.state;
import dagon.resource.gltf.accessor;

/**
 * Represents a single mesh primitive in a GLTF mesh.
 *
 * Description:
 * Manages accessors for vertex attributes, OpenGL buffers,
 * VAO creation, and rendering logic. Supports indexed and non-indexed
 * drawing.
 */
class GLTFMeshPrimitive: Owner, Drawable
{
    /// Accessor for vertex positions.
    GLTFAccessor positionAccessor;

    /// Accessor for vertex normals.
    GLTFAccessor normalAccessor;
    
    /// Accessor for texture coordinates.
    GLTFAccessor texCoord0Accessor;

    /// Accessor for joint indices (skinning).
    GLTFAccessor joints0Accessor;

    /// Accessor for joint weights (skinning).
    GLTFAccessor weights0Accessor;

    /// Accessor for triangle indices.
    GLTFAccessor indexAccessor;

    /// Material used for rendering this primitive.
    Material material;
    
    /// OpenGL vertex array object.
    GLuint vao = 0;

    /// Vertex buffer object.
    GLuint vbo = 0;

    /// Normal buffer object.
    GLuint nbo = 0;

    /// Texture coordinate buffer object.
    GLuint tbo = 0;

    /// Joint buffer object.
    GLuint jbo = 0;

    /// Weight buffer object.
    GLuint wbo = 0;

    /// Element array object.
    GLuint eao = 0;
    
    /// True if the VAO and buffers are ready for rendering.
    bool canRender = false;
    
    /// Flags indicating the presence of vertex positions.
    bool hasPositions = false;

    /// Flags indicating the presence of normals.
    bool hasNormals = false;

    /// Flags indicating the presence of texcoords.
    bool hasTexcoords = false;

    /// Flags indicating the presence of joints.
    bool hasJoints = false;

    /// Flags indicating the presence of weights.
    bool hasWeights = false;

    /// Flags indicating the presence of indices.
    bool hasIndices = false;
    
    /**
     * Constructs a mesh primitive.
     *
     * Params:
     *   owner = Owner object.
     */
    this(Owner owner)
    {
        super(owner);
    }
    
    /**
     * Prepares OpenGL VAO and buffers for rendering.
     * Sets up attribute pointers and uploads vertex/index data.
     */
    void prepareVAO()
    {
        if (positionAccessor && positionAccessor.bufferView)
            hasPositions = positionAccessor.bufferView.slice.length > 0;
        
        if (normalAccessor && normalAccessor.bufferView)
            hasNormals = normalAccessor.bufferView.slice.length > 0;
        
        if (texCoord0Accessor && texCoord0Accessor.bufferView)
            hasTexcoords = texCoord0Accessor.bufferView.slice.length > 0;
        
        if (joints0Accessor && joints0Accessor.bufferView)
            hasJoints = joints0Accessor.bufferView.slice.length > 0;
        
        if (weights0Accessor && weights0Accessor.bufferView)
            hasWeights = weights0Accessor.bufferView.slice.length > 0;
        
        if (indexAccessor && indexAccessor.bufferView)
            hasIndices = indexAccessor.bufferView.slice.length > 0;
        
        if (hasPositions)
        {
            glGenBuffers(1, &vbo);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, positionAccessor.bufferView.slice.length, positionAccessor.bufferView.slice.ptr, GL_STATIC_DRAW); 
        }
        
        if (hasNormals)
        {
            glGenBuffers(1, &nbo);
            glBindBuffer(GL_ARRAY_BUFFER, nbo);
            glBufferData(GL_ARRAY_BUFFER, normalAccessor.bufferView.slice.length, normalAccessor.bufferView.slice.ptr, GL_STATIC_DRAW);
        }
        
        if (hasTexcoords)
        {
            glGenBuffers(1, &tbo);
            glBindBuffer(GL_ARRAY_BUFFER, tbo);
            glBufferData(GL_ARRAY_BUFFER, texCoord0Accessor.bufferView.slice.length, texCoord0Accessor.bufferView.slice.ptr, GL_STATIC_DRAW);
        }
        
        if (hasJoints)
        {
            glGenBuffers(1, &jbo);
            glBindBuffer(GL_ARRAY_BUFFER, jbo);
            glBufferData(GL_ARRAY_BUFFER, joints0Accessor.bufferView.slice.length, joints0Accessor.bufferView.slice.ptr, GL_STATIC_DRAW);
        }
        
        if (hasWeights)
        {
            glGenBuffers(1, &wbo);
            glBindBuffer(GL_ARRAY_BUFFER, wbo);
            glBufferData(GL_ARRAY_BUFFER, weights0Accessor.bufferView.slice.length, weights0Accessor.bufferView.slice.ptr, GL_STATIC_DRAW);
        }
        
        if (hasIndices)
        {
            glGenBuffers(1, &eao);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, indexAccessor.bufferView.slice.length, indexAccessor.bufferView.slice.ptr, GL_STATIC_DRAW);
        }
        
        glGenVertexArrays(1, &vao);
        glBindVertexArray(vao);
        
        if (hasPositions)
        {
            glEnableVertexAttribArray(VertexAttrib.Vertices);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glVertexAttribPointer(VertexAttrib.Vertices,
                positionAccessor.numComponents,
                positionAccessor.componentType,
                GL_FALSE,
                positionAccessor.bufferView.stride,
                cast(void*)positionAccessor.byteOffset);
        }
        else
        {
            glVertexAttrib3f(VertexAttrib.Vertices, 0.0f, 0.0f, 0.0f);
        }
        
        if (hasNormals)
        {
            glEnableVertexAttribArray(VertexAttrib.Normals);
            glBindBuffer(GL_ARRAY_BUFFER, nbo);
            glVertexAttribPointer(VertexAttrib.Normals,
                normalAccessor.numComponents,
                normalAccessor.componentType,
                GL_FALSE,
                normalAccessor.bufferView.stride,
                cast(void*)normalAccessor.byteOffset);
        }
        else
        {
            glVertexAttrib3f(VertexAttrib.Normals, 0.0f, 0.0f, 1.0f);
        }
        
        if (hasTexcoords)
        {
            glEnableVertexAttribArray(VertexAttrib.Texcoords);
            glBindBuffer(GL_ARRAY_BUFFER, tbo);
            glVertexAttribPointer(VertexAttrib.Texcoords,
                texCoord0Accessor.numComponents,
                texCoord0Accessor.componentType,
                GL_FALSE,
                texCoord0Accessor.bufferView.stride,
                cast(void*)texCoord0Accessor.byteOffset);
        }
        else
        {
            glVertexAttrib2f(VertexAttrib.Texcoords, 0.0f, 0.0f);
        }
        
        if (hasJoints)
        {
            glEnableVertexAttribArray(VertexAttrib.Bones);
            glBindBuffer(GL_ARRAY_BUFFER, jbo);
            glVertexAttribIPointer(VertexAttrib.Bones,
                joints0Accessor.numComponents,
                joints0Accessor.componentType,
                joints0Accessor.bufferView.stride,
                cast(void*)joints0Accessor.byteOffset);
        }
        else
        {
            glVertexAttribI4ui(VertexAttrib.Bones, 0, 0, 0, 0);
        }
        
        if (hasWeights)
        {
            glEnableVertexAttribArray(VertexAttrib.Weights);
            glBindBuffer(GL_ARRAY_BUFFER, wbo);
            glVertexAttribPointer(VertexAttrib.Weights,
                weights0Accessor.numComponents,
                weights0Accessor.componentType,
                GL_FALSE,
                weights0Accessor.bufferView.stride,
                cast(void*)weights0Accessor.byteOffset);
        }
        else
        {
            glVertexAttrib4f(VertexAttrib.Weights, 0.0f, 0.0f, 0.0f, 0.0f);
        }
        
        if (hasIndices)
        {
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eao);
        }
        
        glBindVertexArray(0);
        
        canRender = true;
    }
    
    /**
     * Renders the mesh primitive using the provided graphics pipeline state.
     *
     * Params:
     *   state = Pointer to the current graphics pipeline state.
     */
    void render(GraphicsState* state)
    {
        if (canRender)
        {
            glBindVertexArray(vao);
            
            if (hasIndices)
                glDrawElements(GL_TRIANGLES, indexAccessor.count, indexAccessor.componentType, cast(void*)indexAccessor.byteOffset);
            else if (hasPositions)
                glDrawArrays(GL_TRIANGLES, 0, positionAccessor.count);
            
            glBindVertexArray(0);
        }
    }
    
    /// Destructor. Releases all OpenGL resources.
    ~this()
    {
        if (canRender)
        {
            glDeleteVertexArrays(1, &vao);
            
            if (hasPositions) glDeleteBuffers(1, &vbo);
            if (hasNormals) glDeleteBuffers(1, &nbo);
            if (hasTexcoords) glDeleteBuffers(1, &tbo);
            if (hasJoints) glDeleteBuffers(1, &jbo);
            if (hasWeights) glDeleteBuffers(1, &wbo);
            if (hasIndices) glDeleteBuffers(1, &eao);
        }
    }
}
