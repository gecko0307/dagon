/*
Copyright (c) 2021-2024 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module dagon.resource.gltf;

import std.stdio;
import std.math;
import std.path;
import std.algorithm;
import std.base64;
import dlib.core.memory;
import dlib.core.ownership;
import dlib.core.stream;
import dlib.filesystem.filesystem;
import dlib.container.array;
import dlib.serialization.json;
import dlib.text.str;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.transformation;
import dlib.math.quaternion;
import dlib.geometry.triangle;
import dlib.image.color;
import dlib.image.image;

import dagon.core.bindings;
import dagon.core.event;
import dagon.core.time;
import dagon.resource.asset;
import dagon.resource.texture;
import dagon.graphics.texture;
import dagon.graphics.material;
import dagon.graphics.mesh;
import dagon.graphics.entity;

import dagon.resource.gltf.buffer;
import dagon.resource.gltf.bufferview;
import dagon.resource.gltf.accessor;
import dagon.resource.gltf.meshprimitive;
import dagon.resource.gltf.mesh;
import dagon.resource.gltf.node;
import dagon.resource.gltf.skin;

Vector3f asVector(JSONValue value)
{
    Vector3f vec = Vector3f(0.0f, 0.0f, 0.0f);
    foreach(i, v; value.asArray)
        vec[i] = v.asNumber;
    return vec;
}

Matrix4x4f asMatrix(JSONValue value)
{
    Matrix4x4f mat = Matrix4x4f.identity;
    foreach(i, v; value.asArray)
        mat[i] = v.asNumber;
    return mat;
}

Quaternionf asQuaternion(JSONValue value)
{
    Quaternionf q = Quaternionf.identity;
    foreach(i, v; value.asArray)
        q[i] = v.asNumber;
    return q;
}

Color4f asColor(JSONValue value)
{
    Color4f col = Color4f(1.0f, 1.0f, 1.0f, 1.0f);
    foreach(i, v; value.asArray)
        col[i] = v.asNumber;
    return col;
}

class StaticTransformComponent: EntityComponent
{
    Matrix4x4f transformation;
    
    this(EventManager em, Entity e, Matrix4x4f transformation)
    {
        super(em, e);
        this.transformation = transformation;
    }
    
    override void update(Time t)
    {
        entity.transformation = transformation;
        entity.updateAbsoluteTransformation();
    }
}

class GLTFScene: Owner
{
    string name;
    Array!GLTFNode nodes;
    
    this(Owner o)
    {
        super(o);
    }
    
    ~this()
    {
        nodes.free();
    }
}

class GLTFAsset: Asset, TriangleSet
{
    AssetManager assetManager;
    String str;
    JSONDocument doc;
    Array!GLTFBuffer buffers;
    Array!GLTFBufferView bufferViews;
    Array!GLTFAccessor accessors;
    Array!GLTFMesh meshes;
    Array!TextureAsset images;
    Array!Texture textures;
    Array!Material materials;
    Array!GLTFNode nodes;
    Array!GLTFSkin skins;
    Array!GLTFScene scenes;
    Entity rootEntity;
    
    this(Owner o)
    {
        super(o);
    }
    
    ~this()
    {
        release();
    }
    
    override bool loadThreadSafePart(string filename, InputStream istrm, ReadOnlyFileSystem fs, AssetManager mngr)
    {
        assetManager = mngr;
        rootEntity = New!Entity(this);
        string rootDir = dirName(filename);
        str = String(istrm);
        doc = New!JSONDocument(str.toString);
        loadBuffers(doc.root, fs, rootDir);
        loadBufferViews(doc.root);
        loadAccessors(doc.root);
        loadImages(doc.root, fs, rootDir);
        loadTextures(doc.root);
        loadMaterials(doc.root);
        loadMeshes(doc.root);
        loadNodes(doc.root);
        loadSkins(doc.root);
        loadAnimations(doc.root);
        loadScenes(doc.root);
        return true;
    }
    
    void loadBuffers(JSONValue root, ReadOnlyFileSystem fs, string rootDir)
    {
        if ("buffers" in root.asObject)
        {
            foreach(buffer; root.asObject["buffers"].asArray)
            {
                auto buf = buffer.asObject;
                if ("uri" in buf)
                {
                    string uri = buf["uri"].asString;
                    string base64Prefix = "data:application/octet-stream;base64,";
                    
                    GLTFBuffer b = New!GLTFBuffer(this);
                    
                    if (uri.startsWith(base64Prefix))
                    {
                        auto encoded = uri[base64Prefix.length..$];
                        b.fromBase64(encoded);
                    }
                    else
                    {
                        String bufFilename = String(rootDir);
                        bufFilename ~= "/";
                        bufFilename ~= buf["uri"].asString;
                        b.fromFile(fs, bufFilename.toString);
                        bufFilename.free();
                    }
                    
                    buffers.insertBack(b);
                }
            }
        }
    }
    
    void loadBufferViews(JSONValue root)
    {
        if ("bufferViews" in root.asObject)
        {
            foreach(bufferView; root.asObject["bufferViews"].asArray)
            {
                auto bv = bufferView.asObject;
                uint bufferIndex = 0;
                uint byteOffset = 0;
                uint byteLength = 0;
                uint byteStride = 0;
                GLenum target = GL_ARRAY_BUFFER;
                
                if ("buffer" in bv)
                    bufferIndex = cast(uint)bv["buffer"].asNumber;
                if ("byteOffset" in bv)
                    byteOffset = cast(uint)bv["byteOffset"].asNumber;
                if ("byteLength" in bv)
                    byteLength = cast(uint)bv["byteLength"].asNumber;
                if ("byteStride" in bv)
                    byteStride = cast(uint)bv["byteStride"].asNumber;
                if ("target" in bv)
                    target = cast(GLenum)bv["target"].asNumber;
                
                if (bufferIndex < buffers.length)
                {
                    GLTFBufferView bufv = New!GLTFBufferView(buffers[bufferIndex], byteOffset, byteLength, byteStride, target, this);
                    bufferViews.insertBack(bufv);
                }
                else
                {
                    writeln("Warning: can't create buffer view for nonexistent buffer ", bufferIndex);
                    GLTFBufferView bufv = New!GLTFBufferView(null, 0, 0, 0, 0, this);
                    bufferViews.insertBack(bufv);
                }
            }
        }
    }
    
    void loadAccessors(JSONValue root)
    {
        if ("accessors" in root.asObject)
        {
            foreach(i, accessor; root.asObject["accessors"].asArray)
            {
                auto acc = accessor.asObject;
                uint bufferViewIndex = 0;
                GLenum componentType = GL_FLOAT;
                string type;
                uint count = 0;
                uint byteOffset = 0;
                
                if ("bufferView" in acc)
                    bufferViewIndex = cast(uint)acc["bufferView"].asNumber;
                if ("componentType" in acc)
                    componentType = cast(GLenum)acc["componentType"].asNumber;
                if ("type" in acc)
                    type = acc["type"].asString;
                if ("count" in acc)
                    count = cast(uint)acc["count"].asNumber;
                if ("byteOffset" in acc)
                    byteOffset = cast(uint)acc["byteOffset"].asNumber;
                
                GLTFDataType dataType = GLTFDataType.Undefined;
                if (type == "SCALAR")
                    dataType = GLTFDataType.Scalar;
                else if (type == "VEC2")
                    dataType = GLTFDataType.Vec2;
                else if (type == "VEC3")
                    dataType = GLTFDataType.Vec3;
                else if (type == "VEC4")
                    dataType = GLTFDataType.Vec4;
                else if (type == "MAT2")
                    dataType = GLTFDataType.Mat2;
                else if (type == "MAT3")
                    dataType = GLTFDataType.Mat3;
                else if (type == "MAT4")
                    dataType = GLTFDataType.Mat4;
                else
                    writeln("Warning: unsupported data type for accessor ", i);
                
                if (bufferViewIndex < bufferViews.length)
                {
                    GLTFAccessor ac = New!GLTFAccessor(bufferViews[bufferViewIndex], dataType, componentType, count, byteOffset, this);
                    accessors.insertBack(ac);
                }
                else
                {
                    writeln("Warning: can't create accessor for nonexistent buffer view ", bufferViewIndex);
                    GLTFAccessor ac = New!GLTFAccessor(null, dataType, componentType, count, byteOffset, this);
                    accessors.insertBack(ac);
                }
            }
        }
    }
    
    void loadImages(JSONValue root, ReadOnlyFileSystem fs, string rootDir)
    {
        if ("images" in root.asObject)
        {
            foreach(i, img; root.asObject["images"].asArray)
            {
                auto im = img.asObject;
                
                if ("uri" in im)
                {
                    string uri = im["uri"].asString;
                    TextureAsset textureAsset = New!TextureAsset(assetManager);
                    
                    ImageFormatInfo info = assetManager.detectBase64Image(uri);
                    if (info.format.length)
                    {
                        auto encoded = uri[info.prefix.length..$];
                        auto decodedLength = Base64.decodeLength(encoded.length);
                        auto array = New!(ubyte[])(decodedLength);
                        auto decoded = Base64.decode(encoded, array);
                        bool res = assetManager.loadAssetThreadSafePart(textureAsset, decoded, info.dummyFilename);
                        if (!res)
                            writeln("Warning: failed to load Base64-encoded image");
                        Delete(array);
                    }
                    else
                    {
                        String imgFilename = String(rootDir);
                        imgFilename ~= "/";
                        imgFilename ~= uri;
                        string assetFilename = imgFilename.toString;
                        
                        FileStat fstat;
                        if (fs.stat(assetFilename, fstat))
                        {
                            bool res = assetManager.loadAssetThreadSafePart(textureAsset, assetFilename);
                            if (!res)
                                writeln("Warning: failed to load \"", imgFilename, "\"");
                        }
                        else
                            writeln("Warning: image file \"", imgFilename, "\" not found");
                        
                        imgFilename.free();
                    }
                    
                    images.insertBack(textureAsset);
                }
                else if ("bufferView" in im)
                {
                    uint bufferViewIndex = cast(uint)im["bufferView"].asNumber;
                    
                    auto textureAsset = New!TextureAsset(this);
                    
                    if (bufferViewIndex < bufferViews.length)
                    {
                        auto bv = bufferViews[bufferViewIndex];
                        string mimeType = "";
                        if ("mimeType" in im)
                            mimeType = im["mimeType"].asString;
                        if (mimeType == "")
                            writeln("Warning: image MIME type missing");
                        else
                        {
                            string name = nameFromMimeType(mimeType);
                            if (name == "")
                            {
                                writeln("Warning: unsupported image MIME type ", mimeType);
                            }
                            else
                            {
                                
                                bool res = assetManager.loadAssetThreadSafePart(textureAsset, bv.slice, name);
                                if (!res)
                                    writeln("Warning: failed to load image");
                            }
                        }
                    }
                    else
                    {
                        writeln("Warning: can't create image from nonexistent buffer view ", bufferViewIndex);
                    }
                    
                    images.insertBack(textureAsset);
                }
            }
        }
    }
    
    // TODO: loadSamplers
    
    void loadTextures(JSONValue root)
    {
        if ("textures" in root.asObject)
        {
            foreach(i, tex; root.asObject["textures"].asArray)
            {
                auto te = tex.asObject;
                
                if ("source" in te)
                {
                    uint imageIndex = cast(uint)te["source"].asNumber;
                    TextureAsset img;
                    if (imageIndex < images.length)
                        img = images[imageIndex];
                    else
                        writeln("Warning: can't create texture for nonexistent image ", imageIndex);
                    
                    if (img !is null)
                    {
                        Texture texture = img.texture;
                        textures.insertBack(texture);
                    }
                    else
                    {
                        Texture texture;
                        textures.insertBack(texture);
                    }
                }
                
                // TODO: sampler
            }
        }
    }
    
    void loadMaterials(JSONValue root)
    {
        if ("materials" in root.asObject)
        {
            foreach(i, mat; root.asObject["materials"].asArray)
            {
                auto ma = mat.asObject;
                
                Material material = New!Material(this);
                
                if ("name" in ma)
                {
                    material.name = ma["name"].asString;
                }
                
                if ("pbrMetallicRoughness" in ma)
                {
                    auto pbr = ma["pbrMetallicRoughness"].asObject;
                    
                    Color4f baseColorFactor = Color4f(1.0f, 1.0f, 1.0f, 1.0f);
                    if (pbr && "baseColorFactor" in pbr)
                    {
                        baseColorFactor = pbr["baseColorFactor"].asColor;
                        
                        if (baseColorFactor.a < 1.0f)
                            material.blendMode = Transparent;
                        
                        material.baseColorFactor = baseColorFactor;
                    }
                    
                    if (pbr && "baseColorTexture" in pbr)
                    {
                        auto bct = pbr["baseColorTexture"].asObject;
                        if ("index" in bct)
                        {
                            uint baseColorTexIndex = cast(uint)bct["index"].asNumber;
                            if (baseColorTexIndex < textures.length)
                            {
                                Texture baseColorTex = textures[baseColorTexIndex];
                                if (baseColorTex)
                                {
                                    material.baseColorTexture = baseColorTex;
                                }
                            }
                        }
                        
                        material.opacity = baseColorFactor.a;
                    }
                    
                    if (pbr && "metallicRoughnessTexture" in pbr)
                    {
                        uint metallicRoughnessTexIndex = cast(uint)pbr["metallicRoughnessTexture"].asObject["index"].asNumber;
                        if (metallicRoughnessTexIndex < textures.length)
                        {
                            Texture metallicRoughnessTex = textures[metallicRoughnessTexIndex];
                            if (metallicRoughnessTex)
                                material.roughnessMetallicTexture = metallicRoughnessTex;
                        }
                    }
                    else
                    {
                        if (pbr && "metallicFactor" in pbr)
                        {
                            material.metallicFactor = pbr["metallicFactor"].asNumber;
                        }
                        else
                        {
                            material.metallicFactor = 1.0f;
                        }
                        
                        if (pbr && "roughnessFactor" in pbr)
                        {
                            material.roughnessFactor = pbr["roughnessFactor"].asNumber;
                        }
                        else
                        {
                            material.roughnessFactor = 1.0f;
                        }
                    }
                }
                else if ("extensions" in ma)
                {
                    auto extensions = ma["extensions"].asObject;
                    
                    if ("KHR_materials_pbrSpecularGlossiness" in extensions)
                    {
                        auto pbr = extensions["KHR_materials_pbrSpecularGlossiness"].asObject;
                        
                        if (pbr && "diffuseTexture" in pbr)
                        {
                            auto dt = pbr["diffuseTexture"].asObject;
                            if ("index" in dt)
                            {
                                uint diffuseTexIndex = cast(uint)dt["index"].asNumber;
                                if (diffuseTexIndex < textures.length)
                                {
                                    Texture diffuseTex = textures[diffuseTexIndex];
                                    if (diffuseTex)
                                    {
                                        material.baseColorTexture = diffuseTex;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if ("normalTexture" in ma)
                {
                    uint normalTexIndex = cast(uint)ma["normalTexture"].asObject["index"].asNumber;
                    if (normalTexIndex < textures.length)
                    {
                        Texture normalTex = textures[normalTexIndex];
                        if (normalTex)
                            material.normalTexture = normalTex;
                    }
                }
                
                if ("emissiveTexture" in ma)
                {
                    uint emissiveTexIndex = cast(uint)ma["emissiveTexture"].asObject["index"].asNumber;
                    if (emissiveTexIndex < textures.length)
                    {
                        Texture emissiveTex = textures[emissiveTexIndex];
                        if (emissiveTex)
                            material.emissionTexture = emissiveTex;
                    }
                }
                
                if ("emissiveFactor" in ma)
                {
                    Color4f emissiveFactor = ma["emissiveFactor"].asColor;
                    material.emissionFactor = emissiveFactor;
                }
                
                if ("extensions" in ma)
                {
                    auto extensions = ma["extensions"].asObject;
                    
                    if ("KHR_materials_emissive_strength" in extensions)
                    {
                        auto khrEmissiveStrength = extensions["KHR_materials_emissive_strength"].asObject;
                        if (khrEmissiveStrength && "emissiveStrength" in khrEmissiveStrength)
                        {
                            material.emissionEnergy = khrEmissiveStrength["emissiveStrength"].asNumber;
                        }
                    }
                }
                
                if ("doubleSided" in ma)
                {
                    uint doubleSided = cast(uint)ma["doubleSided"].asNumber;
                    if (doubleSided > 0)
                        material.useCulling = false;
                    else
                        material.useCulling = true;
                }
                else
                {
                    material.useCulling = true;
                }
                
                if ("alphaMode" in ma)
                {
                    auto alphaMode = ma["alphaMode"].asString;
                    if (alphaMode == "BLEND")
                    {
                        material.blendMode = Transparent;
                    }
                }
                
                if ("alphaCutoff" in ma)
                {
                    material.alphaTestThreshold = ma["alphaCutoff"].asNumber;
                }
                
                materials.insertBack(material);
            }
        }
    }
    
    void loadMeshes(JSONValue root)
    {
        if ("meshes" in root.asObject)
        {
            foreach(i, mesh; root.asObject["meshes"].asArray)
            {
                auto m = mesh.asObject;
                
                GLTFMesh me = New!GLTFMesh(this);
                
                if ("primitives" in m)
                {
                    foreach(prim; m["primitives"].asArray)
                    {
                        auto p = prim.asObject;
                        
                        GLTFAccessor positionAccessor;
                        GLTFAccessor normalAccessor;
                        GLTFAccessor texCoord0Accessor;
                        GLTFAccessor joints0Accessor;
                        GLTFAccessor weights0Accessor;
                        GLTFAccessor indexAccessor;
                        
                        if ("attributes" in p)
                        {
                            auto attributes = p["attributes"].asObject;
                            
                            if ("POSITION" in attributes)
                            {
                                uint positionsAccessorIndex = cast(uint)attributes["POSITION"].asNumber;
                                if (positionsAccessorIndex < accessors.length)
                                    positionAccessor = accessors[positionsAccessorIndex];
                                else
                                    writeln("Warning: can't create position attributes for nonexistent accessor ", positionsAccessorIndex);
                            }
                            
                            if ("NORMAL" in attributes)
                            {
                                uint normalsAccessorIndex = cast(uint)attributes["NORMAL"].asNumber;
                                if (normalsAccessorIndex < accessors.length)
                                    normalAccessor = accessors[normalsAccessorIndex];
                                else
                                    writeln("Warning: can't create normal attributes for nonexistent accessor ", normalsAccessorIndex);
                            }
                            
                            if ("TEXCOORD_0" in attributes)
                            {
                                uint texCoord0AccessorIndex = cast(uint)attributes["TEXCOORD_0"].asNumber;
                                if (texCoord0AccessorIndex < accessors.length)
                                    texCoord0Accessor = accessors[texCoord0AccessorIndex];
                                else
                                    writeln("Warning: can't create texCoord0 attributes for nonexistent accessor ", texCoord0AccessorIndex);
                            }
                            
                            if ("JOINTS_0" in attributes)
                            {
                                uint joints0AccessorIndex = cast(uint)attributes["JOINTS_0"].asNumber;
                                if (joints0AccessorIndex < accessors.length)
                                    joints0Accessor = accessors[joints0AccessorIndex];
                                else
                                    writeln("Warning: can't create joints0 attributes for nonexistent accessor ", joints0AccessorIndex);
                            }
                            
                            if ("WEIGHTS_0" in attributes)
                            {
                                uint weights0AccessorIndex = cast(uint)attributes["WEIGHTS_0"].asNumber;
                                if (weights0AccessorIndex < accessors.length)
                                    weights0Accessor = accessors[weights0AccessorIndex];
                                else
                                    writeln("Warning: can't create weights0 attributes for nonexistent accessor ", weights0AccessorIndex);
                            }
                        }
                        
                        if ("indices" in p)
                        {
                            uint indicesAccessorIndex = cast(uint)p["indices"].asNumber;
                            if (indicesAccessorIndex < accessors.length)
                                indexAccessor = accessors[indicesAccessorIndex];
                            else
                                writeln("Warning: can't create indices for nonexistent accessor ", indicesAccessorIndex);
                        }
                        
                        Material material;
                        if ("material" in p)
                        {
                            uint materialIndex = cast(uint)p["material"].asNumber;
                            if (materialIndex < materials.length)
                                material = materials[materialIndex];
                            else
                                writeln("Warning: nonexistent material ", materialIndex);
                        }
                        
                        if (positionAccessor is null)
                            writeln("Warning: mesh ", i, " lacks vertex position attributes");
                        
                        if (normalAccessor is null)
                            writeln("Warning: mesh ", i, " lacks vertex normal attributes");
                        
                        if (texCoord0Accessor is null)
                            writeln("Warning: mesh ", i, " lacks vertex texCoord0 attributes");
                        
                        if (indexAccessor is null)
                            writeln("Warning: mesh ", i, " lacks indices");
                        
                        GLTFMeshPrimitive pr = New!GLTFMeshPrimitive(this);
                        pr.positionAccessor = positionAccessor;
                        pr.normalAccessor = normalAccessor;
                        pr.texCoord0Accessor = texCoord0Accessor;
                        pr.joints0Accessor = joints0Accessor;
                        pr.weights0Accessor = weights0Accessor;
                        pr.indexAccessor = indexAccessor;
                        pr.material = material;
                        
                        me.primitives.insertBack(pr);
                    }
                }
                
                meshes.insertBack(me);
            }
        }
    }
    
    void loadNodes(JSONValue root)
    {
        if ("nodes" in root.asObject)
        {
            foreach(i, n; root.asObject["nodes"].asArray)
            {
                auto node = n.asObject;
                
                GLTFNode nodeObj = New!GLTFNode(this);
                nodeObj.entity.setParent(rootEntity);
                
                if ("mesh" in node)
                {
                    uint meshIndex = cast(uint)node["mesh"].asNumber;
                    if (meshIndex < meshes.length)
                    {
                        GLTFMesh mesh = meshes[meshIndex];
                        nodeObj.mesh = mesh;
                        nodeObj.entity.drawable = mesh;
                    }
                    else
                        writeln("Warning: mesh ", meshIndex, " doesn't exist");
                }
                
                if ("extensions" in node)
                {
                    auto nodeExt = node["extensions"].asObject;
                    if ("KHR_lights_punctual" in nodeExt)
                    {
                        // TODO
                    }
                }
                
                if ("matrix" in node)
                {
                    nodeObj.transformation = node["matrix"].asMatrix;
                    auto nodeComponent = New!StaticTransformComponent(assetManager.eventManager, nodeObj.entity, nodeObj.transformation);
                }
                else
                {
                    Vector3f position = Vector3f(0.0f, 0.0f, 0.0f);
                    Quaternionf rotation = Quaternionf.identity;
                    Vector3f scale = Vector3f(1.0f, 1.0f, 1.0f);
                    
                    if ("translation" in node)
                    {
                        position = node["translation"].asVector;
                    }
                    if ("rotation" in node)
                    {
                        rotation = node["rotation"].asQuaternion;
                    }
                    if ("scale" in node)
                    {
                        scale = node["scale"].asVector;
                    }
                    
                    nodeObj.entity.position = position;
                    nodeObj.entity.rotation = rotation;
                    nodeObj.entity.scaling = scale;
                    
                    nodeObj.transformation =
                        translationMatrix(position) *
                        rotation.toMatrix4x4 *
                        scaleMatrix(scale);
                }
                
                if ("children" in node)
                {
                    auto children = node["children"].asArray;
                    nodeObj.children = New!(size_t[])(children.length);
                    
                    foreach(ci, c; children)
                    {
                        uint childIndex = cast(uint)c.asNumber;
                        nodeObj.children[ci] = childIndex;
                    }
                }
                
                nodes.insertBack(nodeObj);
            }
        }
        
        foreach(node; nodes)
        {
            foreach(i; node.children)
            {
                GLTFNode child = nodes[i];
                node.entity.addChild(child.entity);
            }
        }
        
        rootEntity.updateTransformationTopDown();
    }
    
    void loadSkins(JSONValue root)
    {
        if ("skins" in root.asObject)
        {
            foreach(i, s; root.asObject["skins"].asArray)
            {
                auto skin = s.asObject;
                
                GLTFSkin skinObj = New!GLTFSkin(this);
                
                if ("joins" in skin)
                {
                    foreach(ni, n; skin["joins"].asArray)
                    {
                        uint nodeIndex = cast(uint)n.asNumber;
                        if (nodeIndex < nodes.length)
                            skinObj.joints.insertBack(nodes[nodeIndex]);
                    }
                }
                
                if ("inverseBindMatrices" in skin)
                {
                    GLTFAccessor invBindMatricesAccessor;
                    uint invBindMatricesAccessorIndex = cast(uint)skin["inverseBindMatrices"].asNumber;
                    if (invBindMatricesAccessorIndex < accessors.length)
                        invBindMatricesAccessor = accessors[invBindMatricesAccessorIndex];
                    else
                        writeln("Warning: nonexistent accessor ", invBindMatricesAccessorIndex);
                    
                    skinObj.invBindMatricesAccessor = invBindMatricesAccessor;
                }
                
                skins.insertBack(skinObj);
            }
        }
    }
    
    void loadAnimations(JSONValue root)
    {
        // TODO
    }
    
    void loadScenes(JSONValue root)
    {
        if ("scenes" in root.asObject)
        {
            foreach(i, s; root.asObject["scenes"].asArray)
            {
                auto scene = s.asObject;
                
                GLTFScene sceneObj = New!GLTFScene(this);
                
                if ("name" in scene)
                {
                    sceneObj.name = scene["name"].asString;
                }
                
                if ("nodes" in scene)
                {
                    foreach(ni, n; scene["nodes"].asArray)
                    {
                        uint nodeIndex = cast(uint)n.asNumber;
                        if (nodeIndex < nodes.length)
                            sceneObj.nodes.insertBack(nodes[nodeIndex]);
                    }
                }
                
                scenes.insertBack(sceneObj);
            }
        }
    }
    
    override bool loadThreadUnsafePart()
    {
        foreach(me; meshes)
        {
            foreach(p; me.primitives)
                p.prepareVAO();
        }
        
        foreach(img; images)
        {
            img.loadThreadUnsafePart();
        }
        
        return true;
    }
    
    void markTransparentEntities()
    {
        foreach(node; nodes)
        {
            if (node.mesh)
            {
                foreach(primitive; node.mesh.primitives)
                {
                    Material material = primitive.material;
                    if (material)
                    {
                        if (material.blendMode == Transparent)
                        {
                            node.entity.transparent = true;
                        }
                    }
                }
            }
        }
    }
    
    override void release()
    {
        foreach(b; buffers)
            deleteOwnedObject(b);
        buffers.free();
        
        foreach(bv; bufferViews)
            deleteOwnedObject(bv);
        bufferViews.free();
        
        foreach(ac; accessors)
            deleteOwnedObject(ac);
        accessors.free();
        
        foreach(me; meshes)
            deleteOwnedObject(me);
        meshes.free();
        
        foreach(im; images)
            deleteOwnedObject(im);
        images.free();
        
        foreach(no; nodes)
            deleteOwnedObject(no);
        nodes.free();
        
        foreach(sko; skins)
            deleteOwnedObject(sko);
        skins.free();
        
        foreach(sc; scenes)
            deleteOwnedObject(sc);
        scenes.free();
        
        textures.free();
        materials.free();
        
        Delete(doc);
        str.free();
    }
    
    int opApply(scope int delegate(Triangle t) dg)
    {
        int result = 0;
        
        foreach(node; nodes)
        {
            auto mat = node.entity.absoluteTransformation;
            
            if (node.mesh)
            {
                foreach(primitive; node.mesh.primitives)
                {
                    GLTFAccessor pa = primitive.positionAccessor;
                    GLTFAccessor na = primitive.normalAccessor;
                    GLTFAccessor ia = primitive.indexAccessor;
                    
                    Vector3f* positions = cast(Vector3f*)(pa.bufferView.slice.ptr + pa.byteOffset);
                    size_t numPositions = pa.count;
                    
                    Vector3f* normals = cast(Vector3f*)(na.bufferView.slice.ptr + na.byteOffset);
                    size_t numNormals = na.count;
                    
                    ubyte* indicesStart = ia.bufferView.slice.ptr + ia.byteOffset;
                    size_t numTriangles = ia.count / 3;
                    
                    size_t indexStride;
                    if (ia.componentType == GL_UNSIGNED_BYTE)
                        indexStride = 1;
                    else if (ia.componentType == GL_UNSIGNED_SHORT)
                        indexStride = 2;
                    else if (ia.componentType == GL_UNSIGNED_INT)
                        indexStride = 4;
                    
                    foreach(i; 0..numTriangles)
                    {
                        ubyte* ptr = indicesStart + i * 3 * indexStride;
                        
                        size_t[3] indices;
                        if (ia.componentType == GL_UNSIGNED_BYTE)
                        {
                            indices[0] = ptr[0];
                            indices[1] = ptr[1];
                            indices[2] = ptr[2];
                        }
                        else if (ia.componentType == GL_UNSIGNED_SHORT)
                        {
                            indices[0] = *cast(ushort*)ptr;
                            indices[1] = *cast(ushort*)(ptr+2);
                            indices[2] = *cast(ushort*)(ptr+4);
                        }
                        else if (ia.componentType == GL_UNSIGNED_INT)
                        {
                            indices[0] = *cast(uint*)ptr;
                            indices[1] = *cast(uint*)(ptr+4);
                            indices[2] = *cast(uint*)(ptr+8);
                        }
                        
                        Triangle tri;
                        tri.v[0] = positions[indices[0]] * mat;
                        tri.v[1] = positions[indices[1]] * mat;
                        tri.v[2] = positions[indices[2]] * mat;
                        tri.n[0] = mat.rotate(normals[indices[0]]);
                        tri.n[1] = mat.rotate(normals[indices[1]]);
                        tri.n[2] = mat.rotate(normals[indices[2]]);
                        tri.normal = (tri.n[0] + tri.n[1] + tri.n[2]) / 3.0f;
                        
                        result = dg(tri);
                        if (result)
                            return result;
                    }
                }
            }
        }
        
        return result;
    }
    
    Material material(string name)
    {
        Material res;
        
        foreach(i, mat; materials)
        {
            if (mat.name == name)
            {
                res = mat;
                break;
            }
        }
        
        return res;
    }
}

// TODO: generate random name instead of "undefined"
string nameFromMimeType(string mime)
{
    string name;
    switch(mime)
    {
        case "image/jpeg": name = "undefined.jpg"; break;
        case "image/png": name = "undefined.png"; break;
        case "image/tga": name = "undefined.tga"; break;
        case "image/targa": name = "undefined.tga"; break;
        case "image/bmp": name = "undefined.bmp"; break;
        case "image/vnd.radiance": name = "undefined.hdr"; break;
        case "image/x-hdr": name = "undefined.hdr"; break;
        case "image/x-dds": name = "undefined.dds"; break;
        default: name = ""; break;
    }
    return name;
}

void decomposeMatrix(
    Matrix4x4f m,
    out Vector3f position,
    out Quaternionf rotation,
    out Vector3f scale)
{
    position = Vector3f(m[12], m[13], m[14]);
    
    float sx = sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    float sy = sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    float sz = sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);

    if (m.determinant < 0)
        sx = -sx;
    
    scale = Vector3f(sx, sy, sz);
    
    float invSx = 1.0f / sx;
    float invSy = 1.0f / sy;
    float invSz = 1.0f / sz;
    
    Matrix3x3f rotationMatrix = matrixf(
        m[0] * invSx, m[4] * invSy, m[8] * invSz,
        m[1] * invSx, m[5] * invSy, m[9] * invSz,
        m[2] * invSx, m[6] * invSy, m[10] * invSz
    );
    
    rotation = Quaternionf.fromMatrix(matrix3x3to4x4(rotationMatrix));
}
