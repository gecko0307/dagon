/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

module derelict.opengl.glxext;

private import derelict.util.system;

static if( Derelict_OS_Posix && !Derelict_OS_Mac ) {
    private {
        import derelict.opengl.types;
        import derelict.opengl.constants;
        import derelict.opengl.internal;
        import derelict.opengl.glx;
        import derelict.util.xtypes;
    }

    alias int64_t = ulong;
    alias uint64_t = ulong;
    alias int32_t = int;
    alias GLXContextID = XID;
    alias GLXVideoCaptureDeviceNV = XID;
    alias GLXPbufferSGIX = XID;
    alias GLXVideoDeviceNV = uint;

    struct __GLXFBConfigRec;
    alias __GLXFBConfigRec *GLXFBConfigSGIX;

	enum : uint {
		GLX_CONTEXT_DEBUG_BIT_ARB         = 0x00000001,
		GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB = 0x00000002,
		GLX_CONTEXT_MAJOR_VERSION_ARB     = 0x2091,
		GLX_CONTEXT_MINOR_VERSION_ARB     = 0x2092,
		GLX_CONTEXT_FLAGS_ARB             = 0x2094,
		GLX_CONTEXT_CORE_PROFILE_BIT_ARB  = 0x00000001,
		GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB = 0x00000002,
		GLX_CONTEXT_PROFILE_MASK_ARB      = 0x9126,
		GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB = 0x00000004,
		GLX_LOSE_CONTEXT_ON_RESET_ARB     = 0x8252,
		GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256,
		GLX_NO_RESET_NOTIFICATION_ARB     = 0x8261,
		GLX_RGBA_FLOAT_TYPE_ARB           = 0x20B9,
		GLX_RGBA_FLOAT_BIT_ARB            = 0x00000004,
		GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB  = 0x20B2,
		GLX_SAMPLE_BUFFERS_ARB            = 100000,
		GLX_SAMPLES_ARB                   = 100001,
		GLX_CONTEXT_RESET_ISOLATION_BIT_ARB = 0x00000008,
		GLX_SAMPLE_BUFFERS_3DFX           = 0x8050,
		GLX_SAMPLES_3DFX                  = 0x8051,
		GLX_GPU_VENDOR_AMD                = 0x1F00,
		GLX_GPU_RENDERER_STRING_AMD       = 0x1F01,
		GLX_GPU_OPENGL_VERSION_STRING_AMD = 0x1F02,
		GLX_GPU_FASTEST_TARGET_GPUS_AMD   = 0x21A2,
		GLX_GPU_RAM_AMD                   = 0x21A3,
		GLX_GPU_CLOCK_AMD                 = 0x21A4,
		GLX_GPU_NUM_PIPES_AMD             = 0x21A5,
		GLX_GPU_NUM_SIMD_AMD              = 0x21A6,
		GLX_GPU_NUM_RB_AMD                = 0x21A7,
		GLX_GPU_NUM_SPI_AMD               = 0x21A8,
		GLX_BACK_BUFFER_AGE_EXT           = 0x20F4,
		GLX_CONTEXT_ES2_PROFILE_BIT_EXT   = 0x00000004,
		GLX_CONTEXT_ES_PROFILE_BIT_EXT    = 0x00000004,
		GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT  = 0x20B1,
		GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT   = 0x00000008,
		GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT  = 0x20B2,
		GLX_SHARE_CONTEXT_EXT             = 0x800A,
		GLX_VISUAL_ID_EXT                 = 0x800B,
		GLX_SCREEN_EXT                    = 0x800C,
		GLX_SWAP_INTERVAL_EXT             = 0x20F1,
		GLX_MAX_SWAP_INTERVAL_EXT         = 0x20F2,
		GLX_LATE_SWAPS_TEAR_EXT           = 0x20F3,
		GLX_TEXTURE_1D_BIT_EXT            = 0x00000001,
		GLX_TEXTURE_2D_BIT_EXT            = 0x00000002,
		GLX_TEXTURE_RECTANGLE_BIT_EXT     = 0x00000004,
		GLX_BIND_TO_TEXTURE_RGB_EXT       = 0x20D0,
		GLX_BIND_TO_TEXTURE_RGBA_EXT      = 0x20D1,
		GLX_BIND_TO_MIPMAP_TEXTURE_EXT    = 0x20D2,
		GLX_BIND_TO_TEXTURE_TARGETS_EXT   = 0x20D3,
		GLX_Y_INVERTED_EXT                = 0x20D4,
		GLX_TEXTURE_FORMAT_EXT            = 0x20D5,
		GLX_TEXTURE_TARGET_EXT            = 0x20D6,
		GLX_MIPMAP_TEXTURE_EXT            = 0x20D7,
		GLX_TEXTURE_FORMAT_NONE_EXT       = 0x20D8,
		GLX_TEXTURE_FORMAT_RGB_EXT        = 0x20D9,
		GLX_TEXTURE_FORMAT_RGBA_EXT       = 0x20DA,
		GLX_TEXTURE_1D_EXT                = 0x20DB,
		GLX_TEXTURE_2D_EXT                = 0x20DC,
		GLX_TEXTURE_RECTANGLE_EXT         = 0x20DD,
		GLX_FRONT_LEFT_EXT                = 0x20DE,
		GLX_FRONT_RIGHT_EXT               = 0x20DF,
		GLX_BACK_LEFT_EXT                 = 0x20E0,
		GLX_BACK_RIGHT_EXT                = 0x20E1,
		GLX_FRONT_EXT                     = 0x20DE,
		GLX_BACK_EXT                      = 0x20E0,
		GLX_AUX0_EXT                      = 0x20E2,
		GLX_AUX1_EXT                      = 0x20E3,
		GLX_AUX2_EXT                      = 0x20E4,
		GLX_AUX3_EXT                      = 0x20E5,
		GLX_AUX4_EXT                      = 0x20E6,
		GLX_AUX5_EXT                      = 0x20E7,
		GLX_AUX6_EXT                      = 0x20E8,
		GLX_AUX7_EXT                      = 0x20E9,
		GLX_AUX8_EXT                      = 0x20EA,
		GLX_AUX9_EXT                      = 0x20EB,
		GLX_X_VISUAL_TYPE_EXT             = 0x22,
		GLX_TRANSPARENT_TYPE_EXT          = 0x23,
		GLX_TRANSPARENT_INDEX_VALUE_EXT   = 0x24,
		GLX_TRANSPARENT_RED_VALUE_EXT     = 0x25,
		GLX_TRANSPARENT_GREEN_VALUE_EXT   = 0x26,
		GLX_TRANSPARENT_BLUE_VALUE_EXT    = 0x27,
		GLX_TRANSPARENT_ALPHA_VALUE_EXT   = 0x28,
		GLX_NONE_EXT                      = 0x8000,
		GLX_TRUE_COLOR_EXT                = 0x8002,
		GLX_DIRECT_COLOR_EXT              = 0x8003,
		GLX_PSEUDO_COLOR_EXT              = 0x8004,
		GLX_STATIC_COLOR_EXT              = 0x8005,
		GLX_GRAY_SCALE_EXT                = 0x8006,
		GLX_STATIC_GRAY_EXT               = 0x8007,
		GLX_TRANSPARENT_RGB_EXT           = 0x8008,
		GLX_TRANSPARENT_INDEX_EXT         = 0x8009,
		GLX_VISUAL_CAVEAT_EXT             = 0x20,
		GLX_SLOW_VISUAL_EXT               = 0x8001,
		GLX_NON_CONFORMANT_VISUAL_EXT     = 0x800D,
		GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK = 0x04000000,
		GLX_EXCHANGE_COMPLETE_INTEL       = 0x8180,
		GLX_COPY_COMPLETE_INTEL           = 0x8181,
		GLX_FLIP_COMPLETE_INTEL           = 0x8182,
		GLX_3DFX_WINDOW_MODE_MESA         = 0x1,
		GLX_3DFX_FULLSCREEN_MODE_MESA     = 0x2,
		GLX_FLOAT_COMPONENTS_NV           = 0x20B0,
		GLX_COVERAGE_SAMPLES_NV           = 100001,
		GLX_COLOR_SAMPLES_NV              = 0x20B3,
		GLX_DEVICE_ID_NV                  = 0x20CD,
		GLX_UNIQUE_ID_NV                  = 0x20CE,
		GLX_NUM_VIDEO_CAPTURE_SLOTS_NV    = 0x20CF,
		GLX_VIDEO_OUT_COLOR_NV            = 0x20C3,
		GLX_VIDEO_OUT_ALPHA_NV            = 0x20C4,
		GLX_VIDEO_OUT_DEPTH_NV            = 0x20C5,
		GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV  = 0x20C6,
		GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV  = 0x20C7,
		GLX_VIDEO_OUT_FRAME_NV            = 0x20C8,
		GLX_VIDEO_OUT_FIELD_1_NV          = 0x20C9,
		GLX_VIDEO_OUT_FIELD_2_NV          = 0x20CA,
		GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV = 0x20CB,
		GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV = 0x20CC,
		GLX_SWAP_METHOD_OML               = 0x8060,
		GLX_SWAP_EXCHANGE_OML             = 0x8061,
		GLX_SWAP_COPY_OML                 = 0x8062,
		GLX_SWAP_UNDEFINED_OML            = 0x8063,
		GLX_BLENDED_RGBA_SGIS             = 0x8025,
		GLX_SAMPLE_BUFFERS_SGIS           = 100000,
		GLX_SAMPLES_SGIS                  = 100001,
		GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS = 0x8026,
		GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS = 0x8027,
		GLX_WINDOW_BIT_SGIX               = 0x00000001,
		GLX_PIXMAP_BIT_SGIX               = 0x00000002,
		GLX_RGBA_BIT_SGIX                 = 0x00000001,
		GLX_COLOR_INDEX_BIT_SGIX          = 0x00000002,
		GLX_DRAWABLE_TYPE_SGIX            = 0x8010,
		GLX_RENDER_TYPE_SGIX              = 0x8011,
		GLX_X_RENDERABLE_SGIX             = 0x8012,
		GLX_FBCONFIG_ID_SGIX              = 0x8013,
		GLX_RGBA_TYPE_SGIX                = 0x8014,
		GLX_COLOR_INDEX_TYPE_SGIX         = 0x8015,
		GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX = 80,
		GLX_BAD_HYPERPIPE_CONFIG_SGIX     = 91,
		GLX_BAD_HYPERPIPE_SGIX            = 92,
		GLX_HYPERPIPE_DISPLAY_PIPE_SGIX   = 0x00000001,
		GLX_HYPERPIPE_RENDER_PIPE_SGIX    = 0x00000002,
		GLX_PIPE_RECT_SGIX                = 0x00000001,
		GLX_PIPE_RECT_LIMITS_SGIX         = 0x00000002,
		GLX_HYPERPIPE_STEREO_SGIX         = 0x00000003,
		GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX  = 0x00000004,
		GLX_HYPERPIPE_ID_SGIX             = 0x8030,
		GLX_PBUFFER_BIT_SGIX              = 0x00000004,
		GLX_BUFFER_CLOBBER_MASK_SGIX      = 0x08000000,
		GLX_FRONT_LEFT_BUFFER_BIT_SGIX    = 0x00000001,
		GLX_FRONT_RIGHT_BUFFER_BIT_SGIX   = 0x00000002,
		GLX_BACK_LEFT_BUFFER_BIT_SGIX     = 0x00000004,
		GLX_BACK_RIGHT_BUFFER_BIT_SGIX    = 0x00000008,
		GLX_AUX_BUFFERS_BIT_SGIX          = 0x00000010,
		GLX_DEPTH_BUFFER_BIT_SGIX         = 0x00000020,
		GLX_STENCIL_BUFFER_BIT_SGIX       = 0x00000040,
		GLX_ACCUM_BUFFER_BIT_SGIX         = 0x00000080,
		GLX_SAMPLE_BUFFERS_BIT_SGIX       = 0x00000100,
		GLX_MAX_PBUFFER_WIDTH_SGIX        = 0x8016,
		GLX_MAX_PBUFFER_HEIGHT_SGIX       = 0x8017,
		GLX_MAX_PBUFFER_PIXELS_SGIX       = 0x8018,
		GLX_OPTIMAL_PBUFFER_WIDTH_SGIX    = 0x8019,
		GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX   = 0x801A,
		GLX_PRESERVED_CONTENTS_SGIX       = 0x801B,
		GLX_LARGEST_PBUFFER_SGIX          = 0x801C,
		GLX_WIDTH_SGIX                    = 0x801D,
		GLX_HEIGHT_SGIX                   = 0x801E,
		GLX_EVENT_MASK_SGIX               = 0x801F,
		GLX_DAMAGED_SGIX                  = 0x8020,
		GLX_SAVED_SGIX                    = 0x8021,
		GLX_WINDOW_SGIX                   = 0x8022,
		GLX_PBUFFER_SGIX                  = 0x8023,
		GLX_SYNC_FRAME_SGIX               = 0x00000000,
		GLX_SYNC_SWAP_SGIX                = 0x00000001,
		GLX_VISUAL_SELECT_GROUP_SGIX      = 0x8028,
	}

    struct GLXHyperpipeNetworkSGIX {
        char[80] pipeName; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
        int networkId;
    }

    struct GLXHyperpipeConfigSGIX {
        char[80] pipeName; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
        int chann;
        uint participationType;
        int timeSlice;
    }

    struct GLXPipeRect {
        char[80] pipeName; /* Should be [GLX_HYPERPIPE_PIPE_NAME NGTH_SGIX] */
        int srcXOrigin, srcYOrigin, srcWidth, srcHeight;
        int destXOrigin, destYOrigin, destWidth, destHeight;
    }

    struct GLXPipeRectLimits {
        char[80] pipeName; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
        int XOrigin, YOrigin, maxHeight, maxWidth;
    }

    // functions as types
    extern( C ) @nogc nothrow {
        // function types
        alias __GLXextFuncPtr = void function();

        // GLX_ARB_create_context
        alias da_glXCreateContextAttribsARB = GLXContext function( Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list );

        // GLX_ARB_get_proc_address
        alias da_glXGetProcAddressARB = __GLXextFuncPtr function( const GLubyte *procName );

        // GLX_EXT_import_context
        alias da_glXGetCurrentDisplayEXT = Display* function();
        alias da_glXQueryContextInfoEXT = int function( Display* dpy, GLXContext context, int attribute, int* value );
        alias da_glXGetContextIDEXT = GLXContextID function( const GLXContext context );
        alias da_glXImportContextEXT = GLXContext function( Display* dpy, GLXContextID contextID );
        alias da_glXFreeContextEXT = void function( Display* dpy, GLXContext context );

        // GLX_EXT_swap_control
        alias da_glXSwapIntervalEXT = void function( Display* dpy, GLXDrawable drawable, int interval );

        // GLX_EXT_texture_from_pixmap
        alias da_glXBindTexImageEXT = void function( Display* dpy, GLXDrawable drawable, int buffer, const int* attrib_list );
        alias da_glXReleaseTexImageEXT = void function( Display* dpy, GLXDrawable drawable, int buffer );

        // GLX_MESA_agp_offset
        alias da_glXGetAGPOffsetMESA = uint function( const void* pointer );

        // GLX_MESA_pixmap_colormap
        alias da_glXCreateGLXPixmapMESA = GLXPixmap function( Display* dpy, XVisualInfo* visual, Pixmap pixmap, Colormap cmap );

        // GLX_MESA_release_buffers
        alias da_glXReleaseBuffersMESA = Bool function( Display* dpy, GLXDrawable drawable );

        // GLX_MESA_set_3dfx_mode
        alias da_glXSet3DfxModeMESA = Bool function( int mode );

        // GLX_NV_copy_image
        alias da_glXCopyImageSubDataNV = void function( Display* dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth );

        // GLX_NV_present_video
        alias da_glXEnumerateVideoDevicesNV = uint* function( Display* dpy, int screen, int* nelements );
        alias da_glXBindVideoDeviceNV = int function( Display* dpy, uint video_slot, uint video_device, const int* attrib_list );

        // GLX_NV_swap_group
        alias da_glXJoinSwapGroupNV = Bool function( Display* dpy, GLXDrawable drawable, GLuint group );
        alias da_glXBindSwapBarrierNV = Bool function( Display* dpy, GLuint group, GLuint barrier );
        alias da_glXQuerySwapGroupNV = Bool function( Display* dpy, GLXDrawable drawable, GLuint* group, GLuint* barrier );
        alias da_glXQueryMaxSwapGroupsNV = Bool function( Display* dpy, int screen, GLuint* maxGroups, GLuint* maxBarriers );
        alias da_glXQueryFrameCountNV = Bool function( Display* dpy, int screen, GLuint* count );
        alias da_glXResetFrameCountNV = Bool function( Display* dpy, int screen );

        // GLX_NV_video_capture
        alias da_glXBindVideoCaptureDeviceNV = int function( Display* dpy, uint video_capture_slot, GLXVideoCaptureDeviceNV device );
        alias da_glXEnumerateVideoCaptureDevicesNV = GLXVideoCaptureDeviceNV* function( Display* dpy, int screen, int* nelements );
        alias da_glXLockVideoCaptureDeviceNV = void function( Display* dpy, GLXVideoCaptureDeviceNV device );
        alias da_glXQueryVideoCaptureDeviceNV = int function( Display* dpy, GLXVideoCaptureDeviceNV device, int attribute, int* value );
        alias da_glXReleaseVideoCaptureDeviceNV = void function( Display* dpy, GLXVideoCaptureDeviceNV device );

        // GLX_NV_video_output
        alias da_glXGetVideoDeviceNV = int function( Display* dpy, int screen, int numVideoDevices, GLXVideoDeviceNV* pVideoDevice );
        alias da_glXReleaseVideoDeviceNV = int function( Display* dpy, int screen, GLXVideoDeviceNV VideoDevice );
        alias da_glXBindVideoImageNV = int function( Display* dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer );
        alias da_glXReleaseVideoImageNV = int function( Display* dpy, GLXPbuffer pbuf );
        alias da_glXSendPbufferToVideoNV = int function( Display* dpy, GLXPbuffer pbuf, int iBufferType, ulong* pulCounterPbuffer, GLboolean bBlock );
        alias da_glXGetVideoInfoNV = int function( Display* dpy, int screen, GLXVideoDeviceNV VideoDevice, ulong* pulCounterOutputPbuffer, ulong* pulCounterOutputVideo );

        // GLX_OML_sync_control
        alias da_glXGetSyncValuesOML = Bool function( Display* dpy, GLXDrawable drawable, int64_t* ust, int64_t* msc, int64_t* sbc );
        alias da_glXGetMscRateOML = Bool function( Display* dpy, GLXDrawable drawable, int32_t* numerator, int32_t* denominator );
        alias da_glXSwapBuffersMscOML = int64_t function( Display* dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder );
        alias da_glXWaitForMscOML = Bool function( Display* dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t* ust, int64_t* msc, int64_t* sbc );
        alias da_glXWaitForSbcOML = Bool function( Display* dpy, GLXDrawable drawable, int64_t target_sbc, int64_t* ust, int64_t* msc, int64_t* sbc );

        // GLX_SGIX_fbconfig
        alias da_glXGetFBConfigAttribSGIX = int function( Display* dpy, GLXFBConfigSGIX config, int attribute, int* value );
        alias da_glXChooseFBConfigSGIX = GLXFBConfigSGIX* function( Display* dpy, int screen, int* attrib_list, int* nelements );
        alias da_glXCreateGLXPixmapWithConfigSGIX = GLXPixmap function( Display* dpy, GLXFBConfigSGIX config, Pixmap pixmap );
        alias da_glXCreateContextWithConfigSGIX = GLXContext function( Display* dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct );
        alias da_glXGetVisualFromFBConfigSGIX = XVisualInfo* function( Display* dpy, GLXFBConfigSGIX config );
        alias da_glXGetFBConfigFromVisualSGIX = GLXFBConfigSGIX function( Display* dpy, XVisualInfo* vis );

        // GLX_SGIX_hyperpipe
        alias da_glXQueryHyperpipeNetworkS = GLXHyperpipeNetworkSGIX* function( Display* dpy, int* npipes );
        alias da_glXHyperpipeConfigSGIX = int function( Display* dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX* cfg, int* hpId );
        alias da_glXQueryHyperpipeConfigSGIX = GLXHyperpipeConfigSGIX* function( Display* dpy, int hpId, int* npipes );
        alias da_glXDestroyHyperpipeConfigSGIX = int function( Display* dpy, int hpId );
        alias da_glXBindHyperpipeSGIX = int function( Display* dpy, int hpId );
        alias da_glXQueryHyperpipeBestAttribSGIX = int function( Display* dpy, int timeSlice, int attrib, int size, void* attribList, void* returnAttribList );
        alias da_glXHyperpipeAttribSGIX = int function( Display* dpy, int timeSlice, int attrib, int size, void* attribList );
        alias da_glXQueryHyperpipeAttribSGIX = int function( Display* dpy, int timeSlice, int attrib, int size, void* returnAttribList );

        // GLX_SGIX_pbuffer
        alias da_glXCreateGLXPbufferSGIX = GLXPbufferSGIX function( Display* dpy, GLXFBConfigSGIX config, uint width, uint height, int* attrib_list );
        alias da_glXDestroyGLXPbufferSGIX = void function( Display* dpy, GLXPbufferSGIX pbuf );
        alias da_glXQueryGLXPbufferSGIX = int function( Display* dpy, GLXPbufferSGIX pbuf, int attribute, uint* value );
        alias da_glXSelectEventSGIX = void function( Display* dpy, GLXDrawable drawable, ulong mask );
        alias da_glXGetSelectedEventSGIX = void function( Display* dpy, GLXDrawable drawable, ulong* mask );

        // GLX_SGIX_swap_barrier
        alias da_glXBindSwapBarrierSGIX = void function( Display* dpy, GLXDrawable drawable, int barrier );
        alias da_glXQueryMaxSwapBarriersSGIX = Bool function( Display* dpy, int screen, int* max );

        // GLX_SGIX_swap_group
        alias da_glXJoinSwapGroupSGIX = void function( Display* dpy, GLXDrawable drawable, GLXDrawable member );

        // GLX_SGIX_video_source
        alias da_glXBindChannelToWindowSGIX = int function( Display* display, int screen, int channel, Window window );
        alias da_glXChannelRectSGIX = int function( Display* display, int screen, int channel, int x, int y, int w, int h );
        alias da_glXQueryChannelRectSGIX = int function( Display* display, int screen, int channel, int* dx, int* dy, int* dw, int* dh );
        alias da_glXQueryChannelDeltasSGIX = int function( Display* display, int screen, int channel, int* x, int* y, int* w, int* h );
        alias da_glXChannelRectSyncSGIX = int function( Display* display, int screen, int channel, GLenum synctype );

        // GLX_SGI_cushion
        alias da_glXCushionSGI = void function( Display* dpy, Window window, float cushion );

        // GLX_SGI_swap_control
        alias da_glXSwapIntervalSGI = int function( int interval );

        // GLX_SGI_video_sync
        alias da_glXGetVideoSyncSGI = int function( uint* count );
        alias da_glXWaitVideoSyncSGI = int function( int divisor, int remainder, uint* count );

        // GLX_SUN_get_transparent_index
        alias da_glXGetTransparentIndexSUN = Status function( Display* dpy, Window overlay, Window underlay, long* pTransparentIndex );
    }

    // function declarations
    __gshared {
        // GLX_ARB_create_context
        da_glXCreateContextAttribsARB glXCreateContextAttribsARB;

        // GLX_ARB_get_proc_address
        da_glXGetProcAddressARB glXGetProcAddressARB;

        // GLX_EXT_import_context
        da_glXGetCurrentDisplayEXT glXGetCurrentDisplayEXT;
        da_glXQueryContextInfoEXT glXQueryContextInfoEXT;
        da_glXGetContextIDEXT glXGetContextIDEXT;
        da_glXImportContextEXT glXImportContextEXT;
        da_glXFreeContextEXT glXFreeContextEXT;

        // GLX_EXT_swap_control
        da_glXSwapIntervalEXT glXSwapIntervalEXT;

        // GLX_EXT_texture_from_pixmap
        da_glXBindTexImageEXT glXBindTexImageEXT;
        da_glXReleaseTexImageEXT glXReleaseTexImageEXT;

        // GLX_MESA_agp_offset
        da_glXGetAGPOffsetMESA glXGetAGPOffsetMESA;

        // GLX_MESA_pixmap_colormap
        da_glXCreateGLXPixmapMESA glXCreateGLXPixmapMESA;

        // GLX_MESA_release_buffers
        da_glXReleaseBuffersMESA glXReleaseBuffersMESA;

        // GLX_MESA_set_3dfx_mode
        da_glXSet3DfxModeMESA glXSet3DfxModeMESA;

        // GLX_NV_copy_image
        da_glXCopyImageSubDataNV glXCopyImageSubDataNV;

        // GLX_NV_present_video
        da_glXEnumerateVideoDevicesNV glXEnumerateVideoDevicesNV;
        da_glXBindVideoDeviceNV glXBindVideoDeviceNV;

        // GLX_NV_swap_group
        da_glXJoinSwapGroupNV glXJoinSwapGroupNV;
        da_glXBindSwapBarrierNV glXBindSwapBarrierNV;
        da_glXQuerySwapGroupNV glXQuerySwapGroupNV;
        da_glXQueryMaxSwapGroupsNV glXQueryMaxSwapGroupsNV;
        da_glXQueryFrameCountNV glXQueryFrameCountNV;
        da_glXResetFrameCountNV glXResetFrameCountNV;

        // GLX_NV_video_capture
        da_glXBindVideoCaptureDeviceNV glXBindVideoCaptureDeviceNV;
        da_glXEnumerateVideoCaptureDevicesNV glXEnumerateVideoCaptureDevicesNV;
        da_glXLockVideoCaptureDeviceNV glXLockVideoCaptureDeviceNV;
        da_glXQueryVideoCaptureDeviceNV glXQueryVideoCaptureDeviceNV;
        da_glXReleaseVideoCaptureDeviceNV glXReleaseVideoCaptureDeviceNV;

        // GLX_NV_video_output
        da_glXGetVideoDeviceNV glXGetVideoDeviceNV;
        da_glXReleaseVideoDeviceNV glXReleaseVideoDeviceNV;
        da_glXBindVideoImageNV glXBindVideoImageNV;
        da_glXReleaseVideoImageNV glXReleaseVideoImageNV;
        da_glXSendPbufferToVideoNV glXSendPbufferToVideoNV;
        da_glXGetVideoInfoNV glXGetVideoInfoNV;

        // GLX_OML_sync_control
        da_glXGetSyncValuesOML glXGetSyncValuesOML;
        da_glXGetMscRateOML glXGetMscRateOML;
        da_glXSwapBuffersMscOML glXSwapBuffersMscOML;
        da_glXWaitForMscOML glXWaitForMscOML;
        da_glXWaitForSbcOML glXWaitForSbcOML;

        // GLX_SGIX_fbconfig
        da_glXGetFBConfigAttribSGIX glXGetFBConfigAttribSGIX;
        da_glXChooseFBConfigSGIX glXChooseFBConfigSGIX;
        da_glXCreateGLXPixmapWithConfigSGIX glXCreateGLXPixmapWithConfigSGIX;
        da_glXCreateContextWithConfigSGIX glXCreateContextWithConfigSGIX;
        da_glXGetVisualFromFBConfigSGIX glXGetVisualFromFBConfigSGIX;
        da_glXGetFBConfigFromVisualSGIX glXGetFBConfigFromVisualSGIX;

        // GLX_SGIX_hyperpipe
        da_glXQueryHyperpipeNetworkS glXQueryHyperpipeNetworkS;
        da_glXHyperpipeConfigSGIX glXHyperpipeConfigSGIX;
        da_glXQueryHyperpipeConfigSGIX glXQueryHyperpipeConfigSGIX;
        da_glXDestroyHyperpipeConfigSGIX glXDestroyHyperpipeConfigSGIX;
        da_glXBindHyperpipeSGIX glXBindHyperpipeSGIX;
        da_glXQueryHyperpipeBestAttribSGIX glXQueryHyperpipeBestAttribSGIX;
        da_glXHyperpipeAttribSGIX glXHyperpipeAttribSGIX;
        da_glXQueryHyperpipeAttribSGIX glXQueryHyperpipeAttribSGIX;

        // GLX_SGIX_pbuffer
        da_glXCreateGLXPbufferSGIX glXCreateGLXPbufferSGIX;
        da_glXDestroyGLXPbufferSGIX glXDestroyGLXPbufferSGIX;
        da_glXQueryGLXPbufferSGIX glXQueryGLXPbufferSGIX;
        da_glXSelectEventSGIX glXSelectEventSGIX;
        da_glXGetSelectedEventSGIX glXGetSelectedEventSGIX;

        // GLX_SGIX_swap_barrier
        da_glXBindSwapBarrierSGIX glXBindSwapBarrierSGIX;
        da_glXQueryMaxSwapBarriersSGIX glXQueryMaxSwapBarriersSGIX;

        // GLX_SGIX_swap_group
        da_glXJoinSwapGroupSGIX glXJoinSwapGroupSGIX;

        // GLX_SGIX_video_source
        da_glXBindChannelToWindowSGIX glXBindChannelToWindowSGIX;
        da_glXChannelRectSGIX glXChannelRectSGIX;
        da_glXQueryChannelRectSGIX glXQueryChannelRectSGIX;
        da_glXQueryChannelDeltasSGIX glXQueryChannelDeltasSGIX;
        da_glXChannelRectSyncSGIX glXChannelRectSyncSGIX;

        // GLX_SGI_cushion
        da_glXCushionSGI glXCushionSGI;

        // GLX_SGI_swap_control
        da_glXSwapIntervalSGI glXSwapIntervalSGI;

        // GLX_SGI_video_sync
        da_glXGetVideoSyncSGI glXGetVideoSyncSGI;
        da_glXWaitVideoSyncSGI glXWaitVideoSyncSGI;

        // GLX_SUN_get_transparent_index
        da_glXGetTransparentIndexSUN glXGetTransparentIndexSUN;
    }

    private __gshared bool _GLX_ARB_create_context;
    private __gshared bool _GLX_ARB_get_proc_address;
    private __gshared bool _GLX_EXT_import_context;
    private __gshared bool _GLX_EXT_swap_control;
    private __gshared bool _GLX_EXT_texture_from_pixmap;
    private __gshared bool _GLX_MESA_agp_offset;
    private __gshared bool _GLX_MESA_pixmap_colormap;
    private __gshared bool _GLX_MESA_release_buffers;
    private __gshared bool _GLX_MESA_set_3dfx_mode;
    private __gshared bool _GLX_NV_copy_image;
    private __gshared bool _GLX_NV_present_video;
    private __gshared bool _GLX_NV_swap_group;
    private __gshared bool _GLX_NV_video_capture;
    private __gshared bool _GLX_NV_video_output;
    private __gshared bool _GLX_OML_sync_control;
    private __gshared bool _GLX_SGIX_fbconfig;
    private __gshared bool _GLX_SGIX_hyperpipe;
    private __gshared bool _GLX_SGIX_pbuffer;
    private __gshared bool _GLX_SGIX_swap_barrier;
    private __gshared bool _GLX_SGIX_swap_group;
    private __gshared bool _GLX_SGIX_video_source;
    private __gshared bool _GLX_SGI_cushion;
    private __gshared bool _GLX_SGI_swap_control;
    private __gshared bool _GLX_SGI_video_sync;
    private __gshared bool _GLX_SUN_get_transparent_index;

    @nogc nothrow {
        bool GLX_ARB_create_context() @property { return _GLX_ARB_create_context; }
        bool GLX_ARB_get_proc_address() @property { return _GLX_ARB_get_proc_address; }
        bool GLX_EXT_import_context() @property { return _GLX_EXT_import_context; }
        bool GLX_EXT_swap_control() @property { return _GLX_EXT_swap_control; }
        bool GLX_EXT_texture_from_pixmap() @property { return _GLX_EXT_texture_from_pixmap; }
        bool GLX_MESA_agp_offset() @property { return _GLX_MESA_agp_offset; }
        bool GLX_MESA_pixmap_colormap() @property { return _GLX_MESA_pixmap_colormap; }
        bool GLX_MESA_release_buffers() @property { return _GLX_MESA_release_buffers; }
        bool GLX_MESA_set_3dfx_mode() @property { return _GLX_MESA_set_3dfx_mode; }
        bool GLX_NV_copy_image() @property { return _GLX_NV_copy_image; }
        bool GLX_NV_present_video() @property { return _GLX_NV_present_video; }
        bool GLX_NV_swap_group() @property { return _GLX_NV_swap_group; }
        bool GLX_NV_video_capture() @property { return _GLX_NV_video_capture; }
        bool GLX_NV_video_output() @property { return _GLX_NV_video_output; }
        bool GLX_OML_sync_control() @property { return _GLX_OML_sync_control; }
        bool GLX_SGIX_fbconfig() @property { return _GLX_SGIX_fbconfig; }
        bool GLX_SGIX_hyperpipe() @property { return _GLX_SGIX_hyperpipe; }
        bool GLX_SGIX_pbuffer() @property { return _GLX_SGIX_pbuffer; }
        bool GLX_SGIX_swap_barrier() @property { return _GLX_SGIX_swap_barrier; }
        bool GLX_SGIX_swap_group() @property { return _GLX_SGIX_swap_group; }
        bool GLX_SGIX_video_source() @property { return _GLX_SGIX_video_source; }
        bool GLX_SGI_cushion() @property { return _GLX_SGI_cushion; }
        bool GLX_SGI_swap_control() @property { return _GLX_SGI_swap_control; }
        bool GLX_SGI_video_sync() @property { return _GLX_SGI_video_sync; }
        bool GLX_SUN_get_transparent_index() @property { return _GLX_SUN_get_transparent_index; }
    }

    private bool isGLXExtSupported( string name ) {
        if ( !glXGetCurrentDisplayEXT ) {
            // Can't get the current display, so assume the worst.
            return false;
        }

        auto display = glXGetCurrentDisplayEXT();

        return findEXT( glXQueryExtensionsString( display, 0 ), name );
    }

    package void loadPlatformEXT( GLVersion glversion ) {
        // glXGetCurrentDisplayEXT is needed to properly load the other extensions, so attempt
        // to load GLX_EXT_import_context first.
        if ( !glXGetCurrentDisplayEXT ) {
            try {
                bindGLFunc( cast( void** )&glXGetCurrentDisplayEXT, "glXGetCurrentDisplayEXT" );
                bindGLFunc( cast( void** )&glXQueryContextInfoEXT, "glXQueryContextInfoEXT" );
                bindGLFunc( cast( void** )&glXGetContextIDEXT, "glXGetContextIDEXT" );
                bindGLFunc( cast( void** )&glXImportContextEXT, "glXImportContextEXT" );
                bindGLFunc( cast( void** )&glXFreeContextEXT, "glXFreeContextEXT" );
                _GLX_EXT_import_context = true;
            } catch ( Exception e ) {
                _GLX_EXT_import_context = false;
            }
        }

        // GLX_ARB_create_context
        _GLX_ARB_create_context = isGLXExtSupported( "GLX_ARB_create_context" );
        if ( _GLX_ARB_create_context ) {
            try {
                bindGLFunc( cast( void** )&glXCreateContextAttribsARB, "glXCreateContextAttribsARB" );
                _GLX_ARB_create_context = true;
            } catch ( Exception e ) {
                _GLX_ARB_create_context = false;
            }
        }

        // GLX_ARB_get_proc_address
        _GLX_ARB_get_proc_address = isGLXExtSupported( "GLX_ARB_get_proc_address" );
        if ( _GLX_ARB_get_proc_address )
        {
            try {
                bindGLFunc( cast( void** )&glXGetProcAddressARB, "glXGetProcAddressARB" );
                _GLX_ARB_get_proc_address = true;
            } catch ( Exception e ) {
                _GLX_ARB_get_proc_address = false;
            }
        }

        // GLX_EXT_swap_control
        _GLX_EXT_swap_control = isGLXExtSupported( "GLX_EXT_swap_control" );
        if ( _GLX_EXT_swap_control ) {
            try {
                bindGLFunc( cast( void** )&glXSwapIntervalEXT, "glXSwapIntervalEXT" );
                _GLX_EXT_swap_control = true;
            } catch ( Exception e ) {
                _GLX_EXT_swap_control = false;
            }
        }

        // GLX_EXT_texture_from_pixmap
        _GLX_EXT_texture_from_pixmap = isGLXExtSupported( "GLX_EXT_texture_from_pixmap" );
        if ( _GLX_EXT_texture_from_pixmap ) {
            try {
                bindGLFunc( cast( void** )&glXBindTexImageEXT, "glXBindTexImageEXT" );
                bindGLFunc( cast( void** )&glXReleaseTexImageEXT, "glXReleaseTexImageEXT" );
                _GLX_EXT_texture_from_pixmap = true;
            } catch ( Exception e ) {
                _GLX_EXT_texture_from_pixmap = false;
            }
        }

        // GLX_MESA_agp_offset
        _GLX_MESA_agp_offset = isGLXExtSupported( "GLX_MESA_agp_offset" );
        if ( _GLX_MESA_agp_offset ) {
            try {
                bindGLFunc( cast( void** )&glXGetAGPOffsetMESA, "glXGetAGPOffsetMESA" );
                _GLX_MESA_agp_offset = true;
            } catch ( Exception e ) {
                _GLX_MESA_agp_offset = false;
            }
        }

        // GLX_MESA_pixmap_colormap
        _GLX_MESA_pixmap_colormap = isGLXExtSupported( "GLX_MESA_pixmap_colormap" );
        if ( _GLX_MESA_pixmap_colormap ) {
            try {
                bindGLFunc( cast( void** )&glXCreateGLXPixmapMESA, "glXCreateGLXPixmapMESA" );
                _GLX_MESA_pixmap_colormap = true;
            } catch ( Exception e ) {
                _GLX_MESA_pixmap_colormap = false;
            }
        }

        // GLX_MESA_release_buffers
        _GLX_MESA_release_buffers = isGLXExtSupported( "GLX_MESA_release_buffers" );
        if ( _GLX_MESA_release_buffers ) {
            try {
                bindGLFunc( cast( void** )&glXReleaseBuffersMESA, "glXReleaseBuffersMESA" );
                _GLX_MESA_release_buffers = true;
            } catch ( Exception e ) {
                _GLX_MESA_release_buffers = false;
            }
        }

        // GLX_MESA_set_3dfx_mode
        _GLX_MESA_set_3dfx_mode = isGLXExtSupported( "GLX_MESA_set_3dfx_mode" );
        if ( _GLX_MESA_set_3dfx_mode ) {
            try {
                bindGLFunc( cast( void** )&glXSet3DfxModeMESA, "glXSet3DfxModeMESA" );
                _GLX_MESA_set_3dfx_mode = true;
            } catch ( Exception e ) {
                _GLX_MESA_set_3dfx_mode = false;
            }
        }
        // GLX_NV_copy_image
        _GLX_NV_copy_image = isGLXExtSupported( "GLX_NV_copy_image" );
        if ( _GLX_NV_copy_image ) {
            try {
                bindGLFunc( cast( void** )&glXCopyImageSubDataNV, "glXCopyImageSubDataNV" );
                _GLX_NV_copy_image = true;
            } catch ( Exception e ) {
                _GLX_NV_copy_image = false;
            }
        }

        // GLX_NV_present_video
        _GLX_NV_present_video = isGLXExtSupported( "GLX_NV_present_video" );
        if ( _GLX_NV_present_video ) {
            try {
                bindGLFunc( cast( void** )&glXEnumerateVideoDevicesNV, "glXEnumerateVideoDevicesNV" );
                bindGLFunc( cast( void** )&glXBindVideoDeviceNV, "glXBindVideoDeviceNV" );
                _GLX_NV_present_video = true;
            } catch ( Exception e ) {
                _GLX_NV_present_video = false;
            }
        }

        // GLX_NV_swap_group
        _GLX_NV_swap_group = isGLXExtSupported( "GLX_NV_swap_group" );
        if ( _GLX_NV_swap_group ) {
            try {
                bindGLFunc( cast( void** )&glXJoinSwapGroupNV, "glXJoinSwapGroupNV" );
                bindGLFunc( cast( void** )&glXBindSwapBarrierNV, "glXBindSwapBarrierNV" );
                bindGLFunc( cast( void** )&glXQuerySwapGroupNV, "glXQuerySwapGroupNV" );
                bindGLFunc( cast( void** )&glXQueryMaxSwapGroupsNV, "glXQueryMaxSwapGroupsNV" );
                bindGLFunc( cast( void** )&glXQueryFrameCountNV, "glXQueryFrameCountNV" );
                bindGLFunc( cast( void** )&glXResetFrameCountNV, "glXResetFrameCountNV" );
                _GLX_NV_swap_group = true;
            } catch ( Exception e ) {
                _GLX_NV_swap_group = false;
            }
        }

        // GLX_NV_video_capture
        _GLX_NV_video_capture = isGLXExtSupported( "GLX_NV_video_capture" );
        if ( _GLX_NV_video_capture ) {
            try {
                bindGLFunc( cast( void** )&glXBindVideoCaptureDeviceNV, "glXBindVideoCaptureDeviceNV" );
                bindGLFunc( cast( void** )&glXEnumerateVideoCaptureDevicesNV, "glXEnumerateVideoCaptureDevicesNV" );
                bindGLFunc( cast( void** )&glXLockVideoCaptureDeviceNV, "glXLockVideoCaptureDeviceNV" );
                bindGLFunc( cast( void** )&glXQueryVideoCaptureDeviceNV, "glXQueryVideoCaptureDeviceNV" );
                bindGLFunc( cast( void** )&glXReleaseVideoCaptureDeviceNV, "glXReleaseVideoCaptureDeviceNV" );
                _GLX_NV_video_capture= true;
            } catch ( Exception e ) {
                _GLX_NV_video_capture = false;
            }
        }

        // GLX_NV_video_output
        _GLX_NV_video_output = isGLXExtSupported( "GLX_NV_video_output" );
        if ( _GLX_NV_video_output ) {
            try {
                bindGLFunc( cast( void** )&glXGetVideoDeviceNV, "glXGetVideoDeviceNV" );
                bindGLFunc( cast( void** )&glXReleaseVideoDeviceNV, "glXReleaseVideoDeviceNV" );
                bindGLFunc( cast( void** )&glXBindVideoImageNV, "glXBindVideoImageNV" );
                bindGLFunc( cast( void** )&glXReleaseVideoImageNV, "glXReleaseVideoImageNV" );
                bindGLFunc( cast( void** )&glXSendPbufferToVideoNV, "glXSendPbufferToVideoNV" );
                bindGLFunc( cast( void** )&glXGetVideoInfoNV, "glXGetVideoInfoNV" );
                _GLX_NV_video_output = true;
            } catch ( Exception e ) {
                _GLX_NV_video_output = false;
            }
        }

        // GLX_OML_sync_control
        _GLX_OML_sync_control = isGLXExtSupported( "GLX_OML_sync_control" );
        if ( _GLX_OML_sync_control ) {
            try {
                bindGLFunc( cast( void** )&glXGetSyncValuesOML, "glXGetSyncValuesOML" );
                bindGLFunc( cast( void** )&glXGetMscRateOML, "glXGetMscRateOML" );
                bindGLFunc( cast( void** )&glXSwapBuffersMscOML, "glXSwapBuffersMscOML" );
                bindGLFunc( cast( void** )&glXWaitForMscOML, "glXWaitForMscOML" );
                bindGLFunc( cast( void** )&glXWaitForSbcOML, "glXWaitForSbcOML" );
                _GLX_OML_sync_control = true;
            } catch ( Exception e ) {
                _GLX_OML_sync_control = false;
            }
        }

        // GLX_SGIX_fbconfig
        _GLX_SGIX_fbconfig = isGLXExtSupported( "GLX_SGIX_fbconfig" );
        if ( _GLX_SGIX_fbconfig ) {
            try {
                bindGLFunc( cast( void** )&glXGetFBConfigAttribSGIX, "glXGetFBConfigAttribSGIX" );
                bindGLFunc( cast( void** )&glXChooseFBConfigSGIX, "glXChooseFBConfigSGIX" );
                bindGLFunc( cast( void** )&glXCreateGLXPixmapWithConfigSGIX, "glXCreateGLXPixmapWithConfigSGIX" );
                bindGLFunc( cast( void** )&glXCreateContextWithConfigSGIX, "glXCreateContextWithConfigSGIX" );
                bindGLFunc( cast( void** )&glXGetVisualFromFBConfigSGIX, "glXGetVisualFromFBConfigSGIX" );
                bindGLFunc( cast( void** )&glXGetFBConfigFromVisualSGIX, "glXGetFBConfigFromVisualSGIX" );
                _GLX_SGIX_fbconfig = true;
            } catch ( Exception e ) {
                _GLX_SGIX_fbconfig = false;
            }
        }

        // GLX_SGIX_hyperpipe
        _GLX_SGIX_hyperpipe = isGLXExtSupported( "GLX_SGIX_hyperpipe" );
        if ( _GLX_SGIX_hyperpipe ) {
            try {
                bindGLFunc( cast( void** )&glXQueryHyperpipeNetworkS, "glXQueryHyperpipeNetworkS" );
                bindGLFunc( cast( void** )&glXHyperpipeConfigSGIX, "glXHyperpipeConfigSGIX" );
                bindGLFunc( cast( void** )&glXQueryHyperpipeConfigSGIX, "glXQueryHyperpipeConfigSGIX" );
                bindGLFunc( cast( void** )&glXDestroyHyperpipeConfigSGIX, "glXDestroyHyperpipeConfigSGIX" );
                bindGLFunc( cast( void** )&glXBindHyperpipeSGIX, "glXBindHyperpipeSGIX" );
                bindGLFunc( cast( void** )&glXQueryHyperpipeBestAttribSGIX, "glXQueryHyperpipeBestAttribSGIX" );
                bindGLFunc( cast( void** )&glXHyperpipeAttribSGIX, "glXHyperpipeAttribSGIX" );
                bindGLFunc( cast( void** )&glXQueryHyperpipeAttribSGIX, "glXQueryHyperpipeAttribSGIX" );
                _GLX_SGIX_hyperpipe = true;
            } catch ( Exception e ) {
                _GLX_SGIX_hyperpipe = false;
            }
        }

        // GLX_SGIX_pbuffer
        _GLX_SGIX_pbuffer = isGLXExtSupported( "GLX_SGIX_pbuffer" );
        if ( _GLX_SGIX_pbuffer ) {
            try {
                bindGLFunc( cast( void** )&glXCreateGLXPbufferSGIX, "glXCreateGLXPbufferSGIX" );
                bindGLFunc( cast( void** )&glXDestroyGLXPbufferSGIX, "glXDestroyGLXPbufferSGIX" );
                bindGLFunc( cast( void** )&glXQueryGLXPbufferSGIX, "glXQueryGLXPbufferSGIX" );
                bindGLFunc( cast( void** )&glXSelectEventSGIX, "glXSelectEventSGIX" );
                bindGLFunc( cast( void** )&glXGetSelectedEventSGIX, "glXGetSelectedEventSGIX" );
                _GLX_SGIX_pbuffer = true;
            } catch ( Exception e ) {
                _GLX_SGIX_pbuffer = false;
            }
        }

        // GLX_SGIX_swap_barrier
        _GLX_SGIX_swap_barrier = isGLXExtSupported( "GLX_SGIX_swap_barrier" );
        if ( _GLX_SGIX_swap_barrier ) {
            try {
                bindGLFunc( cast( void** )&glXBindSwapBarrierSGIX, "glXBindSwapBarrierSGIX" );
                bindGLFunc( cast( void** )&glXQueryMaxSwapBarriersSGIX, "glXQueryMaxSwapBarriersSGIX" );
                _GLX_SGIX_swap_barrier = true;
            } catch ( Exception e ) {
                _GLX_SGIX_swap_barrier = false;
            }
        }

        // GLX_SGIX_swap_group
        _GLX_SGIX_swap_group = isGLXExtSupported( "GLX_SGIX_swap_group" );
        if ( _GLX_SGIX_swap_group ) {
            try {
                bindGLFunc( cast( void** )&glXJoinSwapGroupSGIX, "glXJoinSwapGroupSGIX" );
                _GLX_SGIX_swap_group = true;
            } catch ( Exception e ) {
                _GLX_SGIX_swap_group = false;
            }
        }
        // GLX_SGIX_video_source
        _GLX_SGIX_video_source = isGLXExtSupported( "GLX_SGIX_video_source" );
        if ( _GLX_SGIX_video_source ) {
            try {
                bindGLFunc( cast( void** )&glXBindChannelToWindowSGIX, "glXBindChannelToWindowSGIX" );
                bindGLFunc( cast( void** )&glXChannelRectSGIX, "glXChannelRectSGIX" );
                bindGLFunc( cast( void** )&glXQueryChannelRectSGIX, "glXQueryChannelRectSGIX" );
                bindGLFunc( cast( void** )&glXQueryChannelDeltasSGIX, "glXQueryChannelDeltasSGIX" );
                bindGLFunc( cast( void** )&glXChannelRectSyncSGIX, "glXChannelRectSyncSGIX" );
                _GLX_SGIX_video_source = true;
            } catch ( Exception e ) {
                _GLX_SGIX_video_source = false;
            }
        }

        // GLX_SGI_cushion
        _GLX_SGI_cushion = isGLXExtSupported( "GLX_SGI_cushion" );
        if ( _GLX_SGI_cushion ) {
            try {
                bindGLFunc( cast( void** )&glXCushionSGI, "glXCushionSGI" );
                _GLX_SGI_cushion = true;
            } catch ( Exception e ) {
                _GLX_SGI_cushion = false;
            }
        }

        // GLX_SGI_swap_control
        _GLX_SGI_swap_control = isGLXExtSupported( "GLX_SGI_swap_control" );
        if ( _GLX_SGI_swap_control ) {
            try {
                bindGLFunc( cast( void** )&glXSwapIntervalSGI, "glXSwapIntervalSGI" );
                _GLX_SGI_swap_control = true;
            } catch ( Exception e ) {
                _GLX_SGI_swap_control = false;
            }
        }

        // GLX_SGI_video_sync
        _GLX_SGI_video_sync = isGLXExtSupported( "GLX_SGI_video_sync" );
        if ( _GLX_SGI_video_sync ) {
            try {
                bindGLFunc( cast( void** )&glXGetVideoSyncSGI, "glXGetVideoSyncSGI" );
                bindGLFunc( cast( void** )&glXWaitVideoSyncSGI, "glXWaitVideoSyncSGI" );
                _GLX_SGI_video_sync = true;
            } catch ( Exception e ) {
                _GLX_SGI_video_sync= false;
            }
        }

        // GLX_SUN_get_transparent_index
        _GLX_SUN_get_transparent_index = isGLXExtSupported( "GLX_SUN_get_transparent_index" );
        if ( _GLX_SUN_get_transparent_index ) {
            try {
                bindGLFunc( cast( void** )&glXGetTransparentIndexSUN, "glXGetTransparentIndexSUN" );
                _GLX_SUN_get_transparent_index = true;
            } catch ( Exception e ) {
                _GLX_SUN_get_transparent_index = false;
            }
        }
    }
}
