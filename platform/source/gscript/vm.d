/*
Copyright (c) 2025 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module gscript.vm;

import std.stdio;
import std.conv;
import std.traits;
import std.algorithm;
import std.array;
import std.ascii;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.container.array;
import dlib.container.dict;

import gscript.arena;
import gscript.instructions;
import gscript.dynamic;
import gscript.stdlib.builtins;
import gscript.stdlib.lib;
import gscript.stdlib.str;
import gscript.stdlib.io;
import gscript.stdlib.time;

interface GsObject
{
    GsDynamic get(string key);
    void set(string key, GsDynamic value);
    bool contains(string key);
    void setPrototype(GsObject);
    
    final GsDynamic opIndex(string key)
    {
        if (contains(key))
            return get(key);
        else
            return GsDynamic();
    }
    
    final T opIndexAssign(T)(T value, string key)
    {
        set(key, GsDynamic(value));
        return value;
    }
}

class GsArenaObject: GsObject
{
    GsArena arena;
    GsObject prototype;
    Dict!(GsDynamic, string) storage;
    
    this(GsArena arena)
    {
        this.arena = arena;
        storage = dict!(GsDynamic, string);
    }
    
    ~this()
    {
        Delete(storage);
    }
    
    GsDynamic get(string key)
    {
        auto v = key in storage;
        if (v)
            return *v;
        else
        {
            if (prototype)
                return prototype.get(key);
            else
                return GsDynamic();
        }
    }
    
    void set(string key, GsDynamic value)
    {
        storage[key] = value;
    }
    
    bool contains(string key)
    {
        if ((key in storage) !is null)
            return true;
        else
        {
            if (prototype)
                return prototype.contains(key);
            else
                return false;
        }
    }
    
    void setPrototype(GsObject proto)
    {
        prototype = proto;
    }
}

struct GsCallFrame
{
    string name;
    GsDynamic[128] parameters;
    GsDynamic[128] localVariables;
    size_t numParameters;
    size_t returnAddress;
    GsLibrary returnLibrary;
}

class GsLibrary: Owner, GsObject
{
    string name;
    GsInstruction[] instructions;     // Program code
    Dict!(size_t, string) jumpTable;  // Function table mapping names to instruction indices
    GsDynamic[128] rootVariables;     // Global (root-scope) variables
    
    this(string name, Owner owner = null)
    {
        super(owner);
        this.name = name;
        jumpTable = dict!(size_t, string);
    }
    
    ~this()
    {
        Delete(jumpTable);
    }
    
    void load(GsInstruction[] instructions)
    {
        this.instructions = instructions;
        
        // Populate the function table with label indices
        foreach(i, instrunction; instructions)
        {
            if (instrunction.type == GsInstructionType.LABEL)
            {
                jumpTable[instrunction.operand.asString] = i;
            }
        }
    }
    
    GsDynamic get(string key)
    {
        auto v = key in jumpTable;
        if (v)
        {
            GsDynamic fun = GsDynamic(key);
            fun.hintBits |= GsSemanticsHint.LibraryFunctionBit;
            return fun;
        }
        else
            return GsDynamic();
    }
    
    void set(string key, GsDynamic value)
    {
        // No-op
    }
    
    bool contains(string key)
    {
        return (key in jumpTable) !is null;
    }
    
    void setPrototype(GsObject proto)
    {
        // No-op
    }
}

class GsVirtualMachine: Owner, GsObject
{
    Dict!(GsDynamic, string) globals; // Built-in variables
    
    GsLibrary mainLibrary;
    
    // Standard library
    GsGlobalLibrarian globLibrarian;
    GsGlobalBuiltins globBuiltins;
    GsGlobalStr globStr;
    GsGlobalIO globIO;
    GsGlobalTime globTime;
    
    GsArena heap;
    
    Array!GsThread threads;
    GsThread mainThread;
    
    GsThread currentThread;
    
    bool running = false;
    
    size_t numActiveThreads = 0;
    
    this(Owner owner = null)
    {
        super(owner);
        heap = New!GsArena(1024 * 10, this);
        
        mainLibrary = New!GsLibrary("main", this);
        
        globals = dict!(GsDynamic, string);
        
        globBuiltins = heap.create!GsGlobalBuiltins(heap);
        globals["builtins"] = GsDynamic(globBuiltins);
        
        globLibrarian = heap.create!GsGlobalLibrarian(this);
        globals["lib"] = GsDynamic(globLibrarian);
        
        globStr = heap.create!GsGlobalStr(heap);
        globals["string"] = GsDynamic(globStr);
        
        globIO = heap.create!GsGlobalIO(heap);
        globals["io"] = GsDynamic(globIO);
        
        globTime = heap.create!GsGlobalTime(heap);
        globals["time"] = GsDynamic(globTime);
        
        globals["channel"] = GsDynamic(&bindCreateChannel);
        
        mainThread = New!GsThread(this);
        mainThread.setPayload(this);
        mainThread.library = mainLibrary;
        mainThread.callFrame.name = mainLibrary.name;
        threads.append(mainThread);
        
        foreach (i; 0..31)
        {
            auto idleThread = New!GsThread(this);
            threads.append(idleThread);
        }
    }
    
    ~this()
    {
        Delete(globals);
        threads.free();
    }
    
    // GsObject methods:
    
    GsDynamic get(string key)
    {
        // TODO: move this to "global.thread" object
        if (key == "numActiveThreads")
            return GsDynamic(cast(double)numActiveThreads);
        else if (key == "numThreads")
            return GsDynamic(cast(double)threads.length);
        
        auto v = key in globals;
        if (v)
            return *v;
        else
            return GsDynamic();
    }

    void set(string key, GsDynamic value)
    {
        globals[key] = value;
    }

    bool contains(string key)
    {
        return (key in globals) !is null;
    }
    
    void setPrototype(GsObject proto)
    {
        // No-op
    }
    
    // VM control methods:
    
    void fatality(A...)(string fmt, A args)
    {
        writeln("Thread fatality");
        for (size_t tracei = 0; tracei < currentThread.cp + 1; tracei++)
        {
            writefln("  in \"%s\":", currentThread.callFrames[tracei].name);
        }
        writefln(fmt, args);
        
        GsDynamic errorValue = GsDynamic("fatality");
        errorValue.type = GsDynamicType.Error;
        currentThread.yieldValue = errorValue;
        
        if (currentThread is mainThread)
            finalize();
        else
            currentThread.finalize();
    }
    
    GsObject createObject()
    {
        return heap.create!GsArenaObject(heap);
    }
    
    GsDynamic[] createArray(size_t len)
    {
        return heap.create!(GsDynamic[])(len);
    }
    
    GsDynamic bindCreateChannel(GsDynamic[] args)
    {
        GsChannel ch = heap.create!GsChannel(this);
        return GsDynamic(ch);
    }
    
    // Spawn a new thread that initializes the library
    GsDynamic spawn(GsLibrary lib)
    {
        GsObject payload = this;
        GsThread newThread;
        
        // Look for a free thread
        for (size_t ti = 0; ti < threads.length; ti++)
        {
            auto t = threads.data[ti];
            if (t.status == GsThreadStatus.Free)
            {
                newThread = t;
                break;
            }
        }
        
        if (newThread is null)
        {
            // No free thread, create a new one
            newThread = New!GsThread(this);
            newThread.library = mainLibrary;
            threads.append(newThread);
        }
        
        newThread.library = lib;
        mainThread.callFrame.name = lib.name;
        newThread.setPayload(payload);
        
        // Add to linked list
        newThread.prev = mainThread;
        if (mainThread.next)
        {
            mainThread.next.prev = newThread;
            newThread.next = mainThread.next;
        }
        mainThread.next = newThread;
        
        newThread.callDepth = 1;
        newThread.start(0, 1);
        
        return GsDynamic(newThread);
    }
    
    // Spawn a new thread in the main library
    GsDynamic spawn(string jumpLabel, GsDynamic[] args)
    {
        if (jumpLabel in mainLibrary.jumpTable)
        {
            GsObject payload = this;
            GsThread newThread;
            
            // Look for a free thread
            for (size_t ti = 0; ti < threads.length; ti++)
            {
                auto t = threads.data[ti];
                if (t.status == GsThreadStatus.Free)
                {
                    newThread = t;
                    break;
                }
            }
            
            if (newThread is null)
            {
                // No free thread, create a new one
                newThread = New!GsThread(this);
                threads.append(newThread);
            }
            
            newThread.setPayload(payload);
            newThread.library = mainLibrary;
            
            // Add to linked list
            newThread.prev = mainThread;
            if (mainThread.next)
            {
                mainThread.next.prev = newThread;
                newThread.next = mainThread.next;
            }
            mainThread.next = newThread;
            
            auto callFrame = &newThread.callFrames[0];
            for(size_t i = 0; i < args.length; i++)
            {
                callFrame.parameters[i] = args[i];
            }
            callFrame.numParameters = args.length;
            newThread.callDepth = 0;
            
            newThread.start(mainLibrary.jumpTable[jumpLabel], 0);
            schedule();
            
            return newThread.yieldValue;
        }
        else
        {
            writeln("Error: unknown jump label \"", jumpLabel, "\"");
            return GsDynamic();
        }
    }
    
    void call(GsThread tr, string jumpLabel, GsDynamic[] args)
    {
        if (jumpLabel in tr.library.jumpTable)
        {
            // Save the current instruction pointer and library
            tr.callFrame.returnAddress = tr.ip;
            tr.callFrame.returnLibrary = tr.library;
            
            // Push a new call frame
            tr.cp = 0;
            tr.callFrame = &tr.callFrames[tr.cp];
            for(size_t i = 0; i < args.length; i++)
            {
                tr.callFrame.parameters[i] = args[i];
            }
            
            tr.callFrame.numParameters = args.length;
            
            auto ip = tr.library.jumpTable[jumpLabel];
            
            tr.start(ip, 0);
            
            schedule();
        }
        else
        {
            writeln("Error: unknown jump label \"", jumpLabel, "\"");
        }
    }
    
    void call(string jumpLabel, GsDynamic[] args)
    {
        call(mainThread, jumpLabel, args);
    }
    
    void finalize()
    {
        for (size_t i = 0; i < threads.length; i++)
        {
            threads[i].finalize();
        }
        
        running = false;
    }
    
    bool internalCall(GsLibrary lib, GsThread tr, string label, GsObject funcOwner, size_t numParams)
    {
        if (label in lib.jumpTable)
        {
            // Save the current instruction pointer and the library
            tr.callFrame.returnAddress = tr.ip;
            tr.callFrame.returnLibrary = tr.library;
            
            // Push a new call frame
            tr.cp++;
            tr.callFrame = &tr.callFrames[tr.cp];
            for(size_t pi = 0; pi < tr.callFrame.parameters.length; pi++)
            {
                if (pi < numParams)
                {
                    GsDynamic value = tr.pop();
                    
                    bool allow = true;
                    if (value.type == GsDynamicType.Object ||
                        value.type == GsDynamicType.String ||
                        value.type == GsDynamicType.Array)
                    {
                        allow = 
                            tr is mainThread || 
                            value.owner is null || 
                            value.owner is mainThread ||
                            funcOwner is tr;
                    }
                    
                    if (allow)
                        tr.callFrame.parameters[numParams - 1 - pi] = value;
                    else
                    {
                        fatality("Escaping thread-local reference (use \"escape\" if intended)");
                        return false;
                    }
                }
                else
                    tr.callFrame.parameters[pi] = GsDynamic();
            }
            tr.callFrame.numParameters = numParams;
            tr.callFrame.name = label;
            
            tr.ip = lib.jumpTable[label]; // Jump to the function's starting instruction
            tr.library = lib;
            
            tr.callDepth++;
        }
        else
        {
            fatality("Undefined jump label \"%s\"", label);
            return false;
        }
        
        return true;
    }

    void load(GsInstruction[] instructions)
    {
        mainLibrary.load(instructions);
    }
    
    void run(size_t initialIp = 0, size_t initialCallDepth = 1)
    {
        mainThread.start(initialIp, initialCallDepth);
        schedule();
    }
    
    bool arraysEqual(GsDynamic[] a1, GsDynamic[] a2)
    {
        if (a1.length != a2.length)
            return false;
        
        for(size_t i = 0; i < a1.length; i++)
        {
            GsDynamic a = a1[i];
            GsDynamic b = a2[i];
            
            bool res = false;
            
            if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                res = a.asNumber == b.asNumber;
            else if ((a.type == GsDynamicType.Error || a.type == GsDynamicType.String) && 
                     (b.type == GsDynamicType.Error || b.type == GsDynamicType.String))
                res = a.asString == b.asString;
            else if (a.type == GsDynamicType.Null && b.type == GsDynamicType.Null)
                res = true;
            else if (a.type == GsDynamicType.Object && b.type == GsDynamicType.Object)
                res = a.asObject is b.asObject;
            else if (a.type == GsDynamicType.NativeMethod && b.type == GsDynamicType.NativeMethod)
                res = a.asNativeMethod is b.asNativeMethod;
            else if (a.type == GsDynamicType.NativeFunction && b.type == GsDynamicType.NativeFunction)
                res = a.asNativeFunction is b.asNativeFunction;
            
            if (!res)
                return false;
        }
        
        return true;
    }
    
    void schedule()
    {
        running = true;
        
        while(running)
        {
            numActiveThreads = 0;
            
            GsThread tr = mainThread;
            
            // Preempt all active threads in the list
            while(tr !is null)
            {
                // Ignore paused, stopped, blocked, or free threads
                if (tr.status != GsThreadStatus.Running && 
                    tr.status != GsThreadStatus.Waiting)
                {
                    if (tr.next is null)
                        break;
                    else
                    {
                        tr = tr.next;
                        continue;
                    }
                }
                
                numActiveThreads++;
                
                tr.callFrame = &tr.callFrames[tr.cp];
                
                if (tr.ip >= tr.library.instructions.length)
                {
                    tr.status = GsThreadStatus.Stopped;
                    continue;
                }
                
                auto instruction = tr.library.instructions[tr.ip];
                
                tr.ip++;
                
                currentThread = tr;
                
                //writeln(instruction);
                
                switch (instruction.type)
                {
                    case GsInstructionType.LABEL:
                        break;
                    case GsInstructionType.PUSH:
                        tr.push(instruction.operand);
                        break;
                    case GsInstructionType.POP:
                        tr.pop();
                        break;
                    case GsInstructionType.ADD:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber + b.asNumber));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(a.asVector + b.asVector));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asVector + GsVector(b.asNumber)));
                        else if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(GsVector(b.asNumber) + b.asVector));
                        else
                        {
                            fatality("Addition of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.SUB:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber - b.asNumber));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(a.asVector - b.asVector));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asVector - GsVector(b.asNumber)));
                        else if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(GsVector(a.asNumber) - b.asVector));
                        else
                        {
                            fatality("Subtraction of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.MUL:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber * b.asNumber));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(a.asVector * b.asVector));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asVector * GsVector(b.asNumber)));
                        else if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(GsVector(a.asNumber) * b.asVector));
                        else
                        {
                            fatality("Multiplication of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.DIV:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber / b.asNumber));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(a.asVector / b.asVector));
                        else if (a.type == GsDynamicType.Vector && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asVector / GsVector(b.asNumber)));
                        else if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(GsVector(a.asNumber) / b.asVector));
                        else
                        {
                            fatality("Division of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.NEG:
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number)
                            tr.push(GsDynamic(-a.asNumber));
                        else if (a.type == GsDynamicType.Vector)
                            tr.push(GsDynamic(-a.asVector));
                        else
                        {
                            fatality("Negation of %s", a.type);
                        }
                        break;
                    case GsInstructionType.MOD:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber % b.asNumber));
                        else
                        {
                            fatality("Modulo of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.POW:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber ^^ b.asNumber));
                        else
                        {
                            fatality("Power of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.BITWISE_AND:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(cast(long)a.asNumber & cast(long)b.asNumber));
                        else
                        {
                            fatality("Bitwise AND of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.BITWISE_OR:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(cast(long)a.asNumber | cast(long)b.asNumber));
                        else
                        {
                            fatality("Bitwise OR of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.BITWISE_XOR:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(cast(long)a.asNumber ^ cast(long)b.asNumber));
                        else
                        {
                            fatality("Bitwise XOR of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.AND:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber && b.asNumber));
                        else
                        {
                            fatality("Logical AND of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.OR:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber || b.asNumber));
                        else
                        {
                            fatality("Logical OR of %s and %s", a.type, b.type);
                        }
                        break;
                    case GsInstructionType.NOT:
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number)
                            tr.push(GsDynamic(!a.asNumber));
                        else
                        {
                            fatality("Logical NOT of %s", a.type);
                        }
                        break;
                    case GsInstructionType.CAT:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        uint region = cast(uint)instruction.operand.asNumber;
                        if (a.type == GsDynamicType.String && b.type == GsDynamicType.String)
                        {
                            GsDynamic result;
                            if (region == 0)
                            {
                                result = GsDynamic(heap.cat(a.toString(), b.toString()));
                                result.owner = mainThread;
                            }
                            else
                            {
                                result = GsDynamic(tr.heap.cat(a.toString(), b.toString()));
                                result.owner = tr;
                            }
                            tr.push(result);
                        }
                        else if (a.type == GsDynamicType.Array && b.type == GsDynamicType.Array)
                        {
                            GsDynamic result;
                            if (region == 0)
                            {
                                result = GsDynamic(heap.cat(a.asArray, b.asArray));
                                result.owner = mainThread;
                            }
                            else
                            {
                                result = GsDynamic(tr.heap.cat(a.asArray, b.asArray));
                                result.owner = tr;
                            }
                            tr.push(result);
                        }
                        else if (a.type == GsDynamicType.Array && b.type != GsDynamicType.Array)
                        {
                            GsDynamic result;
                            if (region == 0)
                            {
                                result = GsDynamic(heap.cat(a.asArray, b));
                                result.owner = mainThread;
                            }
                            else
                            {
                                result = GsDynamic(tr.heap.cat(a.asArray, b));
                                result.owner = tr;
                            }
                            tr.push(result);
                        }
                        else if (a.type != GsDynamicType.Array && b.type == GsDynamicType.Array)
                        {
                            GsDynamic result;
                            if (region == 0)
                            {
                                result = GsDynamic(heap.cat(a, b.asArray));
                                result.owner = mainThread;
                            }
                            else
                            {
                                result = GsDynamic(tr.heap.cat(a, b.asArray));
                                result.owner = tr;
                            }
                            tr.push(result);
                        }
                        else
                        {
                            GsDynamic result;
                            if (region == 0)
                            {
                                GsDynamic[] newArr = heap.create!(GsDynamic[])(2);
                                newArr[0] = a;
                                newArr[0] = b;
                                result = GsDynamic(newArr);
                                result.owner = mainThread;
                            }
                            else
                            {
                                GsDynamic[] newArr = tr.heap.create!(GsDynamic[])(2);
                                newArr[0] = a;
                                newArr[0] = b;
                                result = GsDynamic(newArr);
                                result.owner = tr;
                            }
                            tr.push(result);
                        }
                        break;
                    case GsInstructionType.EQ:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber == b.asNumber));
                        else if ((a.type == GsDynamicType.Error || a.type == GsDynamicType.String) && 
                                 (b.type == GsDynamicType.Error || b.type == GsDynamicType.String))
                            tr.push(GsDynamic(a.asString == b.asString));
                        else if (a.type == GsDynamicType.Array && b.type == GsDynamicType.Array)
                            tr.push(GsDynamic(arraysEqual(a.asArray, b.asArray)));
                        else if (a.type == GsDynamicType.Null && b.type == GsDynamicType.Null)
                            tr.push(GsDynamic(1.0));
                        else if (a.type == GsDynamicType.Object && b.type == GsDynamicType.Object)
                            tr.push(GsDynamic(a.asObject is b.asObject));
                        else if (a.type == GsDynamicType.NativeMethod && b.type == GsDynamicType.NativeMethod)
                            tr.push(GsDynamic(a.asNativeMethod is b.asNativeMethod));
                        else if (a.type == GsDynamicType.NativeFunction && b.type == GsDynamicType.NativeFunction)
                            tr.push(GsDynamic(a.asNativeFunction is b.asNativeFunction));
                        else
                            tr.push(GsDynamic(0.0));
                        break;
                    case GsInstructionType.LESS:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a < b));
                        break;
                    case GsInstructionType.GREATER:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a > b));
                        break;
                    case GsInstructionType.NEQ:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        tr.push(GsDynamic(a != b));
                        break;
                    case GsInstructionType.LESS_EQ:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a <= b));
                        break;
                    case GsInstructionType.GREATER_EQ:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a >= b));
                        break;
                    case GsInstructionType.TYPE:
                        auto val = tr.pop();
                        if (val.type == GsDynamicType.String)
                        {
                            if (val.asString in tr.library.jumpTable)
                                tr.push(GsDynamic(1.0));
                            else
                                tr.push(GsDynamic(cast(double)(val.type)));
                        }
                        else
                        {
                            tr.push(GsDynamic(cast(double)(val.type)));
                        }
                        break;
                    case GsInstructionType.TYPE_IS:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop();
                        if (cast(uint)b == GsDynamicType.Function)
                        {
                            bool result = false;
                            if (a.type == GsDynamicType.String)
                            {
                                result = (a.asString in tr.library.jumpTable) !is null;
                            }
                            tr.push(GsDynamic(cast(double)result));
                        }
                        else
                        {
                            tr.push(GsDynamic(cast(double)(a.type == cast(uint)b)));
                        }
                        break;
                    case GsInstructionType.JMP:
                        tr.ip = tr.library.jumpTable[instruction.operand.asString];
                        break;
                    case GsInstructionType.JMP_IF:
                        if (cast(bool)tr.peek().asNumber)
                        {
                            tr.ip = tr.library.jumpTable[instruction.operand.asString];
                        }
                        break;
                    case GsInstructionType.JMP_IF_NOT:
                        if (!cast(bool)tr.peek().asNumber)
                        {
                            tr.ip = tr.library.jumpTable[instruction.operand.asString];
                        }
                        break;
                    case GsInstructionType.JMPPOP_IF:
                        if (cast(bool)tr.peek().asNumber)
                        {
                            tr.pop();
                            tr.ip = tr.library.jumpTable[instruction.operand.asString];
                        }
                        break;
                    case GsInstructionType.JMPPOP_IF_NOT:
                        if (!cast(bool)tr.peek().asNumber)
                        {
                            tr.pop();
                            tr.ip = tr.library.jumpTable[instruction.operand.asString];
                        }
                        break;
                    case GsInstructionType.INDEX_GET:
                        size_t index = cast(size_t)tr.pop().asNumber;
                        auto arrayParam = tr.pop();
                        if (arrayParam.type == GsDynamicType.Array)
                        {
                            auto array = arrayParam.asArray;
                            if (index >= 0 && index < array.length)
                            {
                                tr.push(array[index]);
                                break;
                            }
                            else
                            {
                                fatality("Index is outside array capability");
                                break;
                            }
                        }
                        else if (arrayParam.type == GsDynamicType.Vector)
                        {
                            auto v = arrayParam.asVector;
                            if (index == 0)
                                tr.push(GsDynamic(v.x));
                            else if (index == 1)
                                tr.push(GsDynamic(v.y));
                            else if (index == 2)
                                tr.push(GsDynamic(v.z));
                            else if (index == 3)
                                tr.push(GsDynamic(v.w));
                            else
                                fatality("Index is outside vector length");
                            
                            break;
                        }
                        else if (arrayParam.type == GsDynamicType.String)
                        {
                            auto str = arrayParam.asString;
                            if (index >= 0 && index < str.length)
                            {
                                tr.push(GsDynamic(cast(double)str[index]));
                                break;
                            }
                            else
                            {
                                fatality("Index is outside string length");
                                break;
                            }
                        }
                        else
                        {
                            fatality("Attempting to index %s which is not an array", arrayParam.type);
                            break;
                        }
                    case GsInstructionType.INDEX_SET:
                        size_t index = cast(size_t)tr.pop().asNumber;
                        auto arrayParam = tr.pop();
                        if (arrayParam.type == GsDynamicType.Array)
                        {
                            auto array = arrayParam.asArray;
                            auto value = tr.pop();
                            if (index >= 0 && index < array.length)
                            {
                                if (value.type == GsDynamicType.Object ||
                                    value.type == GsDynamicType.String ||
                                    value.type == GsDynamicType.Array)
                                {
                                    if (value.owner is null || 
                                        value.owner is mainThread ||
                                        value.owner is arrayParam.owner)
                                    {
                                        array[index] = value;
                                    }
                                    else
                                    {
                                        fatality("Escaping thread-local reference (use \"escape\" if intended)");
                                        break;
                                    }
                                }
                                else
                                {
                                    array[index] = value;
                                }
                            }
                            else
                            {
                                fatality("Index is outside array capability");
                                break;
                            }
                            tr.push(value);
                            break;
                        }
                        else
                        {
                            fatality("Attempting to index %s which is not an array", arrayParam.type);
                            break;
                        }
                    case GsInstructionType.LENGTH:
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.Array)
                            tr.push(GsDynamic(param.asArray.length));
                        else if (param.type == GsDynamicType.String)
                            tr.push(GsDynamic(param.asString.length));
                        else if (param.type == GsDynamicType.Null)
                            tr.push(GsDynamic(0.0));
                        else
                            tr.push(GsDynamic(1.0));
                        break;
                    case GsInstructionType.PRINT:
                        writeln(tr.pop());
                        break;
                    case GsInstructionType.GLOBAL:
                        GsDynamic value = GsDynamic(this);
                        value.owner = mainThread;
                        tr.push(value);
                        break;
                    case GsInstructionType.BORROW:
                        GsDynamic value = tr.pop();
                        value.owner = tr;
                        tr.push(value);
                        break;
                    case GsInstructionType.ESCAPE:
                        GsDynamic value = tr.pop();
                        value.owner = mainThread;
                        tr.push(value);
                        break;
                    case GsInstructionType.ARRAY:
                        uint region = cast(uint)instruction.operand.asNumber;
                        size_t len = cast(size_t)tr.pop().asNumber;
                        GsDynamic[] arr;
                        GsObject owner;
                        if (len > 0)
                        {
                            if (region == 0)
                            {
                                arr = createArray(len);
                                owner = mainThread;
                            }
                            else
                            {
                                arr = tr.createArray(len);
                                owner = tr;
                            }
                            for (size_t ai = 0; ai < len; ai++)
                            {
                                arr[$ - 1 - ai] = tr.pop();
                            }
                        }
                        else
                        {
                            if (region == 0)
                                owner = mainThread;
                            else
                                owner = tr;
                        }
                        GsDynamic result = GsDynamic(arr);
                        result.owner = owner;
                        tr.push(result);
                        break;
                    case GsInstructionType.ARRAY_DEF:
                        uint region = cast(uint)instruction.operand.asNumber;
                        size_t len = cast(size_t)tr.pop().asNumber;
                        GsDynamic defaultValue = tr.pop();
                        GsDynamic[] arr;
                        GsObject owner;
                        if (len > 0)
                        {
                            if (region == 0)
                            {
                                arr = createArray(len);
                                owner = mainThread;
                            }
                            else
                            {
                                arr = tr.createArray(len);
                                owner = tr;
                            }
                        }
                        else
                        {
                            if (region == 0)
                                owner = mainThread;
                            else
                                owner = tr;
                        }
                        
                        if (defaultValue.type != GsDynamicType.Null)
                            arr[] = defaultValue;
                        
                        GsDynamic result = GsDynamic(arr);
                        result.owner = owner;
                        tr.push(result);
                        break;
                    case GsInstructionType.CALL:
                        size_t numParams = cast(size_t)instruction.operand.asNumber;
                        
                        auto func = tr.pop();
                        
                        GsNativeMethod nativeMethod;
                        GsNativeFunc nativeFuncPtr;
                        bool useNativeMethod = false;
                        bool useNativeFunc = false;
                        
                        if (func.type == GsDynamicType.NativeMethod)
                        {
                            nativeMethod = func.asNativeMethod;
                            useNativeMethod = true;
                        }
                        else if (func.type == GsDynamicType.NativeFunction)
                        {
                            nativeFuncPtr = func.asNativeFunction;
                            useNativeFunc = true;
                        }
                        else
                        {
                            if (func.type == GsDynamicType.String)
                            {
                                string funcName = func.asString;
                                
                                if (numParams > 0 && func.hintBits & GsSemanticsHint.LibraryFunctionBit)
                                {
                                    auto firstArgument = tr.peek(numParams - 1);
                                    if (firstArgument.type == GsDynamicType.Object)
                                    {
                                        GsLibrary lib = cast(GsLibrary)firstArgument.asObject;
                                        if (lib)
                                        {
                                            internalCall(lib, tr, funcName, func.owner, numParams);
                                                break;
                                        }
                                        else
                                        {
                                            fatality("Attempting to call function \"%s\" with a non-library object");
                                        }
                                    }
                                }
                                
                                internalCall(tr.library, tr, funcName, func.owner, numParams);
                                break;
                            }
                            else
                            {
                                fatality("Attempting to call %s, which is not a function", func.type);
                                break;
                            }
                        }
                        
                        // Native call: push a new call frame
                        tr.cp++;
                        tr.callFrame = &tr.callFrames[tr.cp];
                        for(size_t pi = 0; pi < tr.callFrame.parameters.length; pi++)
                        {
                            if (pi < numParams)
                            {
                                GsDynamic value = tr.pop();
                                
                                bool allow = true;
                                if (value.type == GsDynamicType.Object ||
                                    value.type == GsDynamicType.String ||
                                    value.type == GsDynamicType.Array)
                                {
                                    allow = 
                                        tr is mainThread || 
                                        value.owner is null || 
                                        value.owner is mainThread ||
                                        func.owner is tr;
                                }
                                
                                if (allow)
                                    tr.callFrame.parameters[numParams - 1 - pi] = value;
                                else
                                {
                                    fatality("Escaping thread-local reference (use \"escape\" if intended)");
                                    break;
                                }
                            }
                            else
                                tr.callFrame.parameters[pi] = GsDynamic();
                        }
                        tr.callFrame.numParameters = numParams;
                        tr.callFrame.name = "<native function>";
                        
                        GsDynamic result;
                        if (useNativeMethod)
                            result = nativeMethod(tr.callFrame.parameters[0..numParams]);
                        else if (useNativeFunc)
                            result = nativeFuncPtr(tr.callFrame.parameters[0..numParams]);
                         
                        tr.cp--;
                        tr.callFrame = &tr.callFrames[tr.cp];
                        tr.push(result);
                        break;
                    case GsInstructionType.RET:
                        if (tr.callDepth > 0)
                        {
                            tr.cp--;
                            tr.callFrame = &tr.callFrames[tr.cp];
                            // Pop the return library and address from the call stack
                            tr.library = tr.callFrame.returnLibrary;
                            tr.ip = tr.callFrame.returnAddress;
                            tr.callDepth--;
                        }
                        else
                        {
                            // Return from thread, halt execution
                            tr.yieldValue = tr.pop();
                            tr.finalize();
                        }
                        break;
                    case GsInstructionType.YIELD:
                        if (tr.callDepth > 0)
                        {
                            // Same as return
                            tr.cp--;
                            tr.callFrame = &tr.callFrames[tr.cp];
                            // Pop the return library and address from the call stack
                            tr.library = tr.callFrame.returnLibrary;
                            tr.ip = tr.callFrame.returnAddress;
                            tr.callDepth--;
                        }
                        else
                        {
                            // Yield a value and pause the thread
                            tr.yieldValue = tr.pop();
                            tr.pause();
                        }
                        break;
                    case GsInstructionType.STORE_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.callFrames[tr.cp].localVariables[vIndex] = tr.peek(); // Store a stack value into a local variable
                        break;
                    case GsInstructionType.LOAD_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.push(tr.callFrames[tr.cp].localVariables[vIndex]); // Load a local variable onto the stack
                        break;
                    case GsInstructionType.STORE_ARG:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.callFrames[tr.cp].parameters[vIndex] = tr.peek(); // Store a stack value into a parameter
                        break;
                    case GsInstructionType.LOAD_ARG:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.push(tr.callFrames[tr.cp].parameters[vIndex]); // Load a parameter onto the stack
                        break;
                    case GsInstructionType.LOAD_ARGS:
                        auto frame = &tr.callFrames[tr.cp];
                        tr.push(GsDynamic(frame.parameters[0..frame.numParameters])); // Load all parameters onto the stack
                        break;
                    case GsInstructionType.GLOBAL_STORE_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        auto value = tr.peek();
                        if (value.type == GsDynamicType.Object ||
                            value.type == GsDynamicType.String ||
                            value.type == GsDynamicType.Array)
                        {
                            if (value.owner is null || value.owner is mainThread)
                            {
                                // Store a value into a global variable
                                tr.library.rootVariables[vIndex] = value;
                                break;
                            }
                            else
                            {
                                fatality("Escaping thread-local reference (use \"escape\" if intended)");
                                break;
                            }
                        }
                        else
                        {
                            // Store a value into a global variable
                            tr.library.rootVariables[vIndex] = value;
                            break;
                        }
                    case GsInstructionType.GLOBAL_LOAD_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.push(tr.library.rootVariables[vIndex]); // Load a global variable onto the stack
                        break;
                    case GsInstructionType.NEW:
                        uint region = cast(uint)instruction.operand.asNumber;
                        GsObject obj;
                        GsObject owner;
                        if (region == 0)
                        {
                            obj = createObject();
                            owner = mainThread;
                        }
                        else
                        {
                            obj = tr.createObject();
                            owner = tr;
                        }
                        GsDynamic result = GsDynamic(obj);
                        result.owner = owner;
                        tr.push(result);
                        break;
                    case GsInstructionType.REUSE:
                        uint region = cast(uint)instruction.operand.asNumber;
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.Object)
                        {
                            GsObject newObj;
                            GsObject owner;
                            if (region == 0)
                            {
                                newObj = createObject();
                                owner = mainThread;
                            }
                            else
                            {
                                newObj = tr.createObject();
                                owner = tr;
                            }
                            newObj.setPrototype(param.asObject);
                            GsDynamic result = GsDynamic(newObj);
                            result.owner = owner;
                            tr.push(result);
                        }
                        else
                        {
                            fatality("Attempting to reuse ", param.type);
                        }
                        break;
                    case GsInstructionType.GET:
                        auto key = instruction.operand.asString;
                        auto storageObj = tr.pop();
                        if (storageObj.type == GsDynamicType.Object)
                        {
                            GsDynamic value = storageObj.asObject.get(key);
                            value.owner = storageObj.owner;
                            tr.push(value);
                        }
                        else
                        {
                            fatality("Attempting to read member \"%s\" of %s", key, storageObj.type);
                        }
                        break;
                    case GsInstructionType.SET:
                        auto key = instruction.operand.asString;
                        auto storageObj = tr.pop();
                        auto value = tr.pop();
                        if (storageObj.type == GsDynamicType.Object)
                        {
                            if (value.type == GsDynamicType.Object ||
                                value.type == GsDynamicType.String ||
                                value.type == GsDynamicType.Array)
                            {
                                if (value.owner is null || 
                                    value.owner is mainThread || 
                                    value.owner is storageObj.asObject ||
                                    value.owner is storageObj.owner)
                                {
                                    storageObj.asObject.set(key, value);
                                    tr.push(value);
                                    break;
                                }
                                else
                                {
                                    fatality("Escaping thread-local reference (use \"escape\" if intended)");
                                    break;
                                }
                            }
                            else
                            {
                                storageObj.asObject.set(key, value);
                                tr.push(value);
                                break;
                            }
                        }
                        else
                        {
                            fatality("Attempting to write member \"%s\" of %s", key, storageObj.type);
                        }
                        break;
                    case GsInstructionType.INIT_SET:
                        auto key = instruction.operand.asString;
                        auto value = tr.pop();
                        auto storageObj = tr.peek();
                        if (storageObj.type == GsDynamicType.Object)
                        {
                            if (value.type == GsDynamicType.Object ||
                                value.type == GsDynamicType.String ||
                                value.type == GsDynamicType.Array)
                            {
                                if (value.owner is null || 
                                    value.owner is mainThread || 
                                    value.owner is storageObj.asObject ||
                                    value.owner is storageObj.owner)
                                {
                                    storageObj.asObject.set(key, value);
                                    break;
                                }
                                else
                                {
                                    fatality("Escaping thread-local reference (use \"escape\" if intended)");
                                    break;
                                }
                            }
                            else
                            {
                                storageObj.asObject.set(key, value);
                                break;
                            }
                        }
                        else
                        {
                            fatality("Attempting to write member \"%s\" of %s", key, storageObj.type);
                        }
                        break;
                    case GsInstructionType.CONTAINS:
                        auto key = instruction.operand.asString;
                        auto storageObj = tr.pop();
                        if (storageObj.type == GsDynamicType.Object)
                        {
                            tr.push(GsDynamic(storageObj.asObject.contains(key)));
                        }
                        else
                        {
                            fatality("Attempting to read member \"%s\" of %s", key, storageObj.type);
                        }
                        break;
                    case GsInstructionType.SPAWN:
                        size_t numParams = cast(size_t)instruction.operand.asNumber;
                        auto func = tr.pop();
                        if (func.type == GsDynamicType.String)
                        {
                            string jumpLabel = func.asString;
                            if (jumpLabel in tr.library.jumpTable)
                            {
                                auto payloadParam = tr.pop();
                                GsObject payload = null;
                                if (payloadParam.type == GsDynamicType.Object)
                                {
                                    payload = payloadParam.asObject;
                                }
                                else if (payloadParam.type != GsDynamicType.Null)
                                {
                                    fatality("Attempting to payload a thread with %s, which is not an object", payloadParam.type);
                                    break;
                                }
                                
                                GsThread newThread;
                                
                                // Look for a free thread
                                for (size_t ti = 0; ti < threads.length; ti++)
                                {
                                    auto t = threads.data[ti];
                                    if (t.status == GsThreadStatus.Free)
                                    {
                                        newThread = t;
                                        break;
                                    }
                                }
                                
                                if (newThread is null)
                                {
                                    // No free thread, create a new one
                                    newThread = New!GsThread(this);
                                    threads.append(newThread);
                                }
                                
                                if (payload is null)
                                    payload = newThread.createObject();
                                newThread.setPayload(payload);
                                newThread.library = tr.library;
                                
                                // Add to linked list
                                newThread.prev = tr;
                                if (tr.next)
                                {
                                    tr.next.prev = newThread;
                                    newThread.next = tr.next;
                                }
                                tr.next = newThread;
                                
                                auto cf = &newThread.callFrames[0];
                                cf.parameters[0] = GsDynamic(newThread);
                                for(size_t i = 0; i < numParams; i++)
                                {
                                    cf.parameters[1 + numParams - 1 - i] = tr.pop();
                                }
                                for(size_t pi = numParams + 1; pi < cf.parameters.length; pi++)
                                {
                                    cf.parameters[pi] = GsDynamic();
                                }
                                cf.numParameters = numParams + 1;
                                cf.name = jumpLabel;
                                
                                newThread.start(newThread.library.jumpTable[jumpLabel], 0);
                                numActiveThreads++;
                                
                                tr.push(GsDynamic(newThread));
                            }
                            else
                            {
                                fatality("Unknown jump label %s", jumpLabel);
                            }
                        }
                        else
                        {
                            fatality("Attempting to spawn %s, which is not a function", func.type);
                        }
                        break;
                    case GsInstructionType.AWAIT:
                        auto param = tr.peek();
                        if (param.type == GsDynamicType.Object)
                        {
                            GsThread paramThread = cast(GsThread)param.asObject;
                            if (paramThread)
                            {
                                if (paramThread.status != GsThreadStatus.Running)
                                {
                                    tr.status = GsThreadStatus.Running;
                                    tr.pop();
                                    tr.push(paramThread.yieldValue);
                                    
                                    if (paramThread.status == GsThreadStatus.Paused)
                                        paramThread.status = GsThreadStatus.Running;
                                }
                                else
                                {
                                    tr.status = GsThreadStatus.Waiting;
                                    tr.ip--;
                                }
                            }
                            else
                            {
                                fatality("Attempting to await non-thread object", param.type);
                            }
                        }
                        else
                        {
                            fatality("Attempting to await %s, which is not a thread", param.type);
                        }
                        break;
                    case GsInstructionType.SYNC:
                        auto param = tr.peek();
                        if (param.type == GsDynamicType.Object)
                        {
                            GsThread paramThread = cast(GsThread)param.asObject;
                            if (paramThread)
                            {
                                if (paramThread.status != GsThreadStatus.Running)
                                {
                                    tr.status = GsThreadStatus.Running;
                                    tr.pop();
                                    tr.push(paramThread.yieldValue);
                                }
                                else
                                {
                                    tr.status = GsThreadStatus.Waiting;
                                    tr.ip--;
                                }
                            }
                            else
                            {
                                fatality("Attempting to sync non-thread object", param.type);
                            }
                        }
                        else
                        {
                            fatality("Attempting to sync %s, which is not a thread", param.type);
                        }
                        break;
                    case GsInstructionType.ERROR:
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.String)
                        {
                            GsDynamic errorValue = param;
                            errorValue.type = GsDynamicType.Error;
                            tr.push(errorValue);
                        }
                        else
                        {
                            fatality("Error value cannot be constructed from %s", param.type);
                        }
                        break;
                    case GsInstructionType.RAISE:
                        if (tr is mainThread)
                        {
                            auto param = tr.pop();
                            tr.yieldValue = param;
                            string msg = param.toString;
                            if (msg.length == 0)
                                msg = "Error raised in main thread";
                            fatality(msg);
                        }
                        else
                        {
                            auto param = tr.pop();
                            tr.yieldValue = param;
                            tr.finalize();
                        }
                        break;
                    case GsInstructionType.VEC0:
                        tr.push(GsDynamic(GsVector(0.0)));
                        break;
                    case GsInstructionType.VEC1:
                        auto e1 = tr.pop();
                        if (e1.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e1.type);
                        tr.push(GsDynamic(GsVector(e1.asNumber)));
                        break;
                    case GsInstructionType.VEC2:
                        auto e2 = tr.pop();
                        auto e1 = tr.pop();
                        if (e1.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e1.type);
                        if (e2.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e2.type);
                        tr.push(GsDynamic(GsVector(e1.asNumber, e2.asNumber)));
                        break;
                    case GsInstructionType.VEC3:
                        auto e3 = tr.pop();
                        auto e2 = tr.pop();
                        auto e1 = tr.pop();
                        if (e1.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e1.type);
                        if (e2.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e2.type);
                        if (e3.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e3.type);
                        tr.push(GsDynamic(GsVector(e1.asNumber, e2.asNumber, e3.asNumber)));
                        break;
                    case GsInstructionType.VEC4:
                        auto e4 = tr.pop();
                        auto e3 = tr.pop();
                        auto e2 = tr.pop();
                        auto e1 = tr.pop();
                        if (e1.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e1.type);
                        if (e2.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e2.type);
                        if (e3.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e3.type);
                        if (e4.type != GsDynamicType.Number)
                            fatality("Cannot make a vector from %s", e4.type);
                        tr.push(GsDynamic(GsVector(e1.asNumber, e2.asNumber, e3.asNumber, e4.asNumber)));
                        break;
                    case GsInstructionType.HALT:
                        tr.finalize();
                        break;
                    default:
                        fatality("Unsupported instruction: %s", instruction.type);
                        break;
                }
                
                tr = tr.next;
            }
            
            if (numActiveThreads == 0)
                running = false;
        }
    }
}

enum GsThreadStatus
{
    Free = 0,    // Thread is idle and ready for running
    Running = 1, // Thread is progressing
    Paused = 2,  // Thread is paused
    Waiting = 3, // Thread is waiting for output from another thread (spinlock)
    Blocked = 4, // Thread is blocked via a synchronization primitive
    Stopped = 5  // Thread has terminated execution
}

class GsThread: Owner, GsObject
{
    GsVirtualMachine vm;
    GsObject payload;
    GsDynamic[] stack;             // Expression stack
    GsCallFrame[] callFrames;      // Call stack
    size_t ip;                     // Instruction pointer
    size_t sp;                     // Stack pointer
    size_t cp;                     // Call stack pointer
    size_t callDepth = 1;
    
    GsArena heap;                  // Isolated heap
    GsLibrary library;             // Current library
    GsCallFrame* callFrame;        // Current call frame
    
    GsThreadStatus status;
    GsDynamic yieldValue;          // Register for yielded/returned value
    
    GsThread prev = null;          // Doubly linked list of threads
    GsThread next = null;          //
    
    this(GsVirtualMachine vm)
    {
        super(vm);
        
        this.vm = vm;
        
        heap = New!GsArena(1024, this);
        
        stack = New!(GsDynamic[])(256);
        callFrames = New!(GsCallFrame[])(256);
        callFrame = &callFrames[0];
        
        status = GsThreadStatus.Free;
        
        ip = 0;
        sp = 0;
        cp = 0;
        
        yieldValue = GsDynamic();
    }
    
    ~this()
    {
        Delete(stack);
        Delete(callFrames);
    }
    
    void setPayload(GsObject payload)
    {
        this.payload = payload;
        this.payload.set("pause", GsDynamic(&bindPause));
        this.payload.set("resume", GsDynamic(&bindResume));
        this.payload.set("release", GsDynamic(&bindRelease));
        this.payload.set("running", GsDynamic(0.0));
    }
    
    GsDynamic get(string key)
    {
        if (payload)
            return payload.get(key);
        else
            return GsDynamic();
    }
    
    void set(string key, GsDynamic value)
    {
        if (payload)
            return payload.set(key, value);
    }
    
    bool contains(string key)
    {
        if (payload)
            return payload.contains(key);
        else
            return false;
    }
    
    void setPrototype(GsObject proto)
    {
        if (payload)
            payload.setPrototype(proto);
    }
    
    // Stack manipulation methods
    GsDynamic pop()
    {
        if (sp == 0)
        {
            vm.fatality("Stack underflow");
            return GsDynamic();
        }
        else
            return stack[--sp];
    }

    GsDynamic peek()
    {
        if (sp == 0)
        {
            vm.fatality("Stack is empty");
            return GsDynamic();
        }
        else
            return stack[sp - 1];
    }
    
    GsDynamic peek(size_t offset)
    {
        if (sp == 0)
        {
            vm.fatality("Stack is empty");
            return GsDynamic();
        }
        else
            return stack[sp - 1 - offset];
    }

    void push(GsDynamic value)
    {
        if (sp >= stack.length)
        {
            vm.fatality("Stack overflow");
        }
        else
            stack[sp++] = value;
    }
    
    GsObject createObject()
    {
        return heap.create!GsArenaObject(heap);
    }
    
    GsDynamic[] createArray(size_t len)
    {
        return heap.create!(GsDynamic[])(len);
    }
    
    void pause()
    {
        if (status == GsThreadStatus.Running)
        {
            status = GsThreadStatus.Paused;
        }
    }
    
    void resume()
    {
        if (status == GsThreadStatus.Paused)
        {
            status = GsThreadStatus.Running;
        }
    }
    
    GsDynamic bindPause(GsDynamic[] args)
    {
        if (status == GsThreadStatus.Running)
        {
            status = GsThreadStatus.Paused;
        }
        return GsDynamic();
    }
    
    GsDynamic bindResume(GsDynamic[] args)
    {
        if (status == GsThreadStatus.Paused)
        {
            status = GsThreadStatus.Running;
        }
        return GsDynamic();
    }
    
    GsDynamic bindRelease(GsDynamic[] args)
    {
        status = GsThreadStatus.Free;
        ip = 0;
        sp = 0;
        cp = 0;
        callFrame = &callFrames[0];
        callDepth = 1;
        payload = null;
        yieldValue = GsDynamic();
        heap.reset();
        return GsDynamic();
    }
    
    void finalize()
    {
        status = GsThreadStatus.Stopped;
        if (payload)
            payload.set("running", GsDynamic(0.0));
        
        if (this !is vm.mainThread)
        {
            // Remove this thread from the linked list
            if (prev)
                prev.next = next;
            if (next)
                next.prev = prev;
            prev = null;
            next = null;
        }
    }
    
    void start(size_t initialIp = 0, size_t initialCallDepth = 1)
    {
        if (status == GsThreadStatus.Free || status == GsThreadStatus.Stopped)
        {
            ip = initialIp;
            sp = 0;
            cp = 0;
            callDepth = initialCallDepth;
            status = GsThreadStatus.Running;
            if (payload)
                payload.set("running", GsDynamic(1.0));
            yieldValue = GsDynamic();
        }
    }
}

class GsChannel: GsObject
{
    GsVirtualMachine vm;
    GsDynamic payload;
    GsThread producer;
    GsThread consumer;
    
    this(GsVirtualMachine vm)
    {
        this.vm = vm;
    }
    
    GsDynamic get(string key)
    {
        if (key == "send")
            return GsDynamic(&bindSend);
        else if (key == "receive")
            return GsDynamic(&bindReceive);
        else
            return GsDynamic();
    }
    
    void set(string key, GsDynamic value)
    {
        // No-op
    }
    
    bool contains(string key)
    {
        return (key == "send" || key == "receive");
    }
    
    void setPrototype(GsObject proto)
    {
        // No-op
    }
    
    GsDynamic bindSend(GsDynamic[] args)
    {
        if (args.length < 2)
            return GsDynamic();
        if (consumer)
        {
            consumer.status = GsThreadStatus.Running;
            consumer.push(args[1]);
        }
        else
        {
            payload = args[1];
            vm.currentThread.status = GsThreadStatus.Blocked;
            producer = vm.currentThread;
        }
        return GsDynamic();
    }
    
    GsDynamic bindReceive(GsDynamic[] args)
    {
        if (producer)
        {
            producer.status = GsThreadStatus.Running;
            producer = null;
            payload = GsDynamic();
            return payload;
        }
        else
        {
            vm.currentThread.status = GsThreadStatus.Blocked;
            consumer = vm.currentThread;
        }
        return GsDynamic();
    }
}
