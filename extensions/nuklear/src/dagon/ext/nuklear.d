/*
Copyright (c) 2019-2022 Mateusz Muszy≈Ñski

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dagon.ext.nuklear;

import std.stdio;
import core.stdc.stdarg;

import dlib.core.ownership;
import dlib.image.color;
import dlib.container.array;
import dlib.text.utf8;
import dlib.text.str;

import dagon.core.application;
import dagon.core.time;
import dagon.core.event;
import dagon.core.keycodes;
import dagon.core.locale;
import dagon.graphics.drawable;
import dagon.graphics.updateable;
import dagon.graphics.shaderloader;
import dagon.graphics.texture;
import dagon.graphics.shader;

import dagon.core.bindings;
public import bindbc.nuklear;

import dagon.ext.ftfont;

__gshared NuklearSupport nuklearSupport;

void initNuklear()
{
    nuklearSupport = loadNuklear();
    if (nuklearSupport != NuklearSupport.Nuklear4)
    {
        if (nuklearSupport == NuklearSupport.badLibrary)
            writeln("Warning: failed to load some Nuklear functions. It seems that you have an old version of Nuklear. Dagon will try to use it, but it is recommended to install Nuklear 4.01");
        else
            writeln("Error: Nuklear library is not found. Please, install Nuklear 4.01");
    }
}

static this()
{
    initNuklear();
}

alias nk_color NKColor;
alias nk_colorf NKColorf;
alias nk_rect NKRect;
alias nk_rect NKRecti;
alias nk_vec2 NKVec2;
alias nk_vec2i NKVec2i;
alias nk_cursor NKCursor;
alias nk_font NKFont;
alias nk_flags NKFlags;
alias nk_size NKSize;
alias nk_image NKImage;
alias nk_rune NKRune;
alias nk_handle NKHandle;
alias nk_window NKWindow;
alias nk_panel NKPanel;

NKColor toNKColor(Color4f col)
{
    auto c = col.convert(8);
    return NKColor(
        cast(ubyte)c.r,
        cast(ubyte)c.g,
        cast(ubyte)c.b,
        cast(ubyte)c.a);
}

NKImage toNKImage(Texture texture)
{
    NKImage img;
    img.handle.id = cast(int)texture.texture;
    img.w = cast(short)texture.size.width;
    img.h = cast(short)texture.size.height;
    img.region[2] = cast(short)texture.size.width;
    img.region[3] = cast(short)texture.size.height;
    return img;
}

private extern(C) void clipboardPaste(nk_handle usr, nk_text_edit* edit)
{
    char* text = SDL_GetClipboardText();
    if (text)
    {
        // Determine how many codepoints do we have
        uint numCharacters = 0;
        size_t offset = 0;
        while(true)
        {
            UTF8Decoder dec = UTF8Decoder(cast(string)text[offset..offset+4]);
            auto code = dec.decodeNext();
            if (code == 0)
                break;
            offset += dec.index;
            numCharacters++;
        }

        nk_textedit_paste(edit, text, numCharacters); //nk_strlen(text)
        SDL_free(text);
    }
}

private extern(C) void clipboardCopy(nk_handle usr, const(char)* text, int len)
{
    import core.stdc.stdio;
    import core.stdc.string;
    import core.stdc.stdlib;
    char *str = null;
    if (!len) return;

    // Decode len codepoints and determine byte length
    size_t byteLen = 0;
    for(int pos = 0; pos < len; pos++)
    {
        UTF8Decoder dec = UTF8Decoder(cast(string)text[byteLen..byteLen+4]);
        dec.decodeNext();
        byteLen += dec.index;
    }

    str = cast(char*)malloc(byteLen+1);
    if (!str) return;
    memcpy(str, text, byteLen);
    str[byteLen] = '\0';
    SDL_SetClipboardText(str);
    free(str);
}

enum NuklearEventType
{
    MouseMotion,
    MouseButton,
    MouseScroll,
    TextInput,
    Key
}

struct NuklearEvent
{
    NuklearEventType type;
    int x;
    int y;
    union
    {
        int button;
        dchar unicode;
        int key;
    }
    int down;
}

class NuklearGUI: Owner, Updateable, Drawable
{
    NuklearEvent[10] events;
    int eventsCount = 0;

    nk_context ctx;
    nk_buffer cmds;
    nk_draw_null_texture nullTexture;

    Array!nk_font_atlas atlases;
    Array!GLuint fontsTextures;

    GLuint vbo;
    GLuint vao;
    GLuint ebo;

    GLuint shaderProgram;
    GLuint vertexShader;
    GLuint fragmentShader;

    GLint positionLoc;
    GLint texcoordLoc;
    GLint colorLoc;

    GLint textureLoc;
    GLint projectionMatrixLoc;

    String vs, fs;

    EventManager eventManager; // Needed for mouse position

    this(EventManager em, Owner o)
    {
        super(o);

        eventManager = em;

        nk_init_default(&ctx, null);

        ctx.clip.copy = cast(nk_plugin_copy)&clipboardCopy;
        ctx.clip.paste = cast(nk_plugin_paste)&clipboardPaste;
        ctx.clip.userdata = nk_handle_ptr(null);

        nk_buffer_init_default(&cmds);

        prepareVAO();

        addFont(null, 0, 13.0f); // load default font
    }

    ~this()
    {
        if (vs.length) vs.free();
        if (fs.length) fs.free();

        foreach(atlas; atlases)
            nk_font_atlas_clear(&atlas);
        atlases.free();

        foreach(tex; fontsTextures)
            glDeleteTextures(1, &tex);
        fontsTextures.free();

        nk_free(&ctx);
        nk_buffer_free(&cmds);

        glDeleteProgram(shaderProgram);

        glDeleteBuffers(1, &vbo);
        glDeleteBuffers(1, &ebo);
    }

    void prepareVAO()
    {
        vs = Shader.load("data/__internal/shaders/Nuklear/Nuklear.vert.glsl");
        fs = Shader.load("data/__internal/shaders/Nuklear/Nuklear.frag.glsl");

        vertexShader = compileShader(vs, ShaderStage.vertex);
        fragmentShader = compileShader(fs, ShaderStage.fragment);
        if (vertexShader != 0 && fragmentShader != 0)
            shaderProgram = linkShaders(vertexShader, fragmentShader);

        debug writeln("NuklearShader: program ", shaderProgram);

        if (shaderProgram != 0)
        {
            textureLoc = glGetUniformLocation(shaderProgram, "Texture");
            projectionMatrixLoc = glGetUniformLocation(shaderProgram, "ProjMtx");
            positionLoc = glGetAttribLocation(shaderProgram, "va_Vertex");
            texcoordLoc = glGetAttribLocation(shaderProgram, "va_Texcoord");
            colorLoc = glGetAttribLocation(shaderProgram, "va_Color");
        }

        // buffer setup
        glGenBuffers(1, &vbo);
        glGenBuffers(1, &ebo);
        glGenVertexArrays(1, &vao);

        glBindVertexArray(vao);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);

        glEnableVertexAttribArray(positionLoc);
        glEnableVertexAttribArray(texcoordLoc);
        glEnableVertexAttribArray(colorLoc);

        glVertexAttribPointer(positionLoc, 2, GL_FLOAT, GL_FALSE, 20, cast(void*)0);
        glVertexAttribPointer(texcoordLoc, 2, GL_FLOAT, GL_FALSE, 20, cast(void*)8);
        glVertexAttribPointer(colorLoc, 4, GL_UNSIGNED_BYTE, GL_TRUE, 20, cast(void*)16);

        glBindTexture(GL_TEXTURE_2D, 0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
    }

    override void update(Time t)
    {
        nk_clear(&ctx);

        nk_input_begin(&ctx);
        nk_input_motion(&ctx, eventManager.mouseX, eventManager.mouseY);

        // perform all inputs
        while (eventsCount != 0)
        {
            auto e = events[--eventsCount];
            switch (e.type)
            {
                case NuklearEventType.Key:
                    nk_input_key(&ctx, cast(nk_keys)e.key, e.down);
                    break;
                case NuklearEventType.MouseButton:
                    nk_input_button(&ctx, cast(nk_buttons)e.button, e.x, e.y, e.down);
                    break;
                case NuklearEventType.MouseScroll:
                    nk_input_scroll(&ctx, nk_vec2(e.x, e.y));
                    break;
                case NuklearEventType.TextInput:
                    nk_input_unicode(&ctx, e.unicode);
                    break;
                default:
                    break;
            }
        }

        nk_input_end(&ctx);
    }

    override void render(GraphicsState* state)
    {
        const(int) maxVertexBuffer = 512 * 1024;
        const(int) maxElementBuffer = 128 * 1024;

        glEnable(GL_SCISSOR_TEST);
        glEnable(GL_BLEND);
        glBlendEquation(GL_FUNC_ADD);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_FALSE);
        glActiveTexture(GL_TEXTURE0);

        glUseProgram(shaderProgram);
        glUniform1i(textureLoc, 0);
        glUniformMatrix4fv(projectionMatrixLoc, 1, GL_FALSE, state.projectionMatrix.arrayof.ptr);

        //const(nk_draw_command) *cmd;
        void *vertices;
        void *elements;
        nk_draw_index* offset = null;
        nk_buffer vbuf;
        nk_buffer ebuf;

        // allocate vertex and element buffer
        glBindVertexArray(vao);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);

        glBufferData(GL_ARRAY_BUFFER, maxVertexBuffer, null, GL_STREAM_DRAW);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, maxElementBuffer, null, GL_STREAM_DRAW);

        // load vertices/elements directly into vertex/element buffer
        vertices = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
        elements = glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_WRITE_ONLY);
        {
            // fill convert configuration
            nk_convert_config config;
            nk_draw_vertex_layout_element[4] vertex_layout =
            [
                { NK_VERTEX_POSITION, NK_FORMAT_FLOAT, 0 },
                    { NK_VERTEX_TEXCOORD,  NK_FORMAT_FLOAT, 8 },
                        { NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, 16 },
                            NK_VERTEX_LAYOUT_END
            ];
            config.vertex_layout = vertex_layout.ptr;
            config.vertex_size = 20;
            config.vertex_alignment = 0;
            config.null_ = nullTexture;
            config.circle_segment_count = 16;
            config.curve_segment_count = 16;
            config.arc_segment_count = 16;
            config.global_alpha = 1.0f;
            config.shape_AA = NK_ANTI_ALIASING_ON;
            config.line_AA = NK_ANTI_ALIASING_ON;

            // setup buffers to load vertices and elements
            nk_buffer_init_fixed(&vbuf, vertices, cast(nk_size)maxVertexBuffer);
            nk_buffer_init_fixed(&ebuf, elements, cast(nk_size)maxElementBuffer);
            nk_convert(&ctx, &cmds, &vbuf, &ebuf, &config);
        }
        glUnmapBuffer(GL_ARRAY_BUFFER);
        glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);

        // iterate over and execute each draw command
        for (auto c = nk__draw_begin(&ctx, &cmds); c != null; c = nk__draw_next(c, &cmds, &ctx))
        {
            if (!c.elem_count)
                continue;
            glBindTexture(GL_TEXTURE_2D, c.texture.id);
            glScissor(cast(GLint)(c.clip_rect.x),
                cast(GLint)((eventManager.windowHeight - cast(GLint)(c.clip_rect.y + c.clip_rect.h))),
                cast(GLint)(c.clip_rect.w),
                cast(GLint)(c.clip_rect.h));
            glDrawElements(GL_TRIANGLES, c.elem_count, GL_UNSIGNED_INT, offset);
            offset += c.elem_count;
        }

        glDepthMask(GL_TRUE);
        glEnable(GL_DEPTH_TEST);
        glDisable(GL_BLEND);
        glDisable(GL_SCISSOR_TEST);

        glUseProgram(0);
    }

    // TODO: move this to a separate module for easier extending?
    static const(NKRune[]) fontDefaultGlyphRanges = [ 0x0020, 0x00FF, 0 ];
    static const(NKRune[]) fontLatinExtendedAGlyphRanges = [ 0x0020, 0x017F, 0 ];
    static const(NKRune[]) fontLatinExtendedBGlyphRanges = [ 0x0020, 0x024F, 0 ];
    static const(NKRune[]) fontCyrillicGlyphRanges = [ 0x0020, 0x00FF,  0x0400, 0x052F, 0x2DE0, 0x2DFF, 0xA640, 0xA69F, 0 ];
    static const(NKRune[]) fontGreekGlyphRanges = [ 0x0020, 0x00FF, 0x0370, 0x03FF, 0 ];
    static const(NKRune[]) fontChineseGlyphRanges = [ 0x0020, 0x00FF, 0x3000, 0x30FF, 0x31F0, 0x31FF, 0xFF00, 0xFFEF, 0x4E00, 0x9FAF, 0 ];
    static const(NKRune[]) fontJapaneseGlyphRanges = [ 0x0020, 0x00FF, 0x3000, 0x303F, 0x3040, 0x309F, 0x30A0, 0x30FF, 0 ];
    static const(NKRune[]) fontKoreanGlyphRanges = [ 0x0020, 0x00FF, 0x3131, 0x3163,  0xAC00, 0xD79D, 0 ];
    static const(NKRune[]) fontHebrewGlyphRanges = [ 0x0020, 0x00FF, 0x0590, 0x05FF, 0 ];
    static const(NKRune[]) fontArabicGlyphRanges = [ 0x0020, 0x00FF, 0x0600, 0x06FF, 0 ];
    static const(NKRune[]) fontArmenianGlyphRanges = [ 0x0020, 0x00FF, 0x0530, 0x058F, 0 ];
    static const(NKRune[]) fontGeorgianGlyphRanges = [ 0x0020, 0x00FF, 0x10A0, 0x10FF, 0 ];

    static const(NKRune[]) localeGlyphRanges(string locale = systemLocale())
    {
        if (locale == "ru_RU" || // Russian
            locale == "tt_RU")   // Tatar
            return fontCyrillicGlyphRanges;

        else if (locale == "fr_FR" || // French
                 locale == "de_DE" || // German
                 locale == "is_IS" || // Icelandic
                 locale == "es_ES" || // Spanish
                 locale == "ca_ES" || // Catalan
                 locale == "pl_PL" || // Polish
                 locale == "cs_CZ" || // Czech
                 locale == "lv_LV" || // Latvian
                 locale == "lt_LT" || // Lithuanian
                 locale == "sk_SK" || // Slovak
                 locale == "tr_TR" || // Turkish
                 locale == "cy_GB")   // Welsh
            return fontLatinExtendedAGlyphRanges;

        else if (locale == "el_GR") // Greek
            return fontGreekGlyphRanges;

        else if (locale == "zh_CN") // Chinese
            return fontChineseGlyphRanges;

        else if (locale == "ja_JP") // Japanese
            return fontJapaneseGlyphRanges;

        else if (locale == "ko_KR") // Korean
            return fontKoreanGlyphRanges;

        else if (locale == "he_IL") // Hebrew
            return fontHebrewGlyphRanges;

        else if (locale == "ar_AE" || // Arabic (United Arab Emirates)
                 locale == "ar_DZ" || // Arabic (Algeria)
                 locale == "ar_BH" || // Arabic (Bahrain)
                 locale == "ar_EG" || // Arabic (Egypt)
                 locale == "ar_IQ" || // Arabic (Iraq)
                 locale == "ar_JO" || // Arabic (Jordan)
                 locale == "ar_KW" || // Arabic (Kuwait)
                 locale == "ar_LB" || // Arabic (Lebanon)
                 locale == "ar_LY" || // Arabic (Libya)
                 locale == "ar_MA" || // Arabic (Morocco)
                 locale == "ar_OM" || // Arabic (Oman)
                 locale == "ar_QA" || // Arabic (Qatar)
                 locale == "ar_SA" || // Arabic (Saudi Arabia)
                 locale == "ar_SD" || // Arabic (Sudan)
                 locale == "ar_SY" || // Arabic (Syria)
                 locale == "ar_TN" || // Arabic (Tunisia)
                 locale == "ar_YE")   // Arabic (Yemen)
            return fontArabicGlyphRanges;

        else if (locale == "hy_AM") // Armenian
            return fontArmenianGlyphRanges;

        else if (locale == "ka_GE") // Georgian
            return fontArmenianGlyphRanges;

        else // Assume English
            return fontDefaultGlyphRanges;
    }

    NKFont* addFont(FontAsset font, float height = 13, const(NKRune[]) range = fontDefaultGlyphRanges)
    {
        return addFont(font.buffer.ptr, font.buffer.length, height, range);
    }
/*
    NKFont* addFont(string filename, float height = 13, const(NKRune[]) range = fontDefaultGlyphRanges)
    {
        import std.file;
        ubyte[] buffer = cast(ubyte[])std.file.read(filename);
        return addFont(buffer.ptr, buffer.length, height, range);
    }
*/
    NKFont* addFont(ubyte* buffer, ulong len, float height = 13, const(NKRune[]) range = fontDefaultGlyphRanges)
    {
        nk_font_config cfg = nk_font_config_(0);
        cfg.range = range.ptr;

        nk_font_atlas atlas;
        nk_font_atlas_init_default(&atlas);
        nk_font_atlas_begin(&atlas);

        nk_font* nkfont;
        if(buffer)
            nkfont = nk_font_atlas_add_from_memory(&atlas, buffer, cast(int)len, height, &cfg);
        else
            nkfont = nk_font_atlas_add_default(&atlas, height, &cfg);

        atlas.default_font = nkfont;

        int w = 0;
        int h = 0;
        const(void)* image = nk_font_atlas_bake(&atlas, &w, &h, NK_FONT_ATLAS_RGBA32);

        GLuint texture;
        glGenTextures(1, &texture);
        glBindTexture(GL_TEXTURE_2D, texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast(GLsizei)w, cast(GLsizei)h, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);

        nk_font_atlas_end(&atlas, nk_handle_id(cast(int)texture), &nullTexture);
        nk_style_set_font(&ctx, &atlas.default_font.handle);

        atlases.insertBack(atlas);
        fontsTextures.insertBack(texture);

        return nkfont;
    }

    //deprecated("No need to call generateFontAtlas()") void generateFontAtlas() {}

    NKFont* getFont(uint index)
    {
        if(index >= atlases.length)
            return atlases[0].default_font;

        return atlases[index].default_font;
    }

    float textWidth(const(char)* txt, int len)
    {
        const(nk_user_font) *f = ctx.style.font;
        return f.width(cast(nk_handle)f.userdata, f.height, txt, len);
    }

    float textWidth(NKFont* font, const(char)* txt, int len)
    {
        const(nk_user_font) *f = &font.handle;
        return f.width(cast(nk_handle)f.userdata, f.height, txt, len);
    }

    void inputKey(nk_keys key, int down)
    {
        auto e = NuklearEvent(NuklearEventType.Key);
        e.key = key;
        e.down = down;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void inputKeyDown(nk_keys key)
    {
        inputKey(key, 1);
    }

    void inputKeyUp(nk_keys key)
    {
        inputKey(key, 0);
    }

    void inputButton(int button, int down)
    {
        auto e = NuklearEvent(NuklearEventType.MouseButton);
        switch (button)
        {
            case MB_LEFT: e.button = nk_buttons.NK_BUTTON_LEFT; break;
            case MB_MIDDLE: e.button = nk_buttons.NK_BUTTON_MIDDLE; break;
            case MB_RIGHT: e.button = nk_buttons.NK_BUTTON_RIGHT; break;
            default:
                break;
        }
        e.x = eventManager.mouseX;
        e.y = eventManager.mouseY;
        e.down = down;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void inputButtonDown(int button)
    {
        inputButton(button, 1);
    }

    void inputButtonUp(int button)
    {
        inputButton(button, 0);
    }

    void inputScroll(int x, int y)
    {
        auto e = NuklearEvent(NuklearEventType.MouseScroll);
        e.x = x;
        e.y = y;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    void inputUnicode(dchar key)
    {
        auto e = NuklearEvent(NuklearEventType.TextInput);
        e.unicode = key;
        if (eventsCount < 10)
            events[eventsCount++] = e;
    }

    int begin(const(char)* title, NKRect bounds, NKFlags flags)
    {
        return nk_begin(&ctx, title, bounds, flags);
    }

    int beginTitled(const(char)* name, const(char)* title, NKRect bounds, NKFlags flags)
    {
        return nk_begin_titled(&ctx, name, title, bounds, flags);
    }

    void end()
    {
        nk_end(&ctx);
    }

    nk_style_window oldWindowStyle;

    int canvasBegin(const(char)* title, NKRect bounds, NKColor background = NKColor(255,255,255,255))
    {
        oldWindowStyle = ctx.style.window;

        ctx.style.window.spacing = nk_vec2(0, 0);
        ctx.style.window.padding = nk_vec2(0, 0);
        ctx.style.window.fixed_background = nk_style_item_color(background);

        nk_begin(&ctx, title, bounds, NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_BACKGROUND | NK_WINDOW_NO_INPUT);

        nk_rect totalSpace = nk_window_get_content_region(&ctx);
        nk_layout_row_dynamic(&ctx, totalSpace.h, 1);
        nk_widget(&totalSpace, &ctx);

        return 1;
    }

    void canvasEnd()
    {
        nk_end(&ctx);
        ctx.style.window = oldWindowStyle;
    }

    NKWindow* windowFind(const(char)* name)
    {
        return nk_window_find(&ctx, name);
    }

    NKPanel* windowGetPanel()
    {
        return nk_window_get_panel(&ctx);
    }

    NKRect windowGetContentRegion()
    {
        return nk_window_get_content_region(&ctx);
    }

    NKVec2 windowGetContentRegionMin()
    {
        return nk_window_get_content_region_min(&ctx);
    }

    NKVec2 windowGetContentRegionMax()
    {
        return nk_window_get_content_region_max(&ctx);
    }

    NKVec2 windowGetContentRegionSize()
    {
        return nk_window_get_content_region_size(&ctx);
    }

    nk_command_buffer* windowGetCanvas()
    {
        return nk_window_get_canvas(&ctx);
    }

    int windowIsHovered()
    {
        return nk_window_is_hovered(&ctx);
    }

    int windowIsCollapsed(const(char)* name)
    {
        return nk_window_is_collapsed(&ctx, name);
    }

    int windowIsClosed(const(char)* name)
    {
        return nk_window_is_closed(&ctx,  name);
    }

    int windowIsHidden(const(char)* name)
    {
        return nk_window_is_hidden(&ctx,  name);
    }

    int windowIsActive(const(char)* name)
    {
        return nk_window_is_active(&ctx, name);
    }

    int windowIsAnyHovered()
    {
        return nk_window_is_any_hovered(&ctx);
    }

    int itemIsAnyActive()
    {
        return nk_item_is_any_active(&ctx);
    }

    void windowSetBounds(const(char)* name, NKRect bounds)
    {
        nk_window_set_bounds(&ctx, name, bounds);
    }

    void windowSetPosition(const(char)* name, NKVec2 pos)
    {
        nk_window_set_position(&ctx, name, pos);
    }

    void windowSetSize(const(char)* name, NKVec2 size)
    {
        nk_window_set_size(&ctx, name, size);
    }

    void windowSetFocus(const(char)* name)
    {
        nk_window_set_focus(&ctx, name);
    }

    void windowClose(const(char)* name)
    {
        nk_window_close(&ctx, name);
    }

    void windowCollapse(const(char)* name, nk_collapse_states state)
    {
        nk_window_collapse(&ctx, name, state);
    }

    void windowCollapseIf(const(char)* name, nk_collapse_states state, int cond)
    {
        nk_window_collapse_if (&ctx, name, state, cond);
    }

    void windowShow(const(char)* name, nk_show_states state)
    {
        nk_window_show(&ctx, name, state);
    }

    void windowShowIf(const(char)* name, nk_show_states state, int cond)
    {
        nk_window_show_if (&ctx, name, state, cond);
    }

    void layoutSetMinRowHeight(float height)
    {
        nk_layout_set_min_row_height(&ctx, height);
    }

    void layoutResetMinRowHeight()
    {
        nk_layout_reset_min_row_height(&ctx);
    }

    NKRect layoutWidgetBounds()
    {
        return nk_layout_widget_bounds(&ctx);
    }

    float layoutRatioFromPixel(float pixel_width)
    {
        return nk_layout_ratio_from_pixel(&ctx, pixel_width);
    }

    void layoutRowDynamic(float height, int cols)
    {
        nk_layout_row_dynamic(&ctx, height, cols);
    }

    void layoutRowStatic(float height, int item_width, int cols)
    {
        nk_layout_row_static(&ctx, height, item_width, cols);
    }

    void layoutRowBegin(nk_layout_format fmt, float row_height, int cols)
    {
        nk_layout_row_begin(&ctx, fmt, row_height, cols);
    }

    void layoutRowPush(float value)
    {
        nk_layout_row_push(&ctx, value);
    }

    void layoutRowEnd()
    {
        nk_layout_row_end(&ctx);
    }

    void layoutRow(nk_layout_format format, float height, int cols, const(float)* ratio)
    {
        nk_layout_row(&ctx, format, height, cols, ratio);
    }

    void layoutRowTemplateBegin(float row_height)
    {
        nk_layout_row_template_begin(&ctx, row_height);
    }

    void layoutRowTemplatePushDynamic()
    {
        nk_layout_row_template_push_dynamic(&ctx);
    }

    void layoutRowTemplatePushVariable(float min_width)
    {
        nk_layout_row_template_push_variable(&ctx, min_width);
    }

    void layoutRowTemplatePushStatic(float width)
    {
        nk_layout_row_template_push_static(&ctx, width);
    }

    void layoutRowTemplateEnd()
    {
        nk_layout_row_template_end(&ctx);
    }

    void layoutSpaceBegin(nk_layout_format foramt, float height, int widget_count)
    {
        nk_layout_space_begin(&ctx, foramt, height, widget_count);
    }

    void layoutSpacePush(NKRect bounds)
    {
        nk_layout_space_push(&ctx, bounds);
    }

    void layoutSpaceEnd()
    {
        nk_layout_space_end(&ctx);
    }

    NKRect layoutSpaceBounds()
    {
        return nk_layout_space_bounds(&ctx);
    }

    NKVec2 layoutSpaceToScreen(NKVec2 a)
    {
        return nk_layout_space_to_screen(&ctx, a);
    }

    NKVec2 layoutSpaceToLocal(NKVec2 a)
    {
        return nk_layout_space_to_local(&ctx, a);
    }

    NKRect layoutSpaceRectToScreen(NKRect a)
    {
        return nk_layout_space_rect_to_screen(&ctx, a);
    }

    NKRect layoutSpaceRectToLocal(NKRect a)
    {
        return nk_layout_space_rect_to_local(&ctx, a);
    }

    int groupBegin(const(char)* title, NKFlags flags)
    {
        return nk_group_begin(&ctx, title, flags);
    }

    int groupBeginTitled(const(char)* name, const(char)* title, NKFlags flags)
    {
        return nk_group_begin_titled(&ctx, name, title, flags);
    }

    void groupEnd()
    {
        nk_group_end(&ctx);
    }

    int groupScrolledOffsetBegin(nk_uint* x_offset, nk_uint* y_offset, const(char)* title, NKFlags flags)
    {
        return nk_group_scrolled_offset_begin(&ctx, x_offset, y_offset, title, flags);
    }

    int groupScrolledBegin(nk_scroll* off, const(char)* title, NKFlags flags)
    {
        return nk_group_scrolled_begin(&ctx, off, title, flags);
    }

    void groupScrolledEnd()
    {
        nk_group_scrolled_end(&ctx);
    }

    int treePush(size_t line = __LINE__)(nk_tree_type type, const(char) *title, nk_collapse_states state)
    {
        return nk_tree_push_hashed(&ctx, type, title, state, null, 0, line);
    }

    int treePushId(nk_tree_type type, const(char) *title, nk_collapse_states state, int id)
    {
        return nk_tree_push_hashed(&ctx, type, title, state, null, 0, id);
    }

    void treePop()
    {
        nk_tree_pop(&ctx);
    }

    int treeStatePush(nk_tree_type type, const(char)* title, nk_collapse_states* state)
    {
        return nk_tree_state_push(&ctx, type, title, state);
    }

    int treeStateImagePush(nk_tree_type type, NKImage image, const(char)* title, nk_collapse_states* state)
    {
        return nk_tree_state_image_push(&ctx, type, image, title, state);
    }

    void treeStatePop()
    {
        nk_tree_state_pop(&ctx);
    }

    auto treeElementPush(size_t line = __LINE__)(nk_tree_type type, const(char) *title, nk_collapse_states state, int* selected)
    {
        return nk_tree_element_push_hashed(&ctx, type, title, state, selected, null, 0, line);
    }

    auto treeElementPushId(nk_tree_type type, const(char) *title, nk_collapse_states state, int* selected, int id)
    {
        return nk_tree_element_push_hashed(&ctx, type, title, state, selected, null, 0, id);
    }

    auto treeElementImagePush(size_t line = __LINE__)(nk_tree_type type, NKImage img, const(char) *title, nk_collapse_states state)
    {
        return nk_tree_image_push_hashed(&ctx, type, img, title, state, null, 0, line);
    }

    auto treeElementImagePushId(nk_tree_type type, NKImage img, const(char) *title, nk_collapse_states state, int id)
    {
        return nk_tree_image_push_hashed(&ctx, type, img, title, state, null, 0, id);
    }

    void treeElementPop()
    {
        nk_tree_element_pop(&ctx);
    }

    int listViewBegin(nk_list_view* out_, const(char)* id, NKFlags flags, int row_height, int row_count)
    {
        return nk_list_view_begin(&ctx, out_, id, flags, row_height, row_count);
    }

    NKRect widgetBounds()
    {
        return nk_widget_bounds(&ctx);
    }

    NKVec2 widgetPosition()
    {
        return nk_widget_position(&ctx);
    }

    NKVec2 widgetSize()
    {
        return nk_widget_size(&ctx);
    }

    float widgetWidth()
    {
        return nk_widget_width(&ctx);
    }

    float widgetHeight()
    {
        return nk_widget_height(&ctx);
    }

    int widgetIsHovered()
    {
        return nk_widget_is_hovered(&ctx);
    }

    int widgetIsMouseClicked(nk_buttons buttons)
    {
        return nk_widget_is_mouse_clicked(&ctx, buttons);
    }

    int widgetHasMouseClickDown(nk_buttons buttons, int down)
    {
        return nk_widget_has_mouse_click_down(&ctx, buttons, down);
    }

    void spacing(int cols)
    {
        nk_spacing(&ctx, cols);
    }

    void text(const(char)* txt, int len, NKFlags flags)
    {
        nk_text(&ctx, txt, len, flags);
    }

    void textColored(const(char)* txt, int len, NKFlags flags, NKColor color)
    {
        nk_text_colored(&ctx, txt, len, flags, color);
    }

    void textWrap(const(char)* txt, int len)
    {
        nk_text_wrap(&ctx, txt, len);
    }

    void textWrapColored(const(char)* txt, int len, NKColor color)
    {
        nk_text_wrap_colored(&ctx, txt, len, color);
    }

    void label(const(char)* txt, NKFlags align__)
    {
        nk_label(&ctx, txt, align__);
    }

    void labelColored(const(char)* txt, NKFlags align__, NKColor color)
    {
        nk_label_colored(&ctx, txt, align__, color);
    }

    void labelWrap(const(char)* txt)
    {
        nk_label_wrap(&ctx, txt);
    }

    void labelColoredWrap(const(char)* txt, NKColor color)
    {
        nk_label_colored_wrap(&ctx, txt, color);
    }

    void image(NKImage img)
    {
        nk_image_(&ctx, img);
    }

    void imageColor(NKImage img, NKColor color)
    {
        nk_image_color(&ctx, img, color);
    }

    void labelf(NKFlags align_, const(char)* format, ...)
    {
        va_list args;
        va_start(args, format);
        nk_labelfv(&ctx, align_, format, args);
    }

    void labelfColored(NKFlags align_, NKColor color, const(char)* format, ...)
    {
        va_list args;
        va_start(args, format);
        version(GNU) {
	        nk_labelf_colored(&ctx, align_, color, format, args.ptr);
        } else {
        	nk_labelf_colored(&ctx, align_, color, format, args);
        }
    }

    void labelfWrap(const(char)* format, ...)
    {
        va_list args;
        va_start(args, format);
        version(GNU) {
	        nk_labelf_wrap(&ctx, format, args.ptr);
        } else {
        	nk_labelf_wrap(&ctx, format, args);
        }
    }

    void labelfColoredWrap(NKColor color, const(char)* format, ...)
    {
        va_list args;
        va_start(args, format);
        version (GNU) {
	        nk_labelf_colored_wrap(&ctx, color, format, args.ptr);
        } else {
        	nk_labelf_colored_wrap(&ctx, color, format, args);
        }
    }

    void valueBool(const(char)* prefix, int value)
    {
        nk_value_bool(&ctx, prefix, value);
    }

    void valueInt(const(char)* prefix, int value)
    {
        nk_value_int(&ctx, prefix, value);
    }

    void valueUint(const(char)* prefix, uint value)
    {
        nk_value_uint(&ctx, prefix, value);
    }

    void valueFloat(const(char)* prefix, float value)
    {
        nk_value_float(&ctx, prefix, value);
    }

    void valueColorByte(const(char)* prefix, NKColor value)
    {
        nk_value_color_byte(&ctx, prefix, value);
    }

    void valueColorFloat(const(char)* prefix, NKColor value)
    {
        nk_value_color_float(&ctx, prefix, value);
    }

    void valueColorHex(const(char)* prefix, NKColor value)
    {
        nk_value_color_hex(&ctx, prefix, value);
    }

    int buttonText(const(char)* title, int len)
    {
        return nk_button_text(&ctx, title, len);
    }

    int buttonLabel(const(char)* title)
    {
        return nk_button_label(&ctx, title);
    }

    int buttonColor(Color4f color)
    {
        return nk_button_color(&ctx, color.toNKColor);
    }

    int buttonColor(NKColor color)
    {
        return nk_button_color(&ctx, color);
    }

    int buttonSymbol(nk_symbol_type type)
    {
        return nk_button_symbol(&ctx, type);
    }

    int buttonImage(NKImage img)
    {
        return nk_button_image(&ctx, img);
    }

    int buttonSymbolLabel(nk_symbol_type type, const(char)* label, NKFlags text_alignment)
    {
        return nk_button_symbol_label(&ctx, type, label, text_alignment);
    }

    int buttonSymbolText(nk_symbol_type type, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_button_symbol_text(&ctx, type, txt, len, align_ment);
    }

    int buttonImageLabel(NKImage img, const(char)* txt, NKFlags text_alignment)
    {
        return nk_button_image_label(&ctx, img, txt, text_alignment);
    }

    int buttonImageText(NKImage img, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_button_image_text(&ctx, img, txt, len, align_ment);
    }

    int buttonTextStyled(const(nk_style_button)* style, const(char)* title, int len)
    {
        return nk_button_text_styled(&ctx, style, title, len);
    }

    int buttonLabelStyled(const(nk_style_button)* style, const(char)* title)
    {
        return nk_button_label_styled(&ctx, style, title);
    }

    int buttonSymbolStyled(const(nk_style_button)* style, nk_symbol_type type)
    {
        return nk_button_symbol_styled(&ctx, style, type);
    }

    int buttonImageStyled(const(nk_style_button)* style, NKImage img)
    {
        return nk_button_image_styled(&ctx, style, img);
    }

    int buttonSymbolTextStyled(const(nk_style_button)* style, nk_symbol_type type, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_button_symbol_text_styled(&ctx, style, type, txt, len, align_ment);
    }

    int buttonSymbolLabelStyled(const(nk_style_button)* style, nk_symbol_type symbol, const(char)* title, NKFlags align_)
    {
        return nk_button_symbol_label_styled(&ctx, style, symbol, title, align_);
    }

    int buttonImageLabelStyled(const(nk_style_button)* style, NKImage img, const(char)* label, NKFlags text_alignment)
    {
        return nk_button_image_label_styled(&ctx, style, img, label, text_alignment);
    }

    int buttonImageTextStyled(const(nk_style_button)* style, NKImage img, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_button_image_text_styled(&ctx, style, img, txt, len, align_ment);
    }

    void buttonSetBehavior(nk_button_behavior beh)
    {
        nk_button_set_behavior(&ctx, beh);
    }

    int buttonPushBehavior(nk_button_behavior beh)
    {
        return nk_button_push_behavior(&ctx, beh);
    }

    int buttonPopBehavior()
    {
        return nk_button_pop_behavior(&ctx);
    }

    int checkLabel(const(char)* label, int active)
    {
        return nk_check_label(&ctx, label, active);
    }

    int checkText(const(char)* txt, int len, int active)
    {
        return nk_check_text(&ctx, txt, len, active);
    }

    uint checkFlagsLabel(const(char)* label, uint flags, uint value)
    {
        return nk_check_flags_label(&ctx, label, flags, value);
    }

    uint checkFlagsText(const(char)* txt, int len, uint flags, uint value)
    {
        return nk_check_flags_text(&ctx, txt, len, flags, value);
    }

    int checkboxLabel(const(char)* label, int* active)
    {
        return nk_checkbox_label(&ctx, label, active);
    }

    int checkboxText(const(char)* txt, int len, int* active)
    {
        return nk_checkbox_text(&ctx, txt, len, active);
    }

    int checkboxFlagsLabel(const(char)* label, uint* flags, uint value)
    {
        return nk_checkbox_flags_label(&ctx, label, flags, value);
    }

    int checkboxFlagsText(const(char)* txt, int len, uint* flags, uint value)
    {
        return nk_checkbox_flags_text(&ctx, txt, len, flags, value);
    }

    int radioLabel(const(char)* label, int* active)
    {
        return nk_radio_label(&ctx, label, active);
    }

    int radioText(const(char)* txt, int len, int* active)
    {
        return nk_radio_text(&ctx, txt, len, active);
    }

    int optionLabel(const(char)* label, int active)
    {
        return nk_option_label(&ctx, label, active);
    }

    int optionText(const(char)* txt, int len, int active)
    {
        return nk_option_text(&ctx, txt, len, active);
    }

    int selectableLabel(const(char)* label, NKFlags align_, int* value)
    {
        return nk_selectable_label(&ctx, label, align_, value);
    }

    int selectableText(const(char)* txt, int len, NKFlags align_, int* value)
    {
        return nk_selectable_text(&ctx, txt, len, align_, value);
    }

    int selectableImageLabel(NKImage img, const(char)* label, NKFlags align_, int* value)
    {
        return nk_selectable_image_label(&ctx, img, label, align_, value);
    }

    int selectableImageText(NKImage img, const(char)* text, int len, NKFlags align_, int* value)
    {
        return nk_selectable_image_text(&ctx, img, text, len, align_, value);
    }

    int selectableSymbolLabel(nk_symbol_type type, const(char)* label, NKFlags align_, int* value)
    {
        return nk_selectable_symbol_label(&ctx, type, label, align_, value);
    }

    int selectableSymbolText(nk_symbol_type type, const(char)* txt, int len, NKFlags align_, int* value)
    {
        return nk_selectable_symbol_text(&ctx, type, txt, len, align_, value);
    }

    int selectLabel(const(char)* label, NKFlags align_, int value)
    {
        return nk_select_label(&ctx, label, align_, value);
    }

    int selectText(const(char)* txt, int len, NKFlags align_, int value)
    {
        return nk_select_text(&ctx, txt, len, align_, value);
    }

    int selectImageLabel(NKImage img, const(char)* label, NKFlags align_, int value)
    {
        return nk_select_image_label(&ctx, img, label, align_, value);
    }

    int selectImageText(NKImage img, const(char)* txt, int len, NKFlags align_, int value)
    {
        return nk_select_image_text(&ctx, img, txt, len, align_, value);
    }

    int selectSymbolLabel(nk_symbol_type type, const(char)* label, NKFlags align_, int value)
    {
        return nk_select_symbol_label(&ctx, type, label, align_, value);
    }

    int selectSymbolText(nk_symbol_type type, const(char)* txt, int len, NKFlags align_, int value)
    {
        return nk_select_symbol_text(&ctx, type, txt, len, align_, value);
    }

    float slide(float min, float val, float max, float step)
    {
        return nk_slide_float(&ctx,min, val, max, step);
    }

    int slide(int min, int val, int max, int step)
    {
        return nk_slide_int(&ctx,min, val, max, step);
    }

    int slider(float min, float* val, float max, float step)
    {
        return nk_slider_float(&ctx, min, val, max, step);
    }

    int slider(int min, int* val, int max, int step)
    {
        return nk_slider_int(&ctx, min, val, max, step);
    }

    int progress(NKSize* cur, NKSize max, int modifyable)
    {
        return nk_progress(&ctx, cur, max, modifyable);
    }

    NKSize prog(NKSize cur, NKSize max, int modifyable)
    {
        return nk_prog(&ctx, cur, max, modifyable);
    }

    NKColorf colorPicker(NKColorf color, nk_color_format format)
    {
        return nk_color_picker(&ctx, color, format);
    }

    Color4f colorPicker(Color4f color, nk_color_format format)
    {
        nk_colorf tmp = nk_colorf(color.r, color.g, color.b, color.a);
        tmp = nk_color_picker(&ctx, tmp, format);
        return Color4f(tmp.r, tmp.g, tmp.b, tmp.a);
    }

    int colorPick(NKColorf* color, nk_color_format format)
    {
        return nk_color_pick(&ctx, color, format);
    }

    int colorPick(Color4f* color, nk_color_format format)
    {
        nk_colorf tmp = nk_colorf(color.r, color.g, color.b, color.a);
        int res = nk_color_pick(&ctx, &tmp, format);
        *color = Color4f(tmp.r, tmp.g, tmp.b, tmp.a);
        return res;
    }

    void property(const(char)* name, int min, int* val, int max, int step, float inc_per_pixel)
    {
        nk_property_int(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    void property(const(char)* name, float min, float* val, float max, float step, float inc_per_pixel)
    {
        nk_property_float(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    void property(const(char)* name, double min, double* val, double max, double step, float inc_per_pixel)
    {
        nk_property_double(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    int property(const(char)* name, int min, int val, int max, int step, float inc_per_pixel)
    {
        return nk_propertyi(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    float property(const(char)* name, float min, float val, float max, float step, float inc_per_pixel)
    {
        return nk_propertyf(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    double property(const(char)* name, double min, double val, double max, double step, float inc_per_pixel)
    {
        return nk_propertyd(&ctx, name, min, val, max, step, inc_per_pixel);
    }

    alias nk_filter_default_fptr filterDefault;
    alias nk_filter_ascii_fptr filterAscii;
    alias nk_filter_float_fptr filterFloat;
    alias nk_filter_decimal_fptr filterDecimal;
    alias nk_filter_hex_fptr filterHex;
    alias nk_filter_oct_fptr filterOct;
    alias nk_filter_binary_fptr filterBinary;

    NKFlags editString(NKFlags flags, char* buffer, int* len, int max, nk_plugin_filter filter = filterDefault)
    {
        return nk_edit_string(&ctx, flags, buffer, len, max, filter);
    }

    NKFlags editStringZeroTerminated(NKFlags flags, char* buffer, int max, nk_plugin_filter filter = filterDefault)
    {
        return nk_edit_string_zero_terminated(&ctx, flags, buffer, max, filter);
    }

    NKFlags editBuffer(NKFlags flags, nk_text_edit* edit, nk_plugin_filter filter = filterDefault)
    {
        return nk_edit_buffer(&ctx, flags, edit, filter);
    }

    void editFocus(NKFlags flags)
    {
        nk_edit_focus(&ctx, flags);
    }

    void editUnfocus()
    {
        nk_edit_unfocus(&ctx);
    }

    int chartBegin(nk_chart_type type, int num, float min, float max)
    {
        return nk_chart_begin(&ctx, type, num, min, max);
    }

    int chartBeginColored(nk_chart_type type, NKColor color, NKColor active, int num, float min, float max)
    {
        return nk_chart_begin_colored(&ctx, type, color, active, num, min, max);
    }

    void chartAddSlot(const(nk_chart_type) type, int count, float min_value, float max_value)
    {
        nk_chart_add_slot(&ctx, type, count, min_value, max_value);
    }

    void chartAddSlotColored(const(nk_chart_type) type, NKColor color, NKColor active, int count, float min_value, float max_value)
    {
        nk_chart_add_slot_colored(&ctx, type, color, active, count, min_value, max_value);
    }

    NKFlags chartPush(float value)
    {
        return nk_chart_push(&ctx, value);
    }

    NKFlags chartPushSlot(float value, int slot)
    {
        return nk_chart_push_slot(&ctx, value, slot);
    }

    void chartEnd()
    {
        nk_chart_end(&ctx);
    }

    void plot(nk_chart_type type, const(float)* values, int count, int offset)
    {
        nk_plot(&ctx, type, values, count, offset);
    }

    void plotFunction(nk_chart_type type, float function(int index) fn, int count, int offset)
    {
        import std.algorithm : min, max;
        int i = 0;
        float min_value;
        float max_value;

        if (count == 0) return;

        max_value = min_value = fn(offset);
        for (i = 0; i < count; ++i)
        {
            float value = fn(i + offset);
            min_value = min(value, min_value);
            max_value = max(value, max_value);
        }

        if (nk_chart_begin(&ctx, type, count, min_value, max_value))
        {
            for (i = 0; i < count; ++i)
                nk_chart_push(&ctx, fn(i + offset));
            nk_chart_end(&ctx);
        }
    }

    int popupBegin(nk_popup_type type, const(char)* title, NKFlags flags, NKRect bounds)
    {
        return nk_popup_begin(&ctx, type, title, flags, bounds);
    }

    void popupClose()
    {
        nk_popup_close(&ctx);
    }

    void popupEnd()
    {
        nk_popup_end(&ctx);
    }

    int combo(const(char)** items, int count, int selected, int item_height, NKVec2 size)
    {
        return nk_combo(&ctx, items, count, selected, item_height, size);
    }

    int comboSeparator(const(char)* items_separated_by_separator, int separator, int selected, int count, int item_height, NKVec2 size)
    {
        return nk_combo_separator(&ctx, items_separated_by_separator, separator, selected, count, item_height, size);
    }

    int comboString(const(char)* items_separated_by_zeros, int selected, int count, int item_height, NKVec2 size)
    {
        return nk_combo_string(&ctx, items_separated_by_zeros, selected, count, item_height, size);
    }

    /*int comboCallback(void func(void*, int, const(char) **) fn, void *userdata, int selected, int count, int item_height, NKVec2 size)
    {
    return nk_combo_callback(&ctx, fn, userdata, selected, count, item_height, size);
    }*/

    void combobox(const(char)** items, int count, int* selected, int item_height, NKVec2 size)
    {
        nk_combobox(&ctx, items, count, selected, item_height, size);
    }

    void comboboxString(const(char)* items_separated_by_zeros, int* selected, int count, int item_height, NKVec2 size)
    {
        nk_combobox_string(&ctx, items_separated_by_zeros, selected, count, item_height, size);
    }

    void comboboxSeparator(const(char)* items_separated_by_separator, int separator, int* selected, int count, int item_height, NKVec2 size)
    {
        nk_combobox_separator(&ctx, items_separated_by_separator, separator, selected, count, item_height, size);
    }

    /*void comboboxCallback(void function(void*, int, const(char) **), void*, int *selected, int count, int item_height, NKVec2 size)
    {
    nk_combobox_callback(&ctx);
    }*/

    int comboBeginText(const(char)* selected, int len, NKVec2 size)
    {
        return nk_combo_begin_text(&ctx, selected, len, size);
    }

    int comboBeginLabel(const(char)* selected, NKVec2 size)
    {
        return nk_combo_begin_label(&ctx, selected, size);
    }

    int comboBeginColor(NKColor color, NKVec2 size)
    {
        return nk_combo_begin_color(&ctx, color, size);
    }

    int comboBeginSymbol(nk_symbol_type type, NKVec2 size)
    {
        return nk_combo_begin_symbol(&ctx, type, size);
    }

    int comboBeginSymbolLabel(const(char)* selected, nk_symbol_type type, NKVec2 size)
    {
        return nk_combo_begin_symbol_label(&ctx, selected, type, size);
    }

    int comboBeginSymbolText(const(char)* selected, int len, nk_symbol_type type, NKVec2 size)
    {
        return nk_combo_begin_symbol_text(&ctx, selected, len, type, size);
    }

    int comboBeginImage(NKImage img, NKVec2 size)
    {
        return nk_combo_begin_image(&ctx, img, size);
    }

    int comboBeginImageLabel(const(char)* selected, NKImage img, NKVec2 size)
    {
        return nk_combo_begin_image_label(&ctx, selected, img, size);
    }

    int comboBeginImageText(const(char)* selected, int len, NKImage img, NKVec2 size)
    {
        return nk_combo_begin_image_text(&ctx, selected, len, img, size);
    }

    int comboItemLabel(const(char)* label, NKFlags align_ment)
    {
        return nk_combo_item_label(&ctx, label, align_ment);
    }

    int comboItemText(const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_combo_item_text(&ctx, txt, len, align_ment);
    }

    int comboItemImageLabel(NKImage img, const(char)* label, NKFlags align_ment)
    {
        return nk_combo_item_image_label(&ctx, img, label, align_ment);
    }

    int comboItemImageText(NKImage img, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_combo_item_image_text(&ctx, img, txt, len, align_ment);
    }

    int comboItemSymbolLabel(nk_symbol_type type, const(char)* label, NKFlags align_ment)
    {
        return nk_combo_item_symbol_label(&ctx, type, label, align_ment);
    }

    int comboItemSymbolText(nk_symbol_type type, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_combo_item_symbol_text(&ctx, type, txt, len, align_ment);
    }

    void comboClose()
    {
        nk_combo_close(&ctx);
    }

    void comboEnd()
    {
        nk_combo_end(&ctx);
    }

    int contextualBegin(NKFlags flags, NKVec2 size, NKRect trigger_bounds)
    {
        return nk_contextual_begin(&ctx, flags, size, trigger_bounds);
    }

    int contextualItemText(const(char)* txt, int len, NKFlags align_)
    {
        return nk_contextual_item_text(&ctx, txt, len, align_);
    }

    int contextualItemLabel(const(char)* label, NKFlags align_)
    {
        return nk_contextual_item_label(&ctx, label, align_);
    }

    int contextualItemImageLabel(NKImage img, const(char)* label, NKFlags align_ment)
    {
        return nk_contextual_item_image_label(&ctx, img, label, align_ment);
    }

    int contextualItemImageText(NKImage img, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_contextual_item_image_text(&ctx, img, txt, len, align_ment);
    }

    int contextualItemSymbolLabel(nk_symbol_type type, const(char)* label, NKFlags align_ment)
    {
        return nk_contextual_item_symbol_label(&ctx, type, label, align_ment);
    }

    int contextualItemSymbolText(nk_symbol_type type, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_contextual_item_symbol_text(&ctx, type, txt, len, align_ment);
    }

    void contextualClose()
    {
        nk_contextual_close(&ctx);
    }

    void contextualEnd()
    {
        nk_contextual_end(&ctx);
    }

    void tooltip(const(char)* txt)
    {
        nk_tooltip(&ctx, txt);
    }

    void tooltipf(const(char)* format, ...)
    {
        va_list args;
        va_start(args, format);
        nk_tooltipfv(&ctx, format, args);
    }

    int tooltipBegin(float width)
    {
        return nk_tooltip_begin(&ctx, width);
    }

    void tooltipEnd()
    {
        nk_tooltip_end(&ctx);
    }

    void menubarBegin()
    {
        nk_menubar_begin(&ctx);
    }

    void menubarEnd()
    {
        nk_menubar_end(&ctx);
    }

    int menuBeginText(const(char)* title, int title_len, NKFlags align_, NKVec2 size)
    {
        return nk_menu_begin_text(&ctx, title, title_len, align_, size);
    }

    int menuBeginLabel(const(char)* label, NKFlags align_, NKVec2 size)
    {
        return nk_menu_begin_label(&ctx, label, align_, size);
    }

    int menuBeginImage(const(char)* label, NKImage img, NKVec2 size)
    {
        return nk_menu_begin_image(&ctx, label, img, size);
    }

    int menuBeginImageText(const(char)* txt, int len, NKFlags align_, NKImage img, NKVec2 size)
    {
        return nk_menu_begin_image_text(&ctx, txt, len, align_, img, size);
    }

    int menuBeginImageLabel(const(char)* label, NKFlags align_, NKImage img, NKVec2 size)
    {
        return nk_menu_begin_image_label(&ctx, label, align_, img, size);
    }

    int menuBeginSymbol(const(char)* label, nk_symbol_type type, NKVec2 size)
    {
        return nk_menu_begin_symbol(&ctx, label, type, size);
    }

    int menuBeginSymbolText(const(char)* txt, int len, NKFlags align_, nk_symbol_type type, NKVec2 size)
    {
        return nk_menu_begin_symbol_text(&ctx, txt, len, align_, type, size);
    }

    int menuBeginSymbolLabel(const(char)* label, NKFlags align_, nk_symbol_type type, NKVec2 size)
    {
        return nk_menu_begin_symbol_label(&ctx, label, align_, type, size);
    }

    int menuItemText(const(char)* txt, int len, NKFlags align_)
    {
        return nk_menu_item_text(&ctx, txt, len, align_);
    }

    int menuItemLabel(const(char)* label, NKFlags align_ment)
    {
        return nk_menu_item_label(&ctx, label, align_ment);
    }

    int menuItemImageLabel(NKImage img, const(char)* label, NKFlags align_ment)
    {
        return nk_menu_item_image_label(&ctx, img, label, align_ment);
    }

    int menuItemImageText(NKImage img, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_menu_item_image_text(&ctx, img, txt, len, align_ment);
    }

    int menuItemSymbolText(nk_symbol_type type, const(char)* txt, int len, NKFlags align_ment)
    {
        return nk_menu_item_symbol_text(&ctx, type, txt, len, align_ment);
    }

    int menuItemSymbolLabel(nk_symbol_type type, const(char)* label, NKFlags align_ment)
    {
        return nk_menu_item_symbol_label(&ctx, type, label, align_ment);
    }

    void menuClose()
    {
        nk_menu_close(&ctx);
    }

    void menuEnd()
    {
        nk_menu_end(&ctx);
    }

    void styleDefault()
    {
        nk_style_default(&ctx);
    }

    void styleFromTable(const(NKColor)* colors)
    {
        nk_style_from_table(&ctx, colors);
    }

    void styleLoadCursor(nk_style_cursor cursor, const(NKCursor)* c)
    {
        nk_style_load_cursor(&ctx, cursor, c);
    }

    void styleLoadAllCursors(NKCursor* cursor)
    {
        nk_style_load_all_cursors(&ctx, cursor);
    }

    void styleSetFont(uint index)
    {
        nk_style_set_font(&ctx, &(getFont(index)).handle);
    }

    void styleSetFont(const(NKFont)* font)
    {
        nk_style_set_font(&ctx, &font.handle);
    }

    void styleSetFont(const(nk_user_font)* font)
    {
        nk_style_set_font(&ctx, font);
    }

    int styleSetCursor(nk_style_cursor cursor)
    {
        return nk_style_set_cursor(&ctx, cursor);
    }

    void styleShowCursor()
    {
        nk_style_show_cursor(&ctx);
    }

    void styleHideCursor()
    {
        nk_style_hide_cursor(&ctx);
    }

    int stylePushFont(const(nk_user_font)* font)
    {
        return nk_style_push_font(&ctx, font);
    }

    int stylePushFloat(float* address, float value)
    {
        return nk_style_push_float(&ctx, address, value);
    }

    int stylePushVec2(NKVec2* address, NKVec2 value)
    {
        return nk_style_push_vec2(&ctx, address, value);
    }

    int stylePushStyleItem(nk_style_item* address, nk_style_item value)
    {
        return nk_style_push_style_item(&ctx, address, value);
    }

    int stylePushFlags(NKFlags* address, NKFlags value)
    {
        return nk_style_push_flags(&ctx, address, value);
    }

    int stylePushColor(NKColor* address, NKColor value)
    {
        return nk_style_push_color(&ctx, address, value);
    }

    int stylePopFont()
    {
        return nk_style_pop_font(&ctx);
    }

    int stylePopFloat()
    {
        return nk_style_pop_float(&ctx);
    }

    int stylePopVec2()
    {
        return nk_style_pop_vec2(&ctx);
    }

    int stylePopStyleItem()
    {
        return nk_style_pop_style_item(&ctx);
    }

    int stylePopFlags()
    {
        return nk_style_pop_flags(&ctx);
    }

    int stylePopColor()
    {
        return nk_style_pop_color(&ctx);
    }

    // Primitives

    void strokeLine(float x0, float y0, float x1, float y1, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_line(&ctx.current.buffer, x0, y0, x1, y1, line_thickness, color);
    }

    void strokeCurve(float ax, float ay, float ctrl0x, float ctrl0y, float ctrl1x, float ctrl1y, float bx, float by, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_curve(&ctx.current.buffer, ax, ay, ctrl0x, ctrl0y, ctrl1x, ctrl1y, bx, by, line_thickness, color);
    }

    void strokeRect(NKRect rect, float rounding, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_rect(&ctx.current.buffer, rect, rounding, line_thickness, color);
    }

    void strokeCircle(NKRect rect, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_circle(&ctx.current.buffer, rect, line_thickness, color);
    }

    void strokeArc(float cx, float cy, float radius, float a_min, float a_max, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_arc(&ctx.current.buffer, cx, cy, radius, a_min, a_max, line_thickness, color);
    }

    void strokeTriangle(float x0, float y0, float x1, float y1, float x2, float y2, float line_thichness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_triangle(&ctx.current.buffer, x0, y0, x1, y1, x2, y2, line_thichness, color);
    }

    void strokePolyline(float* points, int point_count, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_polyline(&ctx.current.buffer, points, point_count, line_thickness, color);
    }

    void strokePolygon(float* points, int point_count, float line_thickness, NKColor color)
    {
        if(ctx.current)
            nk_stroke_polygon(&ctx.current.buffer, points, point_count, line_thickness, color);
    }

    void fillRect(NKRect rect, float rounding, NKColor color)
    {
        if(ctx.current)
            nk_fill_rect(&ctx.current.buffer, rect, rounding, color);
    }

    void fillRectMultiColor(NKRect rect, NKColor left, NKColor top, NKColor right, NKColor bottom)
    {
        if(ctx.current)
            nk_fill_rect_multi_color(&ctx.current.buffer, rect, left, top, right, bottom);
    }

    void fillCircle(NKRect rect, NKColor color)
    {
        if(ctx.current)
            nk_fill_circle(&ctx.current.buffer, rect, color);
    }

    void fillArc(float cx, float cy, float radius, float a_min, float a_max, NKColor color)
    {
        if(ctx.current)
            nk_fill_arc(&ctx.current.buffer, cx, cy, radius, a_min, a_max, color);
    }

    void fillTriangle(float x0, float y0, float x1, float y1, float x2, float y2, NKColor color)
    {
        if(ctx.current)
            nk_fill_triangle(&ctx.current.buffer, x0, y0, x1, y1, x2, y2, color);
    }

    void fillPolygon(float* points, int point_count, NKColor color)
    {
        if(ctx.current)
            nk_fill_polygon(&ctx.current.buffer, points, point_count, color);
    }

    void drawImage(NKRect rect, const(NKImage)* image, NKColor color)
    {
        if(ctx.current)
            nk_draw_image(&ctx.current.buffer, rect, image, color);
    }

    void drawText(NKRect rect, const(char)* txt, int len, const(NKFont)* font, NKColor bg, NKColor fg)
    {
        drawText(rect, txt, len, &font.handle, bg, fg);
    }

    void drawText(NKRect rect, const(char)* txt, int len, const(nk_user_font)* font, NKColor bg, NKColor fg)
    {
        if(!font)
            font = &atlases[0].default_font.handle;
        if(ctx.current)
            nk_draw_text(&ctx.current.buffer, rect, txt, len, font, bg, fg);
    }

    void pushScissor(NKRect rect)
    {
        if(ctx.current)
            nk_push_scissor(&ctx.current.buffer, rect);
    }

    // Colors

    NKColor rgb(int r, int g, int b)
    {
        return nk_rgb(r, g, b);
    }

    NKColor rgb(float r, float g, float b)
    {
        return nk_rgb_f(r, g, b);
    }

    NKColor rgb(char* hex)
    {
        return nk_rgb_hex(hex);
    }

    NKColor rgba(int r, int g, int b, int a)
    {
        return nk_rgba(r, g, b, a);
    }

    NKColor rgba(float r, float g, float b, float a)
    {
        return nk_rgba_f(r, g, b, a);
    }

    NKColor rgba(char* hex)
    {
        return nk_rgba_hex(hex);
    }

    NKColor hsv(int h, int s, int v)
    {
        return nk_hsv(h, s, v);
    }

    NKColor hsv(float h, float s, float v)
    {
        return nk_hsv_f(h, s, v);
    }

    NKColor hsva(int h, int s, int v, int a)
    {
        return nk_hsva(h, s, v, a);
    }

    NKColor hsva(float h, float s, float v, float a)
    {
        return nk_hsva_f(h, s, v, a);
    }
}
