/*
Copyright (c) 2026 Timur Gafarov.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module bindbc.joltc.types;

import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.quaternion;

enum float JPH_DEFAULT_COLLISION_TOLERANCE = 1.0e-4f;
enum float JPH_DEFAULT_PENETRATION_TOLERANCE = 1.0e-4f;
enum float JPH_DEFAULT_CONVEX_RADIUS = 0.05f;
enum float JPH_CAPSULE_PROJECTION_SLOP = 0.02f;
enum int JPH_MAX_PHYSICS_JOBS = 2048;
enum int JPH_MAX_PHYSICS_BARRIERS = 8;
enum uint JPH_INVALID_COLLISION_GROUP_ID = ~0U;
enum uint JPH_INVALID_COLLISION_SUBGROUP_ID = ~0U;
enum float JPH_M_PI = 3.14159265358979323846f;

alias JPH_Bool = uint;
alias JPH_BodyID = uint;
alias JPH_SubShapeID = uint;
alias JPH_ObjectLayer = uint;
alias JPH_BroadPhaseLayer = ubyte;
alias JPH_CollisionGroupID = uint;
alias JPH_CollisionSubGroupID = uint;
alias JPH_CharacterID = uint;

struct JPH_BroadPhaseLayerInterface;
struct JPH_ObjectVsBroadPhaseLayerFilter;
struct JPH_ObjectLayerPairFilter;

struct JPH_BroadPhaseLayerFilter;
struct JPH_ObjectLayerFilter;
struct JPH_BodyFilter;
struct JPH_ShapeFilter;

struct JPH_SimShapeFilter;

struct JPH_PhysicsStepListener;
struct JPH_PhysicsSystem;
struct JPH_PhysicsMaterial;

struct JPH_LinearCurve;

struct JPH_ShapeSettings;
struct JPH_ConvexShapeSettings;
struct JPH_SphereShapeSettings;
struct JPH_BoxShapeSettings;
struct JPH_PlaneShapeSettings;
struct JPH_TriangleShapeSettings;
struct JPH_CapsuleShapeSettings;
struct JPH_TaperedCapsuleShapeSettings;
struct JPH_CylinderShapeSettings;
struct JPH_TaperedCylinderShapeSettings;
struct JPH_ConvexHullShapeSettings;
struct JPH_CompoundShapeSettings;
struct JPH_StaticCompoundShapeSettings;
struct JPH_MutableCompoundShapeSettings;
struct JPH_MeshShapeSettings;
struct JPH_HeightFieldShapeSettings;
struct JPH_RotatedTranslatedShapeSettings;
struct JPH_ScaledShapeSettings;
struct JPH_OffsetCenterOfMassShapeSettings;
struct JPH_EmptyShapeSettings;

struct JPH_Shape;
struct JPH_ConvexShape;
struct JPH_SphereShape;
struct JPH_BoxShape;
struct JPH_PlaneShape;
struct JPH_CapsuleShape;
struct JPH_CylinderShape;
struct JPH_TaperedCylinderShape;
struct JPH_TriangleShape;
struct JPH_TaperedCapsuleShape;
struct JPH_ConvexHullShape;
struct JPH_CompoundShape;
struct JPH_StaticCompoundShape;
struct JPH_MutableCompoundShape;
struct JPH_MeshShape;
struct JPH_HeightFieldShape;
struct JPH_DecoratedShape;
struct JPH_RotatedTranslatedShape;
struct JPH_ScaledShape;
struct JPH_OffsetCenterOfMassShape;
struct JPH_EmptyShape;

struct JPH_BodyCreationSettings;
struct JPH_SoftBodyCreationSettings;
struct JPH_BodyInterface;
struct JPH_BodyLockInterface;
struct JPH_BroadPhaseQuery;
struct JPH_NarrowPhaseQuery;
struct JPH_MotionProperties;
struct JPH_Body;

struct JPH_ContactListener;
struct JPH_ContactManifold;

struct JPH_GroupFilter;
struct JPH_GroupFilterTable;

enum JPH_PhysicsUpdateError
{
    None = 0,
    ManifoldCacheFull = 1 << 0,
    BodyPairCacheFull = 1 << 1,
    ContactConstraintsFull = 1 << 2,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_BodyType
{
    Rigid = 0,
    Soft = 1,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_MotionType
{
    Static = 0,
    Kinematic = 1,
    Dynamic = 2,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_Activation
{
    Activate = 0,
    DontActivate = 1,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_ValidateResult
{
    AcceptAllContactsForThisBodyPair = 0,
    AcceptContact = 1,
    RejectContact = 2,
    RejectAllContactsForThisBodyPair = 3,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_ShapeType
{
    Convex = 0,
    Compound = 1,
    Decorated = 2,
    Mesh = 3,
    HeightField = 4,
    SoftBody = 5,
    User1 = 6,
    User2 = 7,
    User3 = 8,
    User4 = 9,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_ShapeSubType
{
    Sphere = 0,
    Box = 1,
    Triangle = 2,
    Capsule = 3,
    TaperedCapsule = 4,
    Cylinder = 5,
    ConvexHull = 6,
    StaticCompound = 7,
    MutableCompound = 8,
    RotatedTranslated = 9,
    Scaled = 10,
    OffsetCenterOfMass = 11,
    Mesh = 12,
    HeightField = 13,
    SoftBody = 14,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_ConstraintType
{
    Constraint = 0,
    TwoBodyConstraint = 1,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_ConstraintSubType
{
    Fixed = 0,
    Point = 1,
    Hinge = 2,
    Slider = 3,
    Distance = 4,
    Cone = 5,
    SwingTwist = 6,
    SixDOF = 7,
    Path = 8,
    Vehicle = 9,
    RackAndPinion = 10,
    Gear = 11,
    Pulley = 12,
    User1 = 13,
    User2 = 14,
    User3 = 15,
    User4 = 16,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_ConstraintSpace
{
    LocalToBodyCOM = 0,
    WorldSpace = 1,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_MotionQuality
{
    Discrete = 0,
    LinearCast = 1,
    Count,
    Force32 = 0x7fffffff
}

enum JPH_OverrideMassProperties
{
    CalculateMassAndInertia = 0,
    CalculateInertia = 1,
    MassAndInertiaProvided = 2,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_AllowedDOFs
{
    All = 0b111111,
    TranslationX = 0b000001,
    TranslationY = 0b000010,
    TranslationZ = 0b000100,
    RotationX = 0b001000,
    RotationY = 0b010000,
    RotationZ = 0b100000,
    Plane2D = TranslationX | TranslationY | RotationZ,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_GroundState
{
    OnGround = 0,
    OnSteepGround = 1,
    NotSupported = 2,
    InAir = 3,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_BackFaceMode
{
    IgnoreBackFaces,
    CollideWithBackFaces,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_ActiveEdgeMode
{
    CollideOnlyWithActive,
    CollideWithAll,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_CollectFacesMode
{
    CollectFaces,
    NoFaces,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_MotorState
{
    Off = 0,
    Velocity = 1,
    Position = 2,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_CollisionCollectorType
{
    AllHit = 0,
    AllHitSorted = 1,
    ClosestHit = 2,
    AnyHit = 3,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_SwingType
{
    Cone,
    Pyramid,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_SixDOFConstraintAxis
{
    TranslationX,
    TranslationY,
    TranslationZ,
    RotationX,
    RotationY,
    RotationZ,
    Num,
    NumTranslation = TranslationZ + 1,
    Force32 = 0x7FFFFFFF
}

enum JPH_SpringMode
{
    FrequencyAndDamping = 0,
    StiffnessAndDamping = 1,
    Count,
    Force32 = 0x7FFFFFFF
}

/// Defines how to color soft body constraints
enum JPH_SoftBodyConstraintColor
{
    ConstraintType,             /// Draw different types of constraints in different colors
    ConstraintGroup,            /// Draw constraints in the same group in the same color, non-parallel group will be red
    ConstraintOrder,            /// Draw constraints in the same group in the same color, non-parallel group will be red, and order within each group will be indicated with gradient
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_BodyManager_ShapeColor
{
    InstanceColor,                ///< Random color per instance
    ShapeTypeColor,                ///< Convex = green, scaled = yellow, compound = orange, mesh = red
    MotionTypeColor,            ///< Static = grey, keyframed = green, dynamic = random color per instance
    SleepColor,                    ///< Static = grey, keyframed = green, dynamic = yellow, sleeping = red
    IslandColor,                ///< Static = grey, active = random color per island, sleeping = light grey
    MaterialColor,                ///< Color as defined by the PhysicsMaterial of the shape
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_DebugRenderer_CastShadow
{
    On = 0,    ///< This shape should cast a shadow
    Off = 1,   ///< This shape should not cast a shadow
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_DebugRenderer_DrawMode
{
    Solid = 0,       ///< Draw as a solid shape
    Wireframe = 1,   ///< Draw as wireframe
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_Mesh_Shape_BuildQuality
{
    FavorRuntimePerformance = 0,
    FavorBuildSpeed = 1,
    Count,
    Force32 = 0x7FFFFFFF
}

enum JPH_TransmissionMode
{
    Auto = 0,
    Manual = 1,
    Count,
    Force32 = 0x7FFFFFFF
}

/*
struct JPH_Vec3
{
    float x;
    float y;
    float z;
}
*/

alias JPH_Vec3 = Vector3f;

/*
struct JPH_Vec4
{
    float x;
    float y;
    float z;
    float w;
}
*/

alias JPH_Vec4 = Vector4f;

/*
struct JPH_Quat
{
    float x;
    float y;
    float z;
    float w;
}
*/

alias JPH_Quat = Quaternionf;

struct JPH_Plane
{
    JPH_Vec3 normal;
    float distance;
}

/*
struct JPH_Mat4
{
    JPH_Vec4 column[4];
}
*/

alias JPH_Mat4 = Matrix4x4f;

/*
struct JPH_Point
{
    float x;
    float y;
}
*/

alias JPH_Point = Vector2f;

version(JPH_DOUBLE_PRECISION)
{
    /*
    struct JPH_RVec3
    {
        double x;
        double y;
        double z;
    }
    */
    
    alias JPH_RVec3 = Vector3d;
    
    struct JPH_RMat4
    {
        JPH_Vec4[3] column;
        JPH_RVec3 column3;
    }
}
else
{
    alias JPH_RVec3 = JPH_Vec3;
    alias JPH_RMat4 = JPH_Mat4;
}

alias JPH_Color = uint;

struct JPH_AABox
{
    JPH_Vec3 min;
    JPH_Vec3 max;
}

struct JPH_Triangle
{
    JPH_Vec3 v1;
    JPH_Vec3 v2;
    JPH_Vec3 v3;
    uint materialIndex;
}

struct JPH_IndexedTriangleNoMaterial
{
    uint i1;
    uint i2;
    uint i3;
}

struct JPH_IndexedTriangle
{
    uint i1;
    uint i2;
    uint i3;
    uint materialIndex;
    uint userData;
}

struct JPH_MassProperties
{
    float mass;
    JPH_Mat4 inertia;
}

struct JPH_ContactSettings
{
    float combinedFriction;
    float combinedRestitution;
    float invMassScale1;
    float invInertiaScale1;
    float invMassScale2;
    float invInertiaScale2;
    JPH_Bool isSensor;
    JPH_Vec3 relativeLinearSurfaceVelocity;
    JPH_Vec3 relativeAngularSurfaceVelocity;
}

struct JPH_CollideSettingsBase
{
    /// How active edges (edges that a moving object should bump into) are handled
    JPH_ActiveEdgeMode activeEdgeMode = JPH_ActiveEdgeMode.CollideOnlyWithActive;

    /// If colliding faces should be collected or only the collision point
    JPH_CollectFacesMode collectFacesMode = JPH_CollectFacesMode.NoFaces;

    /// If objects are closer than this distance (in meters), they are considered to be colliding (used for GJK)
    float collisionTolerance = JPH_DEFAULT_COLLISION_TOLERANCE;

    /**
     * A factor that determines the accuracy of the penetration depth calculation.
     * If the change of the squared distance is less than tolerance * current_penetration_depth^2
     * the algorithm will terminate.
     */
    float penetrationTolerance = JPH_DEFAULT_PENETRATION_TOLERANCE;

    /**
     * When mActiveEdgeMode is CollideOnlyWithActive a movement direction can be provided.
     * When hitting an inactive edge, the system will select the triangle normal as penetration
     * depth only if it impedes the movement less than with the calculated penetration depth.
     */
    JPH_Vec3 activeEdgeMovementDirection = JPH_Vec3(0.0f, 0.0f, 0.0f);
}

struct JPH_CollideShapeSettings
{
    JPH_CollideSettingsBase base;
    
    /**
     * When > 0 contacts in the vicinity of the query shape can be found.
     * All nearest contacts that are not further away than this distance will be found
     */
    float maxSeparationDistance = 0.0f;

    /// How backfacing triangles should be treated
    JPH_BackFaceMode backFaceMode = JPH_BackFaceMode.IgnoreBackFaces;
}

struct JPH_ShapeCastSettings
{
    JPH_CollideSettingsBase base;

    /**
     * How backfacing triangles should be treated
     * (should we report moving from back to front for triangle based shapes,
     * e.g. for MeshShape/HeightFieldShape?)
     */
    JPH_BackFaceMode backFaceModeTriangles = JPH_BackFaceMode.IgnoreBackFaces;

    /**
     * How backfacing convex objects should be treated
     * (should we report starting inside an object and moving out?)
     */
    JPH_BackFaceMode backFaceModeConvex = JPH_BackFaceMode.IgnoreBackFaces;

    /**
     * Indicates if we want to shrink the shape by the convex radius
     * and then expand it again. This speeds up collision detection
     * and gives a more accurate normal at the cost of a more 'rounded' shape.
     */
    bool useShrunkenShapeAndConvexRadius = false;

    /**
     * When true, and the shape is intersecting at the beginning of the cast
     * (fraction = 0) then this will calculate the deepest penetration point
     * (costing additional CPU time)
     */
    bool returnDeepestPoint = false;
}

struct JPH_RayCastSettings
{
    /**
     * How backfacing triangles should be treated
     * (should we report back facing hits for triangle based shapes,
     * e.g. MeshShape/HeightFieldShape?)
     */
    JPH_BackFaceMode backFaceModeTriangles = JPH_BackFaceMode.IgnoreBackFaces;

    /**
     * How backfacing convex objects should be treated
     * (should we report back facing hits for convex shapes?)
     */
    JPH_BackFaceMode backFaceModeConvex = JPH_BackFaceMode.IgnoreBackFaces;

    /**
     * If convex shapes should be treated as solid.
     * When true, a ray starting inside a convex shape will generate a hit at fraction 0.
     */
    bool treatConvexAsSolid = true;
}

struct JPH_SpringSettings
{
    JPH_SpringMode mode;
    float frequencyOrStiffness;
    float damping;
}

struct JPH_MotorSettings
{
    JPH_SpringSettings springSettings;
    float minForceLimit;
    float maxForceLimit;
    float minTorqueLimit;
    float maxTorqueLimit;
}

struct JPH_SubShapeIDPair
{
    JPH_BodyID Body1ID;
    JPH_SubShapeID subShapeID1;
    JPH_BodyID Body2ID;
    JPH_SubShapeID subShapeID2;
}

struct JPH_BroadPhaseCastResult
{
    JPH_BodyID bodyID;
    float fraction;
}

struct JPH_RayCastResult
{
    JPH_BodyID bodyID;
    float fraction;
    JPH_SubShapeID subShapeID2;
}

struct JPH_CollidePointResult
{
    JPH_BodyID bodyID;
    JPH_SubShapeID subShapeID2;
}

struct JPH_CollideShapeResult
{
    JPH_Vec3 contactPointOn1;
    JPH_Vec3 contactPointOn2;
    JPH_Vec3 penetrationAxis;
    float penetrationDepth;
    JPH_SubShapeID subShapeID1;
    JPH_SubShapeID subShapeID2;
    JPH_BodyID bodyID2;
    uint shape1FaceCount;
    JPH_Vec3* shape1Faces;
    uint shape2FaceCount;
    JPH_Vec3* shape2Faces;
}

struct JPH_ShapeCastResult
{
    JPH_Vec3 contactPointOn1;
    JPH_Vec3 contactPointOn2;
    JPH_Vec3 penetrationAxis;
    float penetrationDepth;
    JPH_SubShapeID subShapeID1;
    JPH_SubShapeID subShapeID2;
    JPH_BodyID bodyID2;
    float fraction;
    bool isBackFaceHit;
}

struct JPH_DrawSettings
{
    /// Draw the GetSupport() function, used for convex collision detection
    bool drawGetSupportFunction;
    
    /// When drawing the support function, also draw which direction mapped to a specific support point
    bool drawSupportDirection;
    
    /// Draw the faces that were found colliding during collision detection
    bool drawGetSupportingFace;
    
    /// Draw the shapes of all bodies
    bool drawShape;
    
    /// When mDrawShape is true and this is true, the shapes will be drawn in wireframe instead of solid.
    bool drawShapeWireframe;
    
    /// Coloring scheme to use for shapes
    JPH_BodyManager_ShapeColor drawShapeColor;
    
    /// Draw a bounding box per body
    bool drawBoundingBox;
    
    /// Draw the center of mass for each body
    bool drawCenterOfMassTransform;
    
    /// Draw the world transform (which may differ from its center of mass) of each body
    bool drawWorldTransform;
    
    /// Draw the velocity vector for each body
    bool drawVelocity;
    
    /// Draw the mass and inertia (as the box equivalent) for each body
    bool drawMassAndInertia;
    
    /// Draw stats regarding the sleeping algorithm of each body
    bool drawSleepStats;
    
    /// Draw the vertices of soft bodies
    bool drawSoftBodyVertices;
    
    /// Draw the velocities of the vertices of soft bodies
    bool drawSoftBodyVertexVelocities;
    
    /// Draw the edge constraints of soft bodies
    bool drawSoftBodyEdgeConstraints;
    
    /// Draw the bend constraints of soft bodies
    bool drawSoftBodyBendConstraints;
    
    /// Draw the volume constraints of soft bodies
    bool drawSoftBodyVolumeConstraints;
    
    /// Draw the skin constraints of soft bodies
    bool drawSoftBodySkinConstraints;
    
    /// Draw the LRA constraints of soft bodies
    bool drawSoftBodyLRAConstraints;
    
    /// Draw the predicted bounds of soft bodies
    bool drawSoftBodyPredictedBounds;
    
    /// Coloring scheme to use for soft body constraints
    JPH_SoftBodyConstraintColor drawSoftBodyConstraintColor;
}

struct JPH_SupportingFace
{
    uint count;
    JPH_Vec3[32] vertices;
}

struct JPH_CollisionGroup
{
    const(JPH_GroupFilter)* groupFilter;
    JPH_CollisionGroupID groupID;
    JPH_CollisionSubGroupID subGroupID;
}

extern(C)
{
    alias JPH_CastRayResultCallback = void function(void* context, const(JPH_RayCastResult)* result);
    alias JPH_RayCastBodyResultCallback = void function(void* context, const(JPH_BroadPhaseCastResult)* result);
    alias JPH_CollideShapeBodyResultCallback = void function(void* context, const(JPH_BodyID) result);
    alias JPH_CollidePointResultCallback = void function(void* context, const(JPH_CollidePointResult)* result);
    alias JPH_CollideShapeResultCallback = void function(void* context, const(JPH_CollideShapeResult)* result);
    alias JPH_CastShapeResultCallback = void function(void* context, const(JPH_ShapeCastResult)* result);
    
    alias JPH_CastRayCollectorCallback = float function(void* context, const(JPH_RayCastResult)* result);
    alias JPH_RayCastBodyCollectorCallback = float function(void* context, const(JPH_BroadPhaseCastResult)* result);
    alias JPH_CollideShapeBodyCollectorCallback = float function(void* context, const(JPH_BodyID) result);
    alias JPH_CollidePointCollectorCallback = float function(void* context, const(JPH_CollidePointResult)* result);
    alias JPH_CollideShapeCollectorCallback = float function(void* context, const(JPH_CollideShapeResult)* result);
    alias JPH_CastShapeCollectorCallback = float function(void* context, const(JPH_ShapeCastResult)* result);
}

struct JPH_CollisionEstimationResultImpulse
{
    float contactImpulse;
    float frictionImpulse1;
    float frictionImpulse2;
}

struct JPH_CollisionEstimationResult
{
    JPH_Vec3 linearVelocity1;
    JPH_Vec3 angularVelocity1;
    JPH_Vec3 linearVelocity2;
    JPH_Vec3 angularVelocity2;

    JPH_Vec3 tangent1;
    JPH_Vec3 tangent2;

    uint impulseCount;
    JPH_CollisionEstimationResultImpulse* impulses;
}

struct JPH_BodyActivationListener;
struct JPH_BodyDrawFilter;

struct JPH_SharedMutex;

struct JPH_DebugRenderer;

// Constraint
struct JPH_Constraint;
struct JPH_TwoBodyConstraint;
struct JPH_FixedConstraint;
struct JPH_DistanceConstraint;
struct JPH_PointConstraint;
struct JPH_HingeConstraint;
struct JPH_SliderConstraint;
struct JPH_ConeConstraint;
struct JPH_SwingTwistConstraint;
struct JPH_SixDOFConstraint;
struct JPH_GearConstraint;

// Character, CharacterVirtual
struct JPH_CharacterBase;
struct JPH_Character;
struct JPH_CharacterVirtual;
struct JPH_CharacterContactListener;
struct JPH_CharacterVsCharacterCollision;

// Skeleton/Ragdoll
struct JPH_Skeleton;
struct JPH_SkeletonPose;
struct JPH_SkeletalAnimation;
struct JPH_SkeletonMapper;
struct JPH_RagdollSettings;
struct JPH_Ragdoll;

struct JPH_ConstraintSettings
{
    bool enabled;
    uint constraintPriority;
    uint numVelocityStepsOverride;
    uint numPositionStepsOverride;
    float drawConstraintSize;
    ulong userData;
}

struct JPH_FixedConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    bool autoDetectPoint;
    JPH_RVec3 point1;
    JPH_Vec3 axisX1;
    JPH_Vec3 axisY1;
    JPH_RVec3 point2;
    JPH_Vec3 axisX2;
    JPH_Vec3 axisY2;
}

struct JPH_DistanceConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_RVec3 point1;
    JPH_RVec3 point2;
    float minDistance;
    float maxDistance;
    JPH_SpringSettings limitsSpringSettings;
}

struct JPH_PointConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_RVec3 point1;
    JPH_RVec3 point2;
}

struct JPH_HingeConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_RVec3 point1;
    JPH_Vec3 hingeAxis1;
    JPH_Vec3 normalAxis1;
    JPH_RVec3 point2;
    JPH_Vec3 hingeAxis2;
    JPH_Vec3 normalAxis2;
    float limitsMin;
    float limitsMax;
    JPH_SpringSettings limitsSpringSettings;
    float maxFrictionTorque;
    JPH_MotorSettings motorSettings;
}

struct JPH_SliderConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    bool autoDetectPoint;
    JPH_RVec3 point1;
    JPH_Vec3 sliderAxis1;
    JPH_Vec3 normalAxis1;
    JPH_RVec3 point2;
    JPH_Vec3 sliderAxis2;
    JPH_Vec3 normalAxis2;
    float limitsMin;
    float limitsMax;
    JPH_SpringSettings limitsSpringSettings;
    float maxFrictionForce;
    JPH_MotorSettings motorSettings;
}

struct JPH_ConeConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_RVec3 point1;
    JPH_Vec3 twistAxis1;
    JPH_RVec3 point2;
    JPH_Vec3 twistAxis2;
    float halfConeAngle;
}

struct JPH_SwingTwistConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_RVec3 position1;
    JPH_Vec3 twistAxis1;
    JPH_Vec3 planeAxis1;
    JPH_RVec3 position2;
    JPH_Vec3 twistAxis2;
    JPH_Vec3 planeAxis2;
    JPH_SwingType swingType;
    float normalHalfConeAngle;
    float planeHalfConeAngle;
    float twistMinAngle;
    float twistMaxAngle;
    float maxFrictionTorque;
    JPH_MotorSettings swingMotorSettings;
    JPH_MotorSettings twistMotorSettings;
}

struct JPH_SixDOFConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_RVec3 position1;
    JPH_Vec3 axisX1;
    JPH_Vec3 axisY1;
    JPH_RVec3 position2;
    JPH_Vec3 axisX2;
    JPH_Vec3 axisY2;
    float[JPH_SixDOFConstraintAxis.Num] maxFriction;
    JPH_SwingType swingType;
    float[JPH_SixDOFConstraintAxis.Num] limitMin;
    float[JPH_SixDOFConstraintAxis.Num] limitMax;
    JPH_SpringSettings[JPH_SixDOFConstraintAxis.NumTranslation] limitsSpringSettings;
    JPH_MotorSettings[JPH_SixDOFConstraintAxis.Num] motorSettings;
}

struct JPH_GearConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_ConstraintSpace space;
    JPH_Vec3 hingeAxis1;
    JPH_Vec3 hingeAxis2;
    float ratio;
}

struct JPH_BodyLockRead
{
    const(JPH_BodyLockInterface)* lockInterface;
    JPH_SharedMutex* mutex;
    const(JPH_Body)* body;
}

struct JPH_BodyLockWrite
{
    const(JPH_BodyLockInterface)* lockInterface;
    JPH_SharedMutex* mutex;
    JPH_Body* body;
}

struct JPH_BodyLockMultiRead;
struct JPH_BodyLockMultiWrite;

struct JPH_ExtendedUpdateSettings
{
    JPH_Vec3 stickToFloorStepDown;
    JPH_Vec3 walkStairsStepUp;
    float walkStairsMinStepForward;
    float walkStairsStepForwardTest;
    float walkStairsCosAngleForwardContact;
    JPH_Vec3 walkStairsStepDownExtra;
}

struct JPH_CharacterBaseSettings
{
    JPH_Vec3 up;
    JPH_Plane supportingVolume;
    float maxSlopeAngle;
    bool enhancedInternalEdgeRemoval;
    const(JPH_Shape)* shape;
}

struct JPH_CharacterSettings
{
    JPH_CharacterBaseSettings base;
    JPH_ObjectLayer layer;
    float mass;
    float friction;
    float gravityFactor;
    JPH_AllowedDOFs allowedDOFs;
}

struct JPH_CharacterVirtualSettings
{
    JPH_CharacterBaseSettings base;
    JPH_CharacterID ID;
    float mass;
    float maxStrength;
    JPH_Vec3 shapeOffset;
    JPH_BackFaceMode backFaceMode;
    float predictiveContactDistance;
    uint maxCollisionIterations;
    uint maxConstraintIterations;
    float minTimeRemaining;
    float collisionTolerance;
    float characterPadding;
    uint maxNumHits;
    float hitReductionCosMaxAngle;
    float penetrationRecoverySpeed;
    const(JPH_Shape)* innerBodyShape;
    JPH_BodyID innerBodyIDOverride;
    JPH_ObjectLayer innerBodyLayer;
}

struct JPH_CharacterContactSettings
{
    bool canPushCharacter;
    bool canReceiveImpulses;
}

struct JPH_CharacterVirtualContact
{
    ulong hash;
    JPH_BodyID bodyB;
    JPH_CharacterID characterIDB;
    JPH_SubShapeID subShapeIDB;
    JPH_RVec3 position;
    JPH_Vec3 linearVelocity;
    JPH_Vec3 contactNormal;
    JPH_Vec3 surfaceNormal;
    float distance;
    float fraction;
    JPH_MotionType motionTypeB;
    bool isSensorB;
    const(JPH_CharacterVirtual)* characterB;
    ulong userData;
    const(JPH_PhysicsMaterial)* material;
    bool hadCollision;
    bool wasDiscarded;
    bool canPushCharacter;
}

extern(C)
{
    alias JPH_TraceFunc = void function(const(char)* message);
    alias JPH_AssertFailureFunc = bool function(const(char)* expression, const(char)* message, const(char)* file, uint line);

    alias JPH_JobFunction = void function(void* arg);
    alias JPH_QueueJobCallback = void function(void* context, JPH_JobFunction* job, void* arg);
    alias JPH_QueueJobsCallback = void function(void* context, JPH_JobFunction* job, void** args, uint count);
}

struct JobSystemThreadPoolConfig
{
    uint maxJobs;
    uint maxBarriers;
    int numThreads;
}

struct JPH_JobSystemConfig
{
    void* context;
    JPH_QueueJobCallback* queueJob;
    JPH_QueueJobsCallback* queueJobs;
    uint maxConcurrency;
    uint maxBarriers;
}

struct JPH_JobSystem;

extern(C)
{
    /**
     * Calculate max tire impulses by combining friction, slip, and suspension impulse.
     * Note that the actual applied impulse may be lower (e.g. when the vehicle is stationary 
     * on a horizontal surface the actual impulse applied will be 0)
     */
    alias JPH_TireMaxImpulseCallback = void function(
        void* userData,
        uint wheelIndex, 
        float* outLongitudinalImpulse,
        float* outLateralImpulse, 
        float suspensionImpulse,
        float longitudinalFriction,
        float lateralFriction,
        float longitudinalSlip,
        float lateralSlip,
        float deltaTime);
}

struct JPH_PhysicsSystemSettings
{
    uint maxBodies = 10240;
    uint numBodyMutexes = 0;
    uint maxBodyPairs = 65536;
    uint maxContactConstraints = 10240;
    uint _padding;
    JPH_BroadPhaseLayerInterface* broadPhaseLayerInterface;
    JPH_ObjectLayerPairFilter* objectLayerPairFilter;
    JPH_ObjectVsBroadPhaseLayerFilter* objectVsBroadPhaseLayerFilter;
}

struct JPH_PhysicsSettings
{
    int maxInFlightBodyPairs;
    int stepListenersBatchSize;
    int stepListenerBatchesPerJob;
    float baumgarte;
    float speculativeContactDistance;
    float penetrationSlop;
    float linearCastThreshold;
    float linearCastMaxPenetration;
    float manifoldTolerance;
    float maxPenetrationDistance;
    float bodyPairCacheMaxDeltaPositionSq;
    float bodyPairCacheCosMaxDeltaRotationDiv2;
    float contactNormalCosMaxDeltaRotation;
    float contactPointPreserveLambdaMaxDistSq;
    uint numVelocitySteps;
    uint numPositionSteps;
    float minVelocityForRestitution;
    float timeBeforeSleep;
    float pointVelocitySleepThreshold;
    bool deterministicSimulation;
    bool constraintWarmStart;
    bool useBodyPairContactCache;
    bool useManifoldReduction;
    bool useLargeIslandSplitter;
    bool allowSleeping;
    bool checkActiveEdges;
}

struct JPH_PhysicsStepListenerContext
{
    float deltaTime;
    JPH_Bool isFirstStep;
    JPH_Bool isLastStep;
    JPH_PhysicsSystem* physicsSystem;
}

struct JPH_PhysicsStepListener_Procs
{
    extern(C) void function(void* userData, const(JPH_PhysicsStepListenerContext)* context) OnStep;
}

struct JPH_BroadPhaseLayerFilter_Procs
{
    extern(C) bool function(void* userData, JPH_BroadPhaseLayer layer) ShouldCollide;
}

struct JPH_ObjectLayerFilter_Procs
{
    extern(C) bool function(void* userData, JPH_ObjectLayer layer) ShouldCollide;
}

struct JPH_BodyFilter_Procs
{
    extern(C) bool function(void* userData, JPH_BodyID bodyID) ShouldCollide;
    extern(C) bool function(void* userData, const(JPH_Body)* bodyID) ShouldCollideLocked;
}

struct JPH_ShapeFilter_Procs
{
    extern(C) bool function(
        void* userData,
        const(JPH_Shape)* shape2,
        const(JPH_SubShapeID)* subShapeIDOfShape2) ShouldCollide;
    extern(C) bool function(
        void* userData,
        const(JPH_Shape)* shape1,
        const(JPH_SubShapeID)* subShapeIDOfShape1,
        const(JPH_Shape)* shape2,
        const(JPH_SubShapeID)* subShapeIDOfShape2) ShouldCollide2;
}

struct JPH_SimShapeFilter_Procs
{
    extern(C) bool function(
        void* userData,
        const(JPH_Body)* body1,
        const(JPH_Shape)* shape1,
        const(JPH_SubShapeID)* subShapeIDOfShape1,
        const(JPH_Body)* body2,
        const(JPH_Shape)* shape2,
        const(JPH_SubShapeID)* subShapeIDOfShape2) ShouldCollide;
}

struct JPH_ContactListener_Procs
{
    extern(C) JPH_ValidateResult function(
        void* userData,
        const(JPH_Body)* body1,
        const(JPH_Body)* body2,
        const(JPH_RVec3)* baseOffset,
        const(JPH_CollideShapeResult)* collisionResult) OnContactValidate;

    extern(C) void function(
        void* userData,
        const(JPH_Body)* body1,
        const(JPH_Body)* body2,
        const(JPH_ContactManifold)* manifold,
        JPH_ContactSettings* settings) OnContactAdded;

    extern(C) void function(
        void* userData,
        const(JPH_Body)* body1,
        const(JPH_Body)* body2,
        const(JPH_ContactManifold)* manifold,
        JPH_ContactSettings* settings) OnContactPersisted;

    extern(C) void function(
        void* userData,
        const(JPH_SubShapeIDPair)* subShapePair) OnContactRemoved;
}

struct JPH_BodyActivationListener_Procs
{
    extern(C) void function(
        void* userData,
        JPH_BodyID bodyID,
        ulong bodyUserData) OnBodyActivated;
    extern(C) void function(
        void* userData,
        JPH_BodyID bodyID,
        ulong bodyUserData) OnBodyDeactivated;
}

struct JPH_BodyDrawFilter_Procs
{
    extern(C) bool function(
        void* userData,
        const(JPH_Body)* body) ShouldDraw;
}

struct JPH_CharacterContactListener_Procs
{
    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_Body)* body2,
        JPH_Vec3* ioLinearVelocity,
        JPH_Vec3* ioAngularVelocity) OnAdjustBodyVelocity;

    extern(C) bool function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_BodyID) bodyID2,
        const(JPH_SubShapeID) subShapeID2) OnContactValidate;

    extern(C) bool function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_CharacterVirtual)* otherCharacter,
        const(JPH_SubShapeID) subShapeID2) OnCharacterContactValidate;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_BodyID) bodyID2,
        const(JPH_SubShapeID) subShapeID2,
        const(JPH_RVec3)* contactPosition,
        const(JPH_Vec3)* contactNormal,
        JPH_CharacterContactSettings* ioSettings) OnContactAdded;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_BodyID) bodyID2,
        const(JPH_SubShapeID) subShapeID2,
        const(JPH_RVec3)* contactPosition,
        const(JPH_Vec3)* contactNormal,
        JPH_CharacterContactSettings* ioSettings) OnContactPersisted;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_BodyID) bodyID2,
        const(JPH_SubShapeID) subShapeID2) OnContactRemoved;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_CharacterVirtual)* otherCharacter,
        const(JPH_SubShapeID) subShapeID2,
        const(JPH_RVec3)* contactPosition,
        const(JPH_Vec3)* contactNormal,
        JPH_CharacterContactSettings* ioSettings) OnCharacterContactAdded;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_CharacterVirtual)* otherCharacter,
        const(JPH_SubShapeID) subShapeID2,
        const(JPH_RVec3)* contactPosition,
        const(JPH_Vec3)* contactNormal,
        JPH_CharacterContactSettings* ioSettings) OnCharacterContactPersisted;
    
    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_CharacterID) otherCharacterID,
        const(JPH_SubShapeID) subShapeID2) OnCharacterContactRemoved;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_BodyID) bodyID2,
        const(JPH_SubShapeID) subShapeID2,
        const(JPH_RVec3)* contactPosition,
        const(JPH_Vec3)* contactNormal,
        const(JPH_Vec3)* contactVelocity,
        const(JPH_PhysicsMaterial)* contactMaterial,
        const(JPH_Vec3)* characterVelocity,
        JPH_Vec3* newCharacterVelocity) OnContactSolve;

    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_CharacterVirtual)* otherCharacter,
        const(JPH_SubShapeID) subShapeID2,
        const(JPH_RVec3)* contactPosition,
        const(JPH_Vec3)* contactNormal,
        const(JPH_Vec3)* contactVelocity,
        const(JPH_PhysicsMaterial)* contactMaterial,
        const(JPH_Vec3)* characterVelocity,
        JPH_Vec3* newCharacterVelocity) OnCharacterContactSolve;
}

struct JPH_CharacterVsCharacterCollision_Procs
{
    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_RMat4)* centerOfMassTransform,
        const(JPH_CollideShapeSettings)* collideShapeSettings,
        const(JPH_RVec3)* baseOffset) CollideCharacter;
    
    extern(C) void function(
        void* userData,
        const(JPH_CharacterVirtual)* character,
        const(JPH_RMat4)* centerOfMassTransform,
        const(JPH_Vec3)* direction,
        const(JPH_ShapeCastSettings)* shapeCastSettings,
        const(JPH_RVec3)* baseOffset) CastCharacter;
}

struct JPH_DebugRenderer_Procs
{
    extern(C) void function(
        void* userData,
        const(JPH_RVec3)* pointFrom,
        const(JPH_RVec3)* pointTo,
        JPH_Color color) DrawLine;
    
    extern(C) void function(
        void* userData,
        const(JPH_RVec3)* v1,
        const(JPH_RVec3)* v2,
        const(JPH_RVec3)* v3,
        JPH_Color color,
        JPH_DebugRenderer_CastShadow castShadow) DrawTriangle;
    
    extern(C) void function(
        void* userData,
        const(JPH_RVec3)* position,
        const(char)* str,
        JPH_Color color,
        float height) DrawText3D;
}

struct JPH_SkeletonJoint
{
    const(char)* name;
    const(char)* parentName;
    int parentJointIndex;
}

struct JPH_WheelSettings;
struct JPH_WheelSettingsWV;
struct JPH_WheelSettingsTV;

struct JPH_Wheel;
struct JPH_WheelWV;
struct JPH_WheelTV;

struct JPH_VehicleEngine;
struct JPH_VehicleTransmission;
struct JPH_VehicleTransmissionSettings;
struct JPH_VehicleCollisionTester;
struct JPH_VehicleCollisionTesterRay;
struct JPH_VehicleCollisionTesterCastSphere;
struct JPH_VehicleCollisionTesterCastCylinder;
struct JPH_VehicleConstraint;

struct JPH_VehicleControllerSettings;
struct JPH_WheeledVehicleControllerSettings;
struct JPH_MotorcycleControllerSettings;
struct JPH_TrackedVehicleControllerSettings;

struct JPH_WheeledVehicleController;
struct JPH_MotorcycleController;
struct JPH_TrackedVehicleController;

struct JPH_VehicleController;

struct JPH_VehicleAntiRollBar
{
    int leftWheel;
    int rightWheel;
    float stiffness;
}

struct JPH_VehicleConstraintSettings
{
    JPH_ConstraintSettings base;
    JPH_Vec3 up;
    JPH_Vec3 forward;
    float maxPitchRollAngle;
    uint wheelsCount;
    JPH_WheelSettings** wheels;
    uint antiRollBarsCount;
    const(JPH_VehicleAntiRollBar)* antiRollBars;
    JPH_VehicleControllerSettings* controller;
}

struct JPH_VehicleEngineSettings
{
    float maxTorque;
    float minRPM;
    float maxRPM;
    const(JPH_LinearCurve)* normalizedTorque;
    float inertia;
    float angularDamping;
}

struct JPH_VehicleDifferentialSettings
{
    int leftWheel;
    int rightWheel;
    float differentialRatio;
    float leftRightSplit;
    float limitedSlipRatio;
    float engineTorqueRatio;
}

struct JPH_VehicleTrack;

enum JPH_TrackSide
{
    Left = 0,
    Right = 1
}

struct JPH_VehicleTrackSettings
{
    uint drivenWheel;
    const(uint)* wheels;
    uint wheelsCount;
    float inertia;
    float angularDamping;
    float maxBrakeTorque;
    float differentialRatio;
}
