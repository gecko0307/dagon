/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module bindbc.newton.types;

private {
    import core.stdc.config;
}

extern(C):

alias dLong = long;
alias dFloat32 = float;
alias dFloat64 = double;
version(_NEWTON_USE_DOUBLE) alias dFloat = double;
else alias dFloat = float;

enum NEWTON_MAJOR_VERSION = 3;
enum NEWTON_MINOR_VERSION = 14;

enum NEWTON_BROADPHASE_DEFAULT = 0;
enum NEWTON_BROADPHASE_PERSINTENT = 1;

enum NEWTON_DYNAMIC_BODY = 0;
enum NEWTON_KINEMATIC_BODY = 1;
enum NEWTON_DYNAMIC_ASYMETRIC_BODY = 2;
// enum NEWTON_DEFORMABLE_BODY = 2;

enum SERIALIZE_ID_SPHERE = 0;
enum SERIALIZE_ID_CAPSULE = 1;
enum SERIALIZE_ID_CYLINDER = 2;
enum SERIALIZE_ID_CHAMFERCYLINDER = 3;
enum SERIALIZE_ID_BOX = 4;
enum SERIALIZE_ID_CONE = 5;
enum SERIALIZE_ID_CONVEXHULL = 6;
enum SERIALIZE_ID_NULL = 7;
enum SERIALIZE_ID_COMPOUND = 8;
enum SERIALIZE_ID_TREE = 9;
enum SERIALIZE_ID_HEIGHTFIELD = 10;
enum SERIALIZE_ID_CLOTH_PATCH = 11;
enum SERIALIZE_ID_DEFORMABLE_SOLID = 12;
enum SERIALIZE_ID_USERMESH = 13;
enum SERIALIZE_ID_SCENE = 14;
enum SERIALIZE_ID_FRACTURED_COMPOUND = 15;

struct NewtonMesh {}
struct NewtonBody {}
struct NewtonWorld {}
struct NewtonJoint {}
struct NewtonMaterial {}
struct NewtonCollision {}
struct NewtonDeformableMeshSegment {}
struct NewtonFracturedCompoundMeshPart {}

union NewtonMaterialData
{
    void* m_ptr;
    dLong m_int;
    dFloat m_float;
}

struct NewtonCollisionMaterial
{
    dLong m_userId;
    NewtonMaterialData m_userData;
    NewtonMaterialData[6] m_userParam;
}

struct NewtonBoxParam
{
    dFloat m_x;
    dFloat m_y;
    dFloat m_z;
}

struct NewtonSphereParam
{
    dFloat m_radio;
}

struct NewtonCapsuleParam
{
    dFloat m_radio0;
    dFloat m_radio1;
    dFloat m_height;
}

struct NewtonCylinderParam
{
    dFloat m_radio0;
    dFloat m_radio1;
    dFloat m_height;
}

struct NewtonConeParam
{
    dFloat m_radio;
    dFloat m_height;
}

struct NewtonChamferCylinderParam
{
    dFloat m_radio;
    dFloat m_height;
}

struct NewtonConvexHullParam
{
    int m_vertexCount;
    int m_vertexStrideInBytes;
    int m_faceCount;
    dFloat* m_vertex;
}

struct NewtonCompoundCollisionParam
{
    int m_chidrenCount;
}

struct NewtonCollisionTreeParam
{
    int m_vertexCount;
    int m_indexCount;
}

struct NewtonDeformableMeshParam
{
    int m_vertexCount;
    int m_triangleCount;
    int m_vrtexStrideInBytes;
    ushort* m_indexList;
    dFloat* m_vertexList;
}

struct NewtonHeightFieldCollisionParam
{
    int m_width;
    int m_height;
    int m_gridsDiagonals;
    int m_elevationDataType; // 0 = 32 bit floats, 1 = unsigned 16 bit integers
    dFloat m_verticalScale;
    dFloat m_horizonalScale_x;
    dFloat m_horizonalScale_z;
    void* m_vertialElevation;
    char* m_atributes;
}

struct NewtonSceneCollisionParam
{
    int m_childrenProxyCount;
}

struct NewtonCollisionInfoRecord
{
    dFloat[4][4] m_offsetMatrix;
    NewtonCollisionMaterial m_collisionMaterial;
    int m_collisionType; // tag id to identify the collision primitive

    union
    {
        NewtonBoxParam m_box;
        NewtonConeParam m_cone;
        NewtonSphereParam m_sphere;
        NewtonCapsuleParam m_capsule;
        NewtonCylinderParam m_cylinder;
        NewtonChamferCylinderParam m_chamferCylinder;
        NewtonConvexHullParam m_convexHull;
        NewtonDeformableMeshParam m_deformableMesh;
        NewtonCompoundCollisionParam m_compoundCollision;
        NewtonCollisionTreeParam m_collisionTree;
        NewtonHeightFieldCollisionParam m_heightField;
        NewtonSceneCollisionParam m_sceneCollision;
        dFloat[64] m_paramArray; // user define collision can use this to store information
    }
}

struct NewtonJointRecord
{
    dFloat[4][4] m_attachmenMatrix_0;
    dFloat[4][4] m_attachmenMatrix_1;
    dFloat[3] m_minLinearDof;
    dFloat[3] m_maxLinearDof;
    dFloat[3] m_minAngularDof;
    dFloat[3] m_maxAngularDof;
    const(NewtonBody)* m_attachBody_0;
    const(NewtonBody)* m_attachBody_1;
    dFloat[64] m_extraParameters;
    int m_bodiesCollisionOn;
    char[128] m_descriptionType;
}

struct NewtonUserMeshCollisionCollideDesc
{
    dFloat[4] m_boxP0; // lower bounding box of intersection query in local space
    dFloat[4] m_boxP1; // upper bounding box of intersection query in local space
    dFloat[4] m_boxDistanceTravel; // max distance that box bpxP0 and boxP1 can travel on this timestep, used this for continue collision mode.
    int m_threadNumber; // current thread executing this query
    int m_faceCount; // the application should set here how many polygons intersect the query box
    int m_vertexStrideInBytes; // the application should set here the size of each vertex
    dFloat m_skinThickness; // this is the minimum skin separation specified by the material between these two colliding shapes
    void* m_userData; // user data passed to the collision geometry at creation time

    NewtonBody* m_objBody; // pointer to the colliding body
    NewtonBody* m_polySoupBody; // pointer to the rigid body owner of this collision tree 
    NewtonCollision* m_objCollision; // collision shape of the colliding body, (no necessarily the collision of m_objBody)
    NewtonCollision* m_polySoupCollision; // collision shape of the collision tree, (no necessarily the collision of m_polySoupBody)

    dFloat* m_vertex; // the application should set here the pointer to the global vertex of the mesh. 
    int* m_faceIndexCount; // the application should set here the pointer to the vertex count of each face.
    int* m_faceVertexIndex; // the application should set here the pointer index array for each vertex on a face.
    // the format of a face is I0, I1, I2, I3, ..., M, N, E0, E1, E2, ..., A
    // I0, I1, I2, .. are the indices to the vertex, relative to m_vertex pointer
    // M is the index to the material sub shape id
    // N in the index to the vertex normal relative to m_vertex pointer
    // E0, E1, E2, ... are the indices of the the face normal that is shared to that face edge, when the edge does not share a face normal then the edge index is set to index N, which the index to the face normal    
    // A is and estimate of the largest diagonal of the face, this used internally as a hint to improve floating point accuracy and algorithm performance. 
}

struct NewtonWorldConvexCastReturnInfo
{
    dFloat[4] m_point; // collision point in global space
    dFloat[4] m_normal; // surface normal at collision point in global space
    //dFloat m_normalOnHitPoint[4];           // surface normal at the surface of the hit body, 
    // is the same as the normal calculated by a ray cast hitting the body at the hit point
    dLong m_contactID; // collision ID at contact point
    const(NewtonBody)* m_hitBody; // body hit at contact point
    dFloat m_penetration; // contact penetration at collision point
}

struct NewtonUserMeshCollisionRayHitDesc
{
    dFloat[4] m_p0; // ray origin in collision local space
    dFloat[4] m_p1; // ray destination in collision local space   
    dFloat[4] m_normalOut; // copy here the normal at the ray intersection
    dLong m_userIdOut; // copy here a user defined id for further feedback  
    void* m_userData; // user data passed to the collision geometry at creation time
}

struct NewtonHingeSliderUpdateDesc
{
    dFloat m_accel;
    dFloat m_minFriction;
    dFloat m_maxFriction;
    dFloat m_timestep;
}

struct NewtonUserContactPoint
{
    dFloat[4] m_point;
    dFloat[4] m_normal;
    dLong m_shapeId0;
    dLong m_shapeId1;
    dFloat m_penetration;
    int[3] m_unused;
}

struct NewtonImmediateModeConstraint
{
    dFloat[8][6] m_jacobian01;
    dFloat[8][6] m_jacobian10;
    dFloat[8] m_minFriction;
    dFloat[8] m_maxFriction;
    dFloat[8] m_jointAccel;
    dFloat[8] m_jointStiffness;
}

// data structure for interfacing with NewtonMesh
struct NewtonMeshDoubleData
{
    dFloat64* m_data;
    int* m_indexList;
    int m_strideInBytes;
}

struct NewtonMeshFloatData
{
    dFloat* m_data;
    int* m_indexList;
    int m_strideInBytes;
}

struct NewtonMeshVertexFormat
{
    int m_faceCount;
    int* m_faceIndexCount;
    int* m_faceMaterial;
    NewtonMeshDoubleData m_vertex;
    NewtonMeshFloatData m_normal;
    NewtonMeshFloatData m_binormal;
    NewtonMeshFloatData m_uv0;
    NewtonMeshFloatData m_uv1;
    NewtonMeshFloatData m_vertexColor;
}

// Newton callback functions
alias NewtonAllocMemory = void* function (int sizeInBytes);
alias NewtonFreeMemory = void function (void* ptr, int sizeInBytes);

alias NewtonWorldDestructorCallback = void function (const NewtonWorld* world);
alias NewtonPostUpdateCallback = void function (const NewtonWorld* world, dFloat timestep);

alias NewtonCreateContactCallback = void function(const NewtonWorld*  newtonWorld, NewtonJoint* contact);
alias NewtonDestroyContactCallback = void function(const NewtonWorld*  newtonWorld, NewtonJoint* contact);

alias NewtonWorldListenerDebugCallback = void function (const NewtonWorld* world, void* listener, void* debugContext);
alias NewtonWorldListenerBodyDestroyCallback = void function (const NewtonWorld* world, void* listenerUserData, NewtonBody* body_);
alias NewtonWorldUpdateListenerCallback = void function (const NewtonWorld* world, void* listenerUserData, dFloat timestep);
alias NewtonWorldDestroyListenerCallback = void function (const NewtonWorld* world, void* listenerUserData);

alias NewtonGetTimeInMicrosencondsCallback = dLong function ();

alias NewtonSerializeCallback = void function (void* serializeHandle, const void* buffer, int size);
alias NewtonDeserializeCallback = void function (void* serializeHandle, void* buffer, int size);

alias NewtonOnBodySerializationCallback = void function (NewtonBody* body_, void* userData, NewtonSerializeCallback function_, void* serializeHandle);
alias NewtonOnBodyDeserializationCallback = void function (NewtonBody* body_, void* userData, NewtonDeserializeCallback function_, void* serializeHandle);

alias NewtonOnJointSerializationCallback = void function (const NewtonJoint* joint, NewtonSerializeCallback function_, void* serializeHandle);
alias NewtonOnJointDeserializationCallback = void function (NewtonBody* body0, NewtonBody* body1, NewtonDeserializeCallback function_, void* serializeHandle);

alias NewtonOnUserCollisionSerializationCallback = void function (void* userData, NewtonSerializeCallback function_, void* serializeHandle);

// user collision callbacks    
alias NewtonUserMeshCollisionDestroyCallback = void function (void* userData);
alias NewtonUserMeshCollisionRayHitCallback = dFloat function (NewtonUserMeshCollisionRayHitDesc* lineDescData);
alias NewtonUserMeshCollisionGetCollisionInfo = void function (void* userData, NewtonCollisionInfoRecord* infoRecord);
alias NewtonUserMeshCollisionAABBTest = int function (void* userData, const dFloat* boxP0, const dFloat* boxP1);
alias NewtonUserMeshCollisionGetFacesInAABB = int function (
    void* userData,
    const dFloat* p0,
    const dFloat* p1,
    const dFloat** vertexArray,
    int* vertexCount,
    int* vertexStrideInBytes,
    const int* indexList,
    int maxIndexCount,
    const int* userDataList);
alias NewtonUserMeshCollisionCollideCallback = void function (NewtonUserMeshCollisionCollideDesc* collideDescData, const void* continueCollisionHandle);

alias NewtonTreeCollisionFaceCallback = int function (void* context, const dFloat* polygon, int strideInBytes, const int* indexArray, int indexCount);

alias NewtonCollisionTreeRayCastCallback = dFloat function (const NewtonBody* body_, const NewtonCollision* treeCollision, dFloat intersection, dFloat* normal, int faceId, void* usedData);
alias NewtonHeightFieldRayCastCallback = dFloat function (const NewtonBody* body_, const NewtonCollision* heightFieldCollision, dFloat intersection, int row, int col, dFloat* normal, int faceId, void* usedData);

alias NewtonCollisionCopyConstructionCallback = void function (const NewtonWorld* newtonWorld, NewtonCollision* collision, const NewtonCollision* sourceCollision);
alias NewtonCollisionDestructorCallback = void function (const NewtonWorld* newtonWorld, const NewtonCollision* collision);

// collision tree call back (obsoleted no recommended)
alias NewtonTreeCollisionCallback = void function (
    const NewtonBody* bodyWithTreeCollision,
    const NewtonBody* body_,
    int faceID,
    int vertexCount,
    const dFloat* vertex,
    int vertexStrideInBytes);

alias NewtonBodyDestructor = void function (const NewtonBody* body_);
alias NewtonApplyForceAndTorque = void function (const NewtonBody* body_, dFloat timestep, int threadIndex);
alias NewtonSetTransform = void function (const NewtonBody* body_, const dFloat* matrix, int threadIndex);

alias NewtonIslandUpdate = int function (const NewtonWorld* newtonWorld, const(void)* islandHandle, int bodyCount);

alias NewtonFractureCompoundCollisionOnEmitCompoundFractured = void function (NewtonBody* fracturedBody);
alias NewtonFractureCompoundCollisionOnEmitChunk = void function (NewtonBody* chunkBody, NewtonFracturedCompoundMeshPart* fracturexChunkMesh, const NewtonCollision* fracturedCompountCollision);
alias NewtonFractureCompoundCollisionReconstructMainMeshCallBack = void function (NewtonBody* body_, NewtonFracturedCompoundMeshPart* mainMesh, const NewtonCollision* fracturedCompountCollision);

alias NewtonWorldRayPrefilterCallback = uint function (const NewtonBody* body_, const NewtonCollision* collision, void* userData);
alias NewtonWorldRayFilterCallback = dFloat function (const NewtonBody* body_, const NewtonCollision* shapeHit, const dFloat* hitContact, const dFloat* hitNormal, long collisionID, void* userData, dFloat intersectParam);

alias NewtonOnAABBOverlap = int function (const NewtonJoint* contact, dFloat timestep, int threadIndex);
alias NewtonContactsProcess = void function (const NewtonJoint* contact, dFloat timestep, int threadIndex);
alias NewtonOnCompoundSubCollisionAABBOverlap = int function (const NewtonJoint* contact, dFloat timestep, const NewtonBody* body0, const void* collisionNode0, const NewtonBody* body1, const void* collisionNode1, int threadIndex);
alias NewtonOnContactGeneration = int function (const NewtonMaterial* material, const NewtonBody* body0, const NewtonCollision* collision0, const NewtonBody* body1, const NewtonCollision* collision1, NewtonUserContactPoint* contactBuffer, int maxCount, int threadIndex);

alias NewtonBodyIterator = int function (const NewtonBody* body_, void* userData);
alias NewtonJointIterator = void function (const NewtonJoint* joint, void* userData);
alias NewtonCollisionIterator = void function (void* userData, int vertexCount, const dFloat* faceArray, int faceId);

alias NewtonBallCallback = void function (const NewtonJoint* ball, dFloat timestep);
alias NewtonHingeCallback = uint function (const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc);
alias NewtonSliderCallback = uint function (const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc);
alias NewtonUniversalCallback = uint function (const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc);
alias NewtonCorkscrewCallback = uint function (const NewtonJoint* corkscrew, NewtonHingeSliderUpdateDesc* desc);

alias NewtonUserBilateralCallback = void function (const NewtonJoint* userJoint, dFloat timestep, int threadIndex);
alias NewtonUserBilateralGetInfoCallback = void function (const NewtonJoint* userJoint, NewtonJointRecord* info);

alias NewtonConstraintDestructor = void function (const NewtonJoint* me);

alias NewtonJobTask = void function (NewtonWorld* world, void* userData, int threadIndex);
alias NewtonReportProgress = int function (dFloat normalizedProgressPercent, void* userData);
