/*
Copyright (c) 2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module dagon.ext.audio.audiomanager;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.math.vector;
import dlib.text.str;

import dagon.core.logger;
import dagon.core.application;
import dagon.core.event;
import dagon.core.time;
import dagon.core.config;
import dagon.graphics.entity;

import bindbc.soloud;
import soloud;

import dagon.ext.audio.soundcomponent;

enum AttenuationModel
{
    NoAttenuation = 0,
    InverseDistance = 1,
    LinearDistance = 2,
    ExponentialDistance = 3
};

enum SoundClass: uint
{
    SFX = 0,
    Music = 1
}

struct SoundClassOptions
{
    float volume;
    bool enabled;
}

class AudioManager: Owner
{
    Application application;
    Configuration config;
    EventManager eventManager;
    
    SLSupport loadedSLSupport;
    bool soloudPresent = true;
    uint soloudVersion;
    
    bool enabled = true;
    
    Soloud audio;
    uint backendId;
    String backend;
    uint channels;
    uint sampleRate;
    uint bufferSize;
    
    float masterVolume = 1.0f;
    float masterVolumeCoef = 0.0f; // start with zero, gradually increment to 1.0f
    float masterFadeInDuration = 0.25f; // in seconds
    SoundClassOptions[32] options;
    
    Entity listener;
    
    this(Application application)
    {
        super(application);
        
        this.application = application;
        this.config = application.config;
        this.eventManager = application.eventManager;
        
        loadedSLSupport = loadSoloud();
        
        if (loadedSLSupport != slSupport)
        {
            if (loadedSLSupport == SLSupport.badLibrary)
            {
                logWarning("Failed to load some SoLoud functions. It seems that you have an old version of SoLoud. Dagon will try to use it, but it is recommended to install SoLoud 20200207 or higher");
            }
            else
            {
                logError("SoLoud library is not found. Please, install SoLoud 20200207");
                soloudPresent = false;
            }
        }
        
        enabled = soloudPresent;
        
        if (!soloudPresent)
            return;
        
        audio = Soloud.create();
        
        soloudVersion = audio.getVersion();
        logInfo("SoLoud version: ", soloudVersion);
        
        audio.init(Soloud.CLIP_ROUNDOFF | Soloud.LEFT_HANDED_3D, Soloud.AUTO, Soloud.AUTO, Soloud.AUTO, 2);
        audio.setGlobalVolume(0.0f);
        
        backendId = audio.getBackendId();
        const(char)* backendStr = audio.getBackendString();
        backend = String(backendStr);
        logInfo("Audio backend: ", backend);
        
        channels = audio.getBackendChannels();
        sampleRate = audio.getBackendSamplerate();
        bufferSize = audio.getBackendBufferSize();
        logInfo("Audio channels: ", channels);
        logInfo("Audio sample rate: ", sampleRate);
        logInfo("Audio buffer size: ", bufferSize);
        
        // Set options
        foreach(ref opt; options)
            opt = SoundClassOptions(0.5f, true);
        
        if ("audio.enabled" in config.props)
            enabled = soloudPresent && cast(bool)config.props["audio.enabled"].toUInt;
        
        if ("audio.masterVolume" in config.props)
            masterVolume = config.props["audio.masterVolume"].toFloat;
        
        if ("audio.masterFadeInDuration" in config.props)
            masterFadeInDuration = config.props["audio.masterFadeInDuration"].toFloat;
        
        float sfxVolume = 0.5f;
        bool sfxEnabled = true;
        if ("audio.sfxVolume" in config.props)
            sfxVolume = config.props["audio.sfxVolume"].toFloat;
        if ("audio.sfxEnabled" in config.props)
            sfxEnabled = cast(bool)config.props["audio.sfxEnabled"].toUInt;
        
        float musicVolume = 0.5f;
        bool musicEnabled = true;
        if ("audio.musicVolume" in config.props)
            musicVolume = config.props["audio.musicVolume"].toFloat;
        if ("audio.musicEnabled" in config.props)
            musicEnabled = cast(bool)config.props["audio.musicEnabled"].toUInt;
        
        options[SoundClass.SFX] = SoundClassOptions(sfxVolume, sfxEnabled);
        options[SoundClass.Music] = SoundClassOptions(musicVolume, musicEnabled);
    }
    
    ~this()
    {
        if (soloudPresent)
        {
            audio.stopAll();
            audio.deinit();
        }
        
        backend.free();
    }
    
    // TODO: use VFS to load the file
    Wav loadSound(string filename)
    {
        String filenameCStr = String(filename);
        Wav sound = Wav.create();
        sound.load(filenameCStr.ptr);
        filenameCStr.free();
        return sound;
    }
    
    // TODO: use VFS to load the file
    WavStream loadMusic(string filename)
    {
        String filenameCStr = String(filename);
        WavStream music = WavStream.create();
        music.load(filenameCStr.ptr);
        filenameCStr.free();
        return music;
    }
    
    // TODO: use VFS to load the file
    Openmpt loadTrackerMusic(string filename)
    {
        String filenameCStr = String(filename);
        Openmpt music = Openmpt.create();
        music.load(filenameCStr.ptr);
        filenameCStr.free();
        return music;
    }
    
    SoundComponent addSoundTo(Entity entity)
    {
        return New!SoundComponent(eventManager, this, entity);
    }
    
    int play(SoloudObject sound, uint soundClass, bool looping = false)
    {
        if (!enabled)
            return 0;
        
        int voice = audio.play(sound);
        audio.setLooping(voice, false);
        audio.setVolume(voice, options[soundClass].volume);
        audio.setLooping(voice, looping);
        return voice;
    }
    
    int playAtPosition(SoloudObject sound, uint soundClass, Vector3f position, bool looping = false)
    {
        if (!enabled)
            return 0;
        
        int voice = audio.play3d(sound, position.x, position.y, position.z);
        audio.setLooping(voice, false);
        audio.setVolume(voice, options[soundClass].volume);
        audio.setLooping(voice, looping);
        // TODO: use master 3D sound settings
        return voice;
    }
    
    int play(SoloudObject sound, bool looping = false)
    {
        return play(sound, SoundClass.SFX, looping);
    }
    
    int playAtPosition(SoloudObject sound, Vector3f position, bool looping = false)
    {
        return playAtPosition(sound, SoundClass.SFX, position, looping);
    }
    
    int playMusic(SoloudObject sound, bool looping = false)
    {
        return play(sound, SoundClass.Music, looping);
    }
    
    int playMusicAtPosition(SoloudObject sound, Vector3f position, bool looping = false)
    {
        return playAtPosition(sound, SoundClass.Music, position, looping);
    }
    
    void stop()
    {
        if (soloudPresent)
            audio.stopAll();
    }
    
    void update(Time time)
    {
        if (!soloudPresent)
            return;
        
        if (masterVolumeCoef < 1.0f)
            masterVolumeCoef += (1.0f / masterFadeInDuration) * time.delta;
        else
            masterVolumeCoef = 1.0f;
        
        audio.setGlobalVolume(masterVolume * masterVolumeCoef);
        
        if (listener)
        {
            Vector3f pos = listener.positionAbsolute;
            Vector3f dir = listener.directionAbsolute;
            Vector3f up = listener.upAbsolute;
            audio.set3dListenerPosition(pos.x, pos.y, pos.z);
            audio.set3dListenerAt(dir.x, dir.y, dir.z);
            audio.set3dListenerUp(up.x, up.y, up.z);
            audio.update3dAudio();
        }
    }
}
