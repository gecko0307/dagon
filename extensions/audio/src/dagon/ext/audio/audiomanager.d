/*
Copyright (c) 2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module dagon.ext.audio.audiomanager;

import std.conv;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.core.stream;
import dlib.math.vector;
import dlib.text.str;

import dagon.core.logger;
import dagon.core.application;
import dagon.core.vfs;
import dagon.core.event;
import dagon.core.time;
import dagon.core.config;
import dagon.core.props;
import dagon.graphics.entity;

import bindbc.soloud;
import loader = bindbc.loader.sharedlib;
import soloud;

import dagon.ext.audio.soundcomponent;
import dagon.ext.audio.playlist;

enum AudioBackend
{
    Auto = 0,
    SDL1 = 1,
    SDL2 = 2,
    PortAudio = 3,
    WinMM = 4,
    XAudio2 = 5,
    WASAPI = 6,
    ALSA = 7,
    JACK = 8,
    OSS = 9,
    OpenAL = 10,
    CoreAudio = 11,
    OpenSLES = 12,
    VitaHomebrew = 13,
    MiniAudio = 14,
    NoSound = 15,
    NullDriver = 16
}

enum AttenuationModel
{
    NoAttenuation = 0,
    InverseDistance = 1,
    LinearDistance = 2,
    ExponentialDistance = 3
};

enum SoundClass: uint
{
    SFX = 0,
    Music = 1
}

struct SoundClassOptions
{
    float volume;
    bool enabled;
}

class AudioManager: Owner
{
    Application application;
    Configuration config;
    VirtualFileSystem vfs;
    EventManager eventManager;
    
    SLSupport loadedSLSupport;
    bool soloudPresent = true;
    uint soloudVersion;
    
    bool enabled = true;
    
    Soloud audio;
    AudioBackend backend;
    String backendName;
    uint channels;
    uint sampleRate;
    uint bufferSize;
    
    float masterVolume = 1.0f;
    float masterVolumeCoef = 0.0f; // start with zero, gradually increment to 1.0f
    float masterFadeInDuration = 0.25f; // in seconds
    SoundClassOptions[32] options;
    
    Entity listener;
    
    Playlist activePlaylist;
    
    this(Application application)
    {
        super(application);
        
        this.application = application;
        this.config = application.config;
        this.vfs = application.vfs;
        this.eventManager = application.eventManager;
        
        loadedSLSupport = loadSoloud();
        
        if (loader.errors.length)
        {
            logError("SoLoad loader errors:");
            foreach(info; loader.errors)
            {
                logError(to!string(info.error), ": ", to!string(info.message));
            }
        }
        
        if (loadedSLSupport != slSupport)
        {
            if (loadedSLSupport == SLSupport.badLibrary)
            {
                logWarning("Failed to load some SoLoud functions. It seems that you have an old version of SoLoud. Dagon will try to use it, but it is recommended to install SoLoud 20200207 or higher");
            }
            else
            {
                logError("SoLoud library is not found. Please, install SoLoud 20200207");
                soloudPresent = false;
            }
        }
        
        enabled = soloudPresent;
        
        if (!soloudPresent)
            return;
        
        audio = Soloud.create();
        
        soloudVersion = audio.getVersion();
        logInfo("SoLoud version: ", soloudVersion);
        
        backend = AudioBackend.Auto;
        if ("audio.backend" in config.props)
        {
            string backendStr = config.props["audio.backend"].toString;
            switch(backendStr)
            {
                case "auto": backend = AudioBackend.Auto; break;
                case "SDL1": backend = AudioBackend.SDL1; break;
                case "SDL2": backend = AudioBackend.SDL2; break;
                case "PortAudio": backend = AudioBackend.PortAudio; break;
                case "WinMM": backend = AudioBackend.WinMM; break;
                case "XAudio2": backend = AudioBackend.XAudio2; break;
                case "WASAPI": backend = AudioBackend.WASAPI; break;
                case "ALSA": backend = AudioBackend.ALSA; break;
                case "JACK": backend = AudioBackend.JACK; break;
                case "OSS": backend = AudioBackend.OSS; break;
                case "OpenAL": backend = AudioBackend.OpenAL; break;
                case "CoreAudio": backend = AudioBackend.CoreAudio; break;
                case "OpenSLES": backend = AudioBackend.OpenSLES; break;
                case "VitaHomebrew": backend = AudioBackend.VitaHomebrew; break;
                case "MiniAudio": backend = AudioBackend.MiniAudio; break;
                case "NoSound": backend = AudioBackend.NoSound; break;
                case "NullDriver": backend = AudioBackend.NullDriver; break;
                default: break;
            }
        }
        
        sampleRate = Soloud.AUTO;
        if ("audio.sampleRate" in config.props)
        {
            auto prop = config.props["audio.sampleRate"];
            if (prop.type == DPropType.Number)
                sampleRate = prop.toUInt;
        }
        
        bufferSize = Soloud.AUTO;
        if ("audio.bufferSize" in config.props)
        {
            auto prop = config.props["audio.bufferSize"];
            if (prop.type == DPropType.Number)
                bufferSize = prop.toUInt;
        }
        
        channels = Soloud.AUTO;
        if ("audio.channels" in config.props)
        {
            auto prop = config.props["audio.channels"];
            if (prop.type == DPropType.Number)
                channels = prop.toUInt;
        }
        
        audio.init(Soloud.CLIP_ROUNDOFF | Soloud.LEFT_HANDED_3D, backend, sampleRate, bufferSize, channels);
        audio.setGlobalVolume(0.0f);
        
        backend = cast(AudioBackend)audio.getBackendId();
        const(char)* backendStr = audio.getBackendString();
        backendName = String(backendStr);
        logInfo("Audio backend: ", backendName);
        
        channels = audio.getBackendChannels();
        sampleRate = audio.getBackendSamplerate();
        bufferSize = audio.getBackendBufferSize();
        logInfo("Audio channels: ", channels);
        logInfo("Audio sample rate: ", sampleRate);
        logInfo("Audio buffer size: ", bufferSize);
        
        // Set options
        foreach(ref opt; options)
            opt = SoundClassOptions(0.5f, true);
        
        if ("audio.enabled" in config.props)
            enabled = soloudPresent && cast(bool)config.props["audio.enabled"].toUInt;
        
        if ("audio.masterVolume" in config.props)
            masterVolume = config.props["audio.masterVolume"].toFloat;
        
        if ("audio.masterFadeInDuration" in config.props)
            masterFadeInDuration = config.props["audio.masterFadeInDuration"].toFloat;
        
        float sfxVolume = 0.5f;
        bool sfxEnabled = true;
        if ("audio.sfxVolume" in config.props)
            sfxVolume = config.props["audio.sfxVolume"].toFloat;
        if ("audio.sfxEnabled" in config.props)
            sfxEnabled = cast(bool)config.props["audio.sfxEnabled"].toUInt;
        
        float musicVolume = 0.5f;
        bool musicEnabled = true;
        if ("audio.musicVolume" in config.props)
            musicVolume = config.props["audio.musicVolume"].toFloat;
        if ("audio.musicEnabled" in config.props)
            musicEnabled = cast(bool)config.props["audio.musicEnabled"].toUInt;
        
        options[SoundClass.SFX] = SoundClassOptions(sfxVolume, sfxEnabled);
        options[SoundClass.Music] = SoundClassOptions(musicVolume, musicEnabled);
    }
    
    ~this()
    {
        if (soloudPresent)
        {
            audio.stopAll();
            audio.deinit();
        }
        
        backendName.free();
    }
    
    Wav loadSound(string filename)
    {
        Wav sound = Wav.create();
        InputStream istrm = vfs.openForInput(filename);
        ubyte[] data = New!(ubyte[])(istrm.size);
        istrm.fillArray(data);
        sound.loadMem(data.ptr, cast(uint)data.length, true, false);
        Delete(data);
        Delete(istrm);
        return sound;
    }
    
    void loadMusic(ref WavStream wavStream, string filename)
    {
        InputStream istrm = vfs.openForInput(filename);
        ubyte[] data = New!(ubyte[])(istrm.size);
        istrm.fillArray(data);
        wavStream.loadMem(data.ptr, cast(uint)data.length, true, false);
        Delete(data);
        Delete(istrm);
    }
    
    WavStream loadMusic(string filename)
    {
        WavStream wavStream = WavStream.create();
        loadMusic(wavStream, filename);
        return wavStream;
    }
    
    void loadTrackerMusic(ref Openmpt openmpt, string filename)
    {
        InputStream istrm = vfs.openForInput(filename);
        ubyte[] data = New!(ubyte[])(istrm.size);
        istrm.fillArray(data);
        openmpt.loadMem(data.ptr, cast(uint)data.length, true, false);
        Delete(data);
        Delete(istrm);
    }
    
    Openmpt loadTrackerMusic(string filename)
    {
        Openmpt openmpt = Openmpt.create();
        loadTrackerMusic(openmpt, filename);
        return openmpt;
    }
    
    SoundComponent addSoundTo(Entity entity)
    {
        return New!SoundComponent(eventManager, this, entity);
    }
    
    Playlist addPlaylist()
    {
        Playlist p = New!Playlist(this, this);
        activePlaylist = p;
        return p;
    }
    
    int play(SoloudObject sound, uint soundClass, bool looping = false)
    {
        if (!enabled)
            return 0;
        
        int voice = audio.play(sound);
        audio.setVolume(voice, options[soundClass].volume);
        audio.setLooping(voice, looping);
        return voice;
    }
    
    int playAtPosition(SoloudObject sound, uint soundClass, Vector3f position, bool looping = false)
    {
        if (!enabled)
            return 0;
        
        int voice = audio.play3d(sound, position.x, position.y, position.z);
        audio.setVolume(voice, options[soundClass].volume);
        audio.setLooping(voice, looping);
        // TODO: use master 3D sound settings
        return voice;
    }
    
    int play(SoloudObject sound, bool looping = false)
    {
        return play(sound, SoundClass.SFX, looping);
    }
    
    int playAtPosition(SoloudObject sound, Vector3f position, bool looping = false)
    {
        return playAtPosition(sound, SoundClass.SFX, position, looping);
    }
    
    int playMusic(SoloudObject sound, bool looping = false)
    {
        return play(sound, SoundClass.Music, looping);
    }
    
    int playMusicAtPosition(SoloudObject sound, Vector3f position, bool looping = false)
    {
        return playAtPosition(sound, SoundClass.Music, position, looping);
    }
    
    void stopAll()
    {
        if (enabled)
            audio.stopAll();
    }
    
    void stop(int voice)
    {
        if (enabled)
            audio.stop(voice);
    }
    
    bool isPlaying(int voice)
    {
        if (enabled)
            return cast(bool)audio.isValidVoiceHandle(voice);
        else
            return false;
    }
    
    void update(Time time)
    {
        if (!soloudPresent)
            return;
        
        if (masterVolumeCoef < 1.0f)
            masterVolumeCoef += (1.0f / masterFadeInDuration) * time.delta;
        else
            masterVolumeCoef = 1.0f;
        
        audio.setGlobalVolume(masterVolume * masterVolumeCoef);
        
        if (listener)
        {
            Vector3f pos = listener.positionAbsolute;
            Vector3f dir = listener.directionAbsolute;
            Vector3f up = listener.upAbsolute;
            audio.set3dListenerPosition(pos.x, pos.y, pos.z);
            audio.set3dListenerAt(dir.x, dir.y, dir.z);
            audio.set3dListenerUp(up.x, up.y, up.z);
            audio.update3dAudio();
        }
        
        if (activePlaylist)
            activePlaylist.update();
    }
}
