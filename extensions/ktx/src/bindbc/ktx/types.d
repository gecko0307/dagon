/*
Copyright (c) 2025 Timur Gafarov.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module bindbc.ktx.types;

import std.stdio;
import std.stdint;

alias ktx_uint8_t = uint8_t;
alias ktx_bool_t = bool;

alias ktx_uint16_t = uint16_t;
alias ktx_int16_t = int16_t;
alias ktx_uint32_t = uint32_t;
alias ktx_int32_t = int32_t;
alias ktx_size_t = size_t;
alias ktx_uint64_t = uint64_t;
alias ktx_int64_t = int64_t;

enum KTX_GL_UNPACK_ALIGNMENT = 4;
enum KTX_FACESLICE_WHOLE_LEVEL = uint.max;

enum KTX_TRUE = true;
enum KTX_FALSE = false;

enum ktx_error_code_e
{
    KTX_SUCCESS = 0,         /* Operation was successful. */
    KTX_FILE_DATA_ERROR,     /* The data in the file is inconsistent with the spec. */
    KTX_FILE_ISPIPE,         /* The file is a pipe or named pipe. */
    KTX_FILE_OPEN_FAILED,    /* The target file could not be opened. */
    KTX_FILE_OVERFLOW,       /* The operation would exceed the max file size. */
    KTX_FILE_READ_ERROR,     /* An error occurred while reading from the file. */
    KTX_FILE_SEEK_ERROR,     /* An error occurred while seeking in the file. */
    KTX_FILE_UNEXPECTED_EOF, /* File does not have enough data to satisfy request. */
    KTX_FILE_WRITE_ERROR,    /* An error occurred while writing to the file. */
    KTX_GL_ERROR,            /* GL operations resulted in an error. */
    KTX_INVALID_OPERATION,   /* The operation is not allowed in the current state. */
    KTX_INVALID_VALUE,       /* A parameter value was not valid. */
    KTX_NOT_FOUND,           /* Requested metadata key or required dynamically loaded GPU function was not found. */
    KTX_OUT_OF_MEMORY,       /* Not enough memory to complete the operation. */
    KTX_TRANSCODE_FAILED,    /* Transcoding of block compressed texture failed. */
    KTX_UNKNOWN_FILE_FORMAT, /* The file not a KTX file */
    KTX_UNSUPPORTED_TEXTURE_TYPE, /* The KTX file specifies an unsupported texture type. */
    KTX_UNSUPPORTED_FEATURE,  /* Feature not included in in-use library or not yet implemented. */
    KTX_LIBRARY_NOT_LINKED,  /* Library dependency (OpenGL or Vulkan) not linked into application. */
    KTX_DECOMPRESS_LENGTH_ERROR, /* Decompressed byte count does not match expected byte size */
    KTX_DECOMPRESS_CHECKSUM_ERROR, /* Checksum mismatch when decompressing */
    KTX_ERROR_MAX_ENUM = KTX_DECOMPRESS_CHECKSUM_ERROR /* For safety checks. */
}

alias KTX_error_code = ktx_error_code_e;

enum KTX_IDENTIFIER_REF = [0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A];
enum KTX_ENDIAN_REF = 0x04030201;
enum KTX_ENDIAN_REF_REV = 0x01020304;
enum KTX_HEADER_SIZE = 64;

alias ktxResult = ktx_error_code_e;

enum ktxTextureCreateFlagBits
{
    KTX_TEXTURE_CREATE_NO_FLAGS = 0x00,
    KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT = 0x01,
    KTX_TEXTURE_CREATE_RAW_KVDATA_BIT = 0x02,
    KTX_TEXTURE_CREATE_SKIP_KVDATA_BIT = 0x04,
    KTX_TEXTURE_CREATE_CHECK_GLTF_BASISU_BIT = 0x08
};

alias ktxTextureCreateFlags = ktx_uint32_t;

struct ktxKVListEntry;
struct ktxStream;

alias ktxHashList = ktxKVListEntry*;
alias ktxHashListEntry = ktxKVListEntry;

enum ktxOrientationX: uint
{
    KTX_ORIENT_X_LEFT = 108, // 'l'
    KTX_ORIENT_X_RIGHT = 114 // 'r'
}

enum ktxOrientationY: uint
{
    KTX_ORIENT_Y_UP = 117,  // 'u',
    KTX_ORIENT_Y_DOWN = 100 // 'd'
}

enum ktxOrientationZ: uint
{
    KTX_ORIENT_Z_IN = 105,  // 'i',
    KTX_ORIENT_Z_OUT = 111  // 'o'
}

enum class_id
{
    ktxTexture1_c = 1,
    ktxTexture2_c = 2
}

struct ktxOrientation
{
    uint x;
    uint y;
    uint z;
}

struct ktxTexture_vtbl
{
    PFNKTEXDESTROY Destroy;
    PFNKTEXGETIMAGEOFFSET GetImageOffset;
    PFNKTEXGETDATASIZEUNCOMPRESSED GetDataSizeUncompressed;
    PFNKTEXGETIMAGESIZE GetImageSize;
    PFNKTEXGETLEVELSIZE GetLevelSize;
    PFNKTEXITERATELEVELS IterateLevels;
    PFNKTEXITERATELOADLEVELFACES IterateLoadLevelFaces;
    PFNKTEXNEEDSTRANSCODING NeedsTranscoding;
    PFNKTEXLOADIMAGEDATA LoadImageData;
    PFNKTEXSETIMAGEFROMMEMORY SetImageFromMemory;
    PFNKTEXSETIMAGEFROMSTDIOSTREAM SetImageFromStdioStream;
    PFNKTEXWRITETOSTDIOSTREAM WriteToStdioStream;
    PFNKTEXWRITETONAMEDFILE WriteToNamedFile;
    PFNKTEXWRITETOMEMORY WriteToMemory;
    PFNKTEXWRITETOSTREAM WriteToStream;
}

struct ktxTexture_vvtbl;
struct ktxTexture_protected;

extern(C) @nogc nothrow
{
    alias PFNKTXITERCB = KTX_error_code function(
        int miplevel,
        int face,
        int width,
        int height,
        int depth,
        ktx_uint64_t faceLodSize,
        void* pixels,
        void* userdata);
    alias PFNKTEXDESTROY = void function(ktxTexture* tex);
    alias PFNKTEXGETIMAGEOFFSET = KTX_error_code function(
        ktxTexture* tex,
        ktx_uint32_t level,
        ktx_uint32_t layer,
        ktx_uint32_t faceSlice,
        ktx_size_t* pOffset);
    alias PFNKTEXGETDATASIZEUNCOMPRESSED = ktx_size_t function(ktxTexture* tex);
    alias PFNKTEXGETIMAGESIZE = ktx_size_t function(ktxTexture* tex, ktx_uint32_t level);
    alias PFNKTEXGETLEVELSIZE = ktx_size_t function(ktxTexture* tex, ktx_uint32_t level);
    alias PFNKTEXITERATELEVELS = KTX_error_code function(
        ktxTexture* tex,
        PFNKTXITERCB iterCb,
        void* userdata);
    alias PFNKTEXITERATELOADLEVELFACES = KTX_error_code function(
        ktxTexture* tex,
        PFNKTXITERCB iterCb,
        void* userdata);
    alias PFNKTEXLOADIMAGEDATA = KTX_error_code function(
        ktxTexture* tex,
        ktx_uint8_t* pBuffer,
        ktx_size_t bufSize);
    alias PFNKTEXNEEDSTRANSCODING = ktx_bool_t function(ktxTexture* tex);
    alias PFNKTEXSETIMAGEFROMMEMORY = KTX_error_code function(
        ktxTexture* tex,
        ktx_uint32_t level,
        ktx_uint32_t layer,
        ktx_uint32_t faceSlice,
        const(ktx_uint8_t)* src,
        ktx_size_t srcSize);
    alias PFNKTEXSETIMAGEFROMSTDIOSTREAM = KTX_error_code function(
        ktxTexture* tex,
        ktx_uint32_t level,
        ktx_uint32_t layer,
        ktx_uint32_t faceSlice,
        FILE* src,
        ktx_size_t srcSize);
    alias PFNKTEXWRITETOSTDIOSTREAM = KTX_error_code function(ktxTexture* tex, FILE* dstsstr);
    alias PFNKTEXWRITETONAMEDFILE = KTX_error_code function(ktxTexture* tex, const(char)* dstname);
    alias PFNKTEXWRITETOMEMORY = KTX_error_code function(
        ktxTexture* tex,
        ktx_uint8_t** bytes,
        ktx_size_t* size);
    alias PFNKTEXWRITETOSTREAM = KTX_error_code function(ktxTexture* tex, ktxStream* dststr);
}

mixin template KTXTEXTURECLASSDEFN()
{
    class_id classId;
    ktxTexture_vtbl* vtbl;
    ktxTexture_vvtbl* vvtbl;
    ktxTexture_protected* _protected;
    ktx_bool_t   isArray;
    ktx_bool_t   isCubemap;
    ktx_bool_t   isCompressed;
    ktx_bool_t   generateMipmaps;
    ktx_uint32_t baseWidth;
    ktx_uint32_t baseHeight;
    ktx_uint32_t baseDepth;
    ktx_uint32_t numDimensions;
    ktx_uint32_t numLevels;
    ktx_uint32_t numLayers;
    ktx_uint32_t numFaces;
    ktxOrientation orientation;
    ktxHashList kvDataHead;
    ktx_uint32_t kvDataLen;
    ktx_uint8_t* kvData;
    ktx_size_t dataSize;
    ktx_uint8_t* pData;
}

struct ktxTexture
{
    mixin KTXTEXTURECLASSDEFN;
}

struct ktxTexture1_private;
struct ktxTexture2_private;

struct ktxTexture1
{
    mixin KTXTEXTURECLASSDEFN;
    ktx_uint32_t glFormat;
    ktx_uint32_t glInternalformat;
    ktx_uint32_t glBaseInternalformat;
    ktx_uint32_t glType;
    ktxTexture1_private* _private;
}

enum ktxSupercmpScheme
{
    KTX_SS_NONE = 0,
    KTX_SS_BASIS_LZ = 1,
    KTX_SS_ZSTD = 2,
    KTX_SS_ZLIB = 3,
    KTX_SS_BEGIN_RANGE = KTX_SS_NONE,
    KTX_SS_END_RANGE = KTX_SS_ZLIB,
    KTX_SS_BEGIN_VENDOR_RANGE = 0x10000,
    KTX_SS_END_VENDOR_RANGE = 0x1ffff,
    KTX_SS_BEGIN_RESERVED = 0x20000,
    KTX_SUPERCOMPRESSION_BASIS = KTX_SS_BASIS_LZ,
    KTX_SUPERCOMPRESSION_ZSTD = KTX_SS_ZSTD
}

struct ktxTexture2
{
    mixin KTXTEXTURECLASSDEFN;
    ktx_uint32_t vkFormat;
    ktx_uint32_t* pDfd;
    ktxSupercmpScheme supercompressionScheme;
    ktx_bool_t isVideo;
    ktx_uint32_t duration;
    ktx_uint32_t timescale;
    ktx_uint32_t loopcount;
    ktxTexture2_private* _private;
}

enum ktx_transcode_fmt_e
{
    KTX_TTF_ETC1_RGB = 0,
    KTX_TTF_ETC2_RGBA = 1,
    KTX_TTF_BC1_RGB = 2,
    KTX_TTF_BC3_RGBA = 3,
    KTX_TTF_BC4_R = 4,
    KTX_TTF_BC5_RG = 5,
    KTX_TTF_BC7_RGBA = 6,
    KTX_TTF_PVRTC1_4_RGB = 8,
    KTX_TTF_PVRTC1_4_RGBA = 9,
    KTX_TTF_ASTC_4x4_RGBA = 10,
    KTX_TTF_PVRTC2_4_RGB = 18,
    KTX_TTF_PVRTC2_4_RGBA = 19,
    KTX_TTF_ETC2_EAC_R11 = 20,
    KTX_TTF_ETC2_EAC_RG11 = 21,
    KTX_TTF_RGBA32 = 13,
    KTX_TTF_RGB565 = 14,
    KTX_TTF_BGR565 = 15,
    KTX_TTF_RGBA4444 = 16,
    KTX_TTF_ETC = 22,
    KTX_TTF_BC1_OR_3 = 23,
    KTX_TTF_NOSELECTION = 0x7fffffff,
    KTX_TF_ETC1 = KTX_TTF_ETC1_RGB,
    KTX_TF_ETC2 = KTX_TTF_ETC,
    KTX_TF_BC1 = KTX_TTF_BC1_RGB,
    KTX_TF_BC3 = KTX_TTF_BC3_RGBA,
    KTX_TF_BC4 = KTX_TTF_BC4_R,
    KTX_TF_BC5 = KTX_TTF_BC5_RG,
    KTX_TTF_BC7_M6_RGB = KTX_TTF_BC7_RGBA,
    KTX_TTF_BC7_M5_RGBA = KTX_TTF_BC7_RGBA,
    KTX_TF_BC7_M6_OPAQUE_ONLY = KTX_TTF_BC7_RGBA,
    KTX_TF_PVRTC1_4_OPAQUE_ONLY = KTX_TTF_PVRTC1_4_RGB
}

enum ktx_transcode_flag_bits_e
{
    KTX_TF_PVRTC_DECODE_TO_NEXT_POW2 = 2,
    KTX_TF_TRANSCODE_ALPHA_DATA_TO_OPAQUE_FORMATS = 4,
    KTX_TF_HIGH_QUALITY = 32
}

alias ktx_transcode_flags = ktx_uint32_t;

auto ktxTexture_NeedsTranscoding(TEX)(TEX* tex)
{
    return tex.vtbl.NeedsTranscoding(cast(ktxTexture*)tex);
}

auto ktxTexture_GetImageOffset(TEX)(TEX* tex, ktx_uint32_t level, ktx_uint32_t layer, ktx_uint32_t faceSlice, ktx_size_t* pOffset)
{
    return tex.vtbl.GetImageOffset(cast(ktxTexture*)tex, level, layer, faceSlice, pOffset);
}

auto ktxTexture_GetImageSize(TEX)(TEX* tex, ktx_uint32_t level)
{
    return tex.vtbl.GetImageSize(cast(ktxTexture*)tex, level);
}

auto ktxTexture_GetLevelSize(TEX)(TEX* tex, ktx_uint32_t level)
{
    return tex.vtbl.GetLevelSize(cast(ktxTexture*)tex, level);
}

auto ktxTexture_IterateLevels(TEX)(TEX* tex, PFNKTXITERCB iterCb, void* userdata)
{
    return tex.vtbl.IterateLevels(cast(ktxTexture*)tex, iterCb, userdata);
}
