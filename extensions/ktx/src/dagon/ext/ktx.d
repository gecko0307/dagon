/*
Copyright (c) 2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module dagon.ext.ktx;

import std.stdio;
import std.path;
import std.algorithm;
import std.conv;
import std.string;

import dlib.core.stream;
import dlib.core.memory;
import dlib.core.ownership;
import dlib.core.compound;
import dlib.filesystem.filesystem;

import dagon.core.bindings;
import dagon.core.vkformat;
import dagon.core.application;
import dagon.core.logger;
import dagon.graphics.texture;
import dagon.resource.asset;
import dagon.resource.texture;
import dagon.resource.scene;

import loader = bindbc.loader.sharedlib;
public import bindbc.ktx;

bool vkFormatToGLFormat(VkFormat vkFormat, out TextureFormat tf)
{
    tf.format = 0;
    tf.internalFormat = 0;
    tf.pixelType = 0;
    tf.blockSize = 0;
    
    switch(vkFormat)
    {
        case VkFormat.R8_UNORM:
            tf.format = GL_RED;
            tf.internalFormat = GL_R8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R8_SNORM:
            tf.format = GL_RED;
            tf.internalFormat = GL_R8;
            tf.pixelType = GL_BYTE;
            break;
        
        case VkFormat.R8G8_UNORM:
            tf.format = GL_RG;
            tf.internalFormat = GL_RG8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R8G8_SNORM:
            tf.format = GL_RG;
            tf.internalFormat = GL_RG8;
            tf.pixelType = GL_BYTE;
            break;
        
        case VkFormat.R8G8B8A8_UNORM, VkFormat.R8G8B8A8_SRGB:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R8G8B8_UNORM, VkFormat.R8G8B8_SRGB:
            tf.format = GL_RGB;
            tf.internalFormat = GL_RGB8;
            tf.pixelType = GL_UNSIGNED_BYTE;
            break;
        
        case VkFormat.R32G32B32A32_SFLOAT:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA32F;
            tf.pixelType = GL_FLOAT;
            break;
        
        case VkFormat.R16G16B16A16_SFLOAT:
            tf.format = GL_RGBA;
            tf.internalFormat = GL_RGBA16F;
            tf.pixelType = GL_HALF_FLOAT;
            break;
        
        case VkFormat.BC1_RGB_UNORM_BLOCK, VkFormat.BC1_RGB_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
            tf.blockSize = 8;
            break;
        
        case VkFormat.BC2_UNORM_BLOCK, VkFormat.BC2_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC3_UNORM_BLOCK, VkFormat.BC3_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC4_UNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RED_RGTC1;
            tf.blockSize = 8;
            break;
        
        case VkFormat.BC4_SNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_SIGNED_RED_RGTC1;
            tf.blockSize = 8;
            break;
        
        case VkFormat.BC5_UNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RG_RGTC2;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC5_SNORM_BLOCK:
            tf.internalFormat = GL_COMPRESSED_SIGNED_RG_RGTC2;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC6H_SFLOAT_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC6H_UFLOAT_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB;
            tf.blockSize = 16;
            break;
        
        case VkFormat.BC7_UNORM_BLOCK, VkFormat.BC7_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_BPTC_UNORM_ARB;
            tf.blockSize = 16;
            break;
        
        case VkFormat.ASTC_4x4_UNORM_BLOCK, VkFormat.ASTC_4x4_SRGB_BLOCK:
            tf.internalFormat = GL_COMPRESSED_RGBA_ASTC_4x4_KHR;
            tf.blockSize = 16;
            break;
        
        default:
            logWarning("Unsupported VkFormat");
            return false;
    }
    
    return true;
}

VkFormat glFormatToVkFormat(GLenum internalFormat)
{
    switch(internalFormat)
    {
        // Uncompressed formats
        case GL_R8:               return VkFormat.R8_UNORM;
        case GL_R8_SNORM:         return VkFormat.R8_SNORM;
        case GL_R8UI:             return VkFormat.R8_UINT;
        case GL_R8I:              return VkFormat.R8_SINT;

        case GL_RG8:              return VkFormat.R8G8_UNORM;
        case GL_RG8_SNORM:        return VkFormat.R8G8_SNORM;
        case GL_RG8UI:            return VkFormat.R8G8_UINT;
        case GL_RG8I:             return VkFormat.R8G8_SINT;

        case GL_RGB8:             return VkFormat.R8G8B8_UNORM;
        case GL_RGB8_SNORM:       return VkFormat.R8G8B8_SNORM;
        case GL_RGB8UI:           return VkFormat.R8G8B8_UINT;
        case GL_RGB8I:            return VkFormat.R8G8B8_SINT;

        case GL_RGBA8:            return VkFormat.R8G8B8A8_UNORM;
        case GL_SRGB8_ALPHA8:     return VkFormat.R8G8B8A8_SRGB;
        case GL_RGBA8_SNORM:      return VkFormat.R8G8B8A8_SNORM;
        case GL_RGBA8UI:          return VkFormat.R8G8B8A8_UINT;
        case GL_RGBA8I:           return VkFormat.R8G8B8A8_SINT;

        case GL_RGB10_A2:         return VkFormat.A2R10G10B10_UNORM_PACK32;
        case GL_RGB10_A2UI:       return VkFormat.A2R10G10B10_UINT_PACK32;

        case GL_R16F:             return VkFormat.R16_SFLOAT;
        case GL_RG16F:            return VkFormat.R16G16_SFLOAT;
        case GL_RGB16F:           return VkFormat.R16G16B16_SFLOAT;
        case GL_RGBA16F:          return VkFormat.R16G16B16A16_SFLOAT;

        case GL_R32F:             return VkFormat.R32_SFLOAT;
        case GL_RG32F:            return VkFormat.R32G32_SFLOAT;
        case GL_RGB32F:           return VkFormat.R32G32B32_SFLOAT;
        case GL_RGBA32F:          return VkFormat.R32G32B32A32_SFLOAT;

        // DXTn
        case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:        return VkFormat.BC1_RGB_UNORM_BLOCK;
        case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:       return VkFormat.BC1_RGBA_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:       return VkFormat.BC1_RGB_SRGB_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: return VkFormat.BC1_RGBA_SRGB_BLOCK;

        case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:       return VkFormat.BC2_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: return VkFormat.BC2_SRGB_BLOCK;

        case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:       return VkFormat.BC3_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: return VkFormat.BC3_SRGB_BLOCK;

        // RGTC1, RGTC2
        case GL_COMPRESSED_RED_RGTC1:                return VkFormat.BC4_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_RED_RGTC1:         return VkFormat.BC4_SNORM_BLOCK;
        case GL_COMPRESSED_RG_RGTC2:                 return VkFormat.BC5_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_RG_RGTC2:          return VkFormat.BC5_SNORM_BLOCK;

        // BPTC
        case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB: return VkFormat.BC6H_UFLOAT_BLOCK;
        case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:   return VkFormat.BC6H_SFLOAT_BLOCK;
        case GL_COMPRESSED_RGBA_BPTC_UNORM_ARB:         return VkFormat.BC7_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB:   return VkFormat.BC7_SRGB_BLOCK;

        // ETC2/EAC
        case GL_COMPRESSED_RGB8_ETC2:                return VkFormat.ETC2_R8G8B8_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ETC2:               return VkFormat.ETC2_R8G8B8_SRGB_BLOCK;
        case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                                                     return VkFormat.ETC2_R8G8B8A1_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                                                     return VkFormat.ETC2_R8G8B8A1_SRGB_BLOCK;
        case GL_COMPRESSED_RGBA8_ETC2_EAC:           return VkFormat.ETC2_R8G8B8A8_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:    return VkFormat.ETC2_R8G8B8A8_SRGB_BLOCK;

        case GL_COMPRESSED_R11_EAC:                  return VkFormat.EAC_R11_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_R11_EAC:           return VkFormat.EAC_R11_SNORM_BLOCK;
        case GL_COMPRESSED_RG11_EAC:                 return VkFormat.EAC_R11G11_UNORM_BLOCK;
        case GL_COMPRESSED_SIGNED_RG11_EAC:          return VkFormat.EAC_R11G11_SNORM_BLOCK;

        // ASTC
        case GL_COMPRESSED_RGBA_ASTC_4x4_KHR:        return VkFormat.ASTC_4x4_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
                                                     return VkFormat.ASTC_4x4_SRGB_BLOCK;
        case GL_COMPRESSED_RGBA_ASTC_8x8_KHR:        return VkFormat.ASTC_8x8_UNORM_BLOCK;
        case GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
                                                     return VkFormat.ASTC_8x8_SRGB_BLOCK;

        default:
            return VkFormat.UNDEFINED;
    }
}

bool loadKTX1(InputStream istrm, string filename, TextureBuffer* buffer, bool* generateMipmaps)
{
    size_t dataSize = istrm.size;
    ubyte[] data = New!(ubyte[])(dataSize);
    istrm.readBytes(data.ptr, dataSize);
    
    ktxTexture1* tex = null;
    KTX_error_code err = ktxTexture1_CreateFromMemory(data.ptr, dataSize,
        ktxTextureCreateFlagBits.KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT, &tex);
    if (err != KTX_error_code.KTX_SUCCESS)
    {
        logError("Failed to load ", filename, ": ", err);
        return false;
    }
    
    TextureSize size;
    size.width = tex.baseWidth;
    size.height = tex.baseHeight;
    size.depth = tex.baseDepth;
    
    TextureFormat format;
    format.format = tex.glFormat;
    format.internalFormat = tex.glInternalformat;
    format.pixelType = tex.glType;
    
    // Don't use automatic linearization
    if (format.internalFormat == GL_SRGB8_ALPHA8)
        format.internalFormat = GL_RGBA8;
    else if (format.internalFormat == GL_SRGB8)
        format.internalFormat = GL_RGB8;
    
    if (tex.isCubemap)
    {
        format.target = GL_TEXTURE_CUBE_MAP;
        format.cubeFaces = CubeFaceBit.All;
    }
    else
    {
        if (tex.numDimensions == 1)
            format.target = GL_TEXTURE_1D;
        else if (tex.numDimensions == 2)
            format.target = GL_TEXTURE_2D;
        else if (tex.numDimensions == 3)
            format.target = GL_TEXTURE_3D;
    }
    
    buffer.format = format;
    buffer.size = size;
    buffer.mipLevels = tex.numLevels;
    buffer.data = New!(ubyte[])(tex.dataSize);
    
    size_t dstOffset = 0;
    for (uint cubeFace = 0; cubeFace < tex.numFaces; cubeFace++)
    {
        for (uint mipLevel = 0; mipLevel < buffer.mipLevels; mipLevel++)
        {
            ktx_size_t mipLevelOffset;
            ktxTexture_GetImageOffset(tex, mipLevel, 0, cubeFace, &mipLevelOffset);
            ktx_size_t mipLevelSize = ktxTexture_GetImageSize(tex, mipLevel);
            
            buffer.data[dstOffset..dstOffset+mipLevelSize] = tex.pData[mipLevelOffset..mipLevelOffset+mipLevelSize];
            dstOffset += mipLevelSize;
        }
    }
    
    *generateMipmaps = tex.generateMipmaps;
    
    ktxTexture1_Destroy(tex);
    
    Delete(data);
    
    return true;
}

enum TranscodeHint
{
    Quality = 0,
    Size = 1,
    Uncompressed = 2
}

bool loadKTX2(InputStream istrm, string filename, TextureBuffer* buffer, TranscodeHint hint, bool* generateMipmaps)
{
    size_t dataSize = istrm.size;
    ubyte[] data = New!(ubyte[])(dataSize);
    istrm.readBytes(data.ptr, dataSize);
    
    ktxTexture2* tex = null;
    KTX_error_code err = ktxTexture2_CreateFromMemory(data.ptr, dataSize,
        ktxTextureCreateFlagBits.KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT, &tex);
    if (err != KTX_error_code.KTX_SUCCESS)
    {
        logError("Failed to load ", filename, ": ", err);
        return false;
    }
    
    if (ktxTexture2_NeedsTranscoding(tex))
    {
        auto numChannels = ktxTexture2_GetNumComponents(tex);
        
        bool bptcSupported = isExtensionSupported("GL_ARB_texture_compression_bptc");
        
        // Desktop GPUs lack ASTC support
        //bool astcSupported = isExtensionSupported("GL_KHR_texture_compression_astc_ldr");
        
        ktx_transcode_fmt_e targetFormat;
        string targetFormatStr;
        
        if (hint == TranscodeHint.Uncompressed)
        {
            targetFormat = ktx_transcode_fmt_e.KTX_TTF_RGBA32;
            targetFormatStr = "RGBA32";
        }
        else if (numChannels == 1)
        {
            targetFormat = ktx_transcode_fmt_e.KTX_TTF_BC4_R;
            targetFormatStr = "RGTC/BC4";
        }
        else if (numChannels == 2)
        {
            targetFormat = ktx_transcode_fmt_e.KTX_TTF_BC5_RG;
            targetFormatStr = "RGTC/BC5";
        }
        else if (numChannels == 3)
        {
            if (bptcSupported && hint == TranscodeHint.Quality)
            {
                targetFormat = ktx_transcode_fmt_e.KTX_TTF_BC7_RGBA;
                targetFormatStr = "BPTC/BC7";
            }
            else
            {
                targetFormat = ktx_transcode_fmt_e.KTX_TTF_BC1_RGB;
                targetFormatStr = "DXT1/BC1";
            }
        }
        else if (numChannels == 4)
        {
            if (bptcSupported && hint == TranscodeHint.Quality)
            {
                targetFormat = ktx_transcode_fmt_e.KTX_TTF_BC7_RGBA;
                targetFormatStr = "BPTC/BC7";
            }
            else
            {
                targetFormat = ktx_transcode_fmt_e.KTX_TTF_BC3_RGBA;
                targetFormatStr = "DXT5/BC3";
            }
        }
        
        logInfo("Transcoding ", filename, " to ", targetFormatStr);
        err = ktxTexture2_TranscodeBasis(tex, targetFormat, 0);
        if (err != KTX_error_code.KTX_SUCCESS)
        {
            logError("Failed to transcode ", filename, ": ", err);
            return false;
        }
    }
    
    TextureSize size;
    size.width = tex.baseWidth;
    size.height = tex.baseHeight;
    size.depth = tex.baseDepth;
    
    TextureFormat format;
    
    if (!vkFormatToGLFormat(cast(VkFormat)tex.vkFormat, format))
        return false;
    
    if (tex.isCubemap)
    {
        format.target = GL_TEXTURE_CUBE_MAP;
        format.cubeFaces = CubeFaceBit.All;
    }
    else
    {
        if (tex.numDimensions == 1)
            format.target = GL_TEXTURE_1D;
        else if (tex.numDimensions == 2)
            format.target = GL_TEXTURE_2D;
        else if (tex.numDimensions == 3)
            format.target = GL_TEXTURE_3D;
    }
    
    buffer.format = format;
    buffer.size = size;
    buffer.mipLevels = tex.numLevels;
    buffer.data = New!(ubyte[])(tex.dataSize);
    
    size_t dstOffset = 0;
    for (uint cubeFace = 0; cubeFace < tex.numFaces; cubeFace++)
    {
        for (uint mipLevel = 0; mipLevel < buffer.mipLevels; mipLevel++)
        {
            ktx_size_t mipLevelOffset;
            ktxTexture2_GetImageOffset(tex, mipLevel, 0, cubeFace, &mipLevelOffset);
            ktx_size_t mipLevelSize = ktxTexture_GetImageSize(tex, mipLevel);
            
            buffer.data[dstOffset..dstOffset+mipLevelSize] = tex.pData[mipLevelOffset..mipLevelOffset+mipLevelSize];
            dstOffset += mipLevelSize;
        }
    }
    
    *generateMipmaps = tex.generateMipmaps;
    
    ktxTexture2_Destroy(tex);
    
    Delete(data);
    
    return true;
}

class KTXLoader: TextureLoader
{
    this(AssetManager assetManager)
    {
        super(assetManager);
    }
    
    override Compound!(bool, string) load(
        string filename,
        string extension,
        InputStream istrm,
        TextureAsset asset,
        uint option = 0)
    {
        TranscodeHint hint = cast(TranscodeHint)asset.conversion.hint;
        
        if (extension == ".ktx" || extension == ".KTX")
        {
            bool loaded = loadKTX1(istrm, filename, &asset.buffer, &asset.generateMipmaps);
            if (loaded)
            {
                asset.bufferDataIsImageData = false;
                return compound(true, "");
            }
            else
                return compound(false, "Failed to decode image file");
        }
        else if (extension == ".ktx2" || extension == ".KTX2")
        {
            bool loaded = loadKTX2(istrm, filename, &asset.buffer, hint, &asset.generateMipmaps);
            if (loaded)
            {
                asset.bufferDataIsImageData = false;
                return compound(true, "");
            }
            else
                return compound(false, "Failed to decode image file");
        }
        else
        {
            return compound(false, "Unsupported image file format");
        }
    }
}

KTXSupport loadKTXLibrary()
{
    KTXSupport ktxVersion = loadKTX();
    
    if (loader.errors.length)
    {
        logError("libktx loader errors:");
        foreach(info; loader.errors)
        {
            logError(to!string(info.error), ": ", to!string(info.message));
        }
    }
    
    return ktxVersion;
}

void registerKTXLoader(AssetManager assetManager)
{
    auto ktxLoader = New!KTXLoader(assetManager);
    assetManager.registerTextureLoader([".ktx", ".ktx2"], ktxLoader);
}

void saveTextureToKTX2(Texture texture, string filename)
{
    VkFormat vkFormat = glFormatToVkFormat(texture.format.internalFormat);
    
    ktxTextureCreateInfo createInfo = {
        glInternalformat: texture.format.internalFormat,
        vkFormat: vkFormat,
        pDfd: null,
        baseWidth: texture.width,
        baseHeight: texture.height,
        baseDepth: 1,
        numDimensions: 2,
        numLevels: 1,
        numLayers: 1,
        numFaces: 1,
        isArray: KTX_FALSE,
        generateMipmaps: KTX_FALSE
    };
    
    ktxTexture2* ktxTex = null;
    KTX_error_code err = ktxTexture2_Create(
        &createInfo,
        ktxTextureCreateStorageEnum.KTX_TEXTURE_CREATE_ALLOC_STORAGE,
        &ktxTex);
    if (err != KTX_error_code.KTX_SUCCESS)
    {
        logError(err);
        exitWithError("ktxTexture2_Create failed");
    }
    
    texture.bind();
    
    ubyte[] data;
    if (texture.isCompressed)
    {
        GLint compressedSize = 0;
        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, &compressedSize);
        data = New!(ubyte[])(compressedSize);
        glGetCompressedTexImage(GL_TEXTURE_2D, 0, data.ptr);
    }
    else
    {
        data = New!(ubyte[])(texture.size.width * texture.size.height * 4);
        glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, data.ptr);
    }
    
    texture.unbind();
    
    err = ktxTexture_SetImageFromMemory(ktxTex, 0, 0, 0, data.ptr, data.length);
    if (err != KTX_error_code.KTX_SUCCESS)
    {
        logError(err);
        exitWithError("ktxTexture_SetImageFromMemory failed");
    }
    
    ktxTexture2_CompressBasis(ktxTex, 128);
    ktxTexture2_DeflateZstd(ktxTex, 10);
    
    err = ktxTexture2_WriteToNamedFile(ktxTex, filename.toStringz);
    if (err != KTX_error_code.KTX_SUCCESS)
    {
        logError(err);
        exitWithError("ktxTexture2_WriteToNamedFile failed");
    }
    
    ktxTexture2_Destroy(ktxTex);
    
    if (data.length)
        Delete(data);
}
