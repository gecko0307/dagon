/*
Copyright (c) 2025 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module gscript.vm;

import std.stdio;
import std.conv;
import std.traits;
import std.algorithm;
import std.array;
import std.ascii;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.container.array;
import dlib.container.dict;

import gscript.arena;
import gscript.instructions;
import gscript.dynamic;
import gscript.stdlib.array;
import gscript.stdlib.str;
import gscript.stdlib.io;
import gscript.stdlib.time;

interface GsObject
{
    GsDynamic get(string key);
    void set(string key, GsDynamic value);
    bool contains(string key);
    void setPrototype(GsObject);
    
    final GsDynamic opIndex(string key)
    {
        if (contains(key))
            return get(key);
        else
            return GsDynamic();
    }
    
    final T opIndexAssign(T)(T value, string key)
    {
        set(key, GsDynamic(value));
        return value;
    }
}

class GsArenaObject: GsObject
{
    GsArena arena;
    GsObject prototype;
    Dict!(GsDynamic, string) storage;
    
    this(GsArena arena)
    {
        this.arena = arena;
        storage = dict!(GsDynamic, string);
    }
    
    ~this()
    {
        Delete(storage);
    }
    
    GsDynamic get(string key)
    {
        auto v = key in storage;
        if (v)
            return *v;
        else
        {
            if (prototype)
                return prototype.get(key);
            else
                return GsDynamic();
        }
    }
    
    void set(string key, GsDynamic value)
    {
        storage[key] = value;
    }
    
    bool contains(string key)
    {
        if ((key in storage) !is null)
            return true;
        else
        {
            if (prototype)
                return prototype.contains(key);
            else
                return false;
        }
    }
    
    void setPrototype(GsObject proto)
    {
        prototype = proto;
    }
}

struct GsCallFrame
{
    GsDynamic[128] parameters;
    GsDynamic[128] localVariables;
    size_t numParameters;
}

class GsVirtualMachine: Owner, GsObject
{
    GsInstruction[] instructions;     // Program code
    Dict!(GsDynamic, string) globals; // Built-in variables
    Dict!(size_t, string) jumpTable;  // Function table mapping names to instruction indices
    
    // Standard library
    GsGlobalArray globArray;
    GsGlobalStr globStr;
    GsGlobalIO globIO;
    GsGlobalTime globTime;
    
    GsArena heap;
    
    Array!GsThread threads;
    GsThread mainThread;
    
    bool running = false;
    
    this(Owner owner = null)
    {
        super(owner);
        heap = New!GsArena(1024 * 10, this);
        
        jumpTable = dict!(size_t, string);
        
        globals = dict!(GsDynamic, string);
        
        globArray = heap.create!GsGlobalArray(heap);
        globals["array"] = GsDynamic(globArray);
        
        globStr = heap.create!GsGlobalStr(heap);
        globals["string"] = GsDynamic(globStr);
        
        globIO = heap.create!GsGlobalIO(heap);
        globals["io"] = GsDynamic(globIO);
        
        globTime = heap.create!GsGlobalTime(heap);
        globals["time"] = GsDynamic(globTime);
        
        mainThread = New!GsThread(this);
        threads.append(mainThread);
    }
    
    ~this()
    {
        Delete(jumpTable);
        Delete(globals);
        threads.free();
    }
    
    // GsObject methods
    
    GsDynamic get(string key)
    {
        auto v = key in globals;
        if (v)
            return *v;
        else
            return GsDynamic(cast(double)0.0);
    }

    void set(string key, GsDynamic value)
    {
        globals[key] = value;
    }

    bool contains(string key)
    {
        return (key in globals) !is null;
    }
    
    void setPrototype(GsObject proto)
    {
        // No-op
    }
    
    // 
    
    void fatality(A...)(string fmt, A args)
    {
        writefln(fmt, args);
        finalize();
    }
    
    GsObject createObject()
    {
        return heap.create!GsArenaObject(heap);
    }
    
    GsDynamic[] createArray(size_t len)
    {
        return heap.create!(GsDynamic[])(len);
    }
    
    bool hasLabel(string name)
    {
        return (name in jumpTable) != null;
    }
    
    GsDynamic call(string jumpLabel, GsDynamic[] args)
    {
        if (jumpLabel in jumpTable)
        {
            auto callFrame = &mainThread.callFrames[0];
            for(size_t i = 0; i < args.length; i++)
            {
                callFrame.parameters[i] = args[i];
            }
            callFrame.numParameters = args.length;
            mainThread.callDepth = 0;
            run(jumpTable[jumpLabel], 0);
            return mainThread.yieldValue;
        }
        else
        {
            writeln("Error: unknown jump label \"", jumpLabel, "\"");
            return GsDynamic();
        }
    }
    
    void finalize()
    {
        for (size_t i = 0; i < threads.length; i++)
        {
            threads[i].finalize();
        }
        
        running = false;
    }

    void load(GsInstruction[] instructions)
    {
        this.instructions = instructions;
        
        // Populate the function table with label indices
        foreach(i, instrunction; instructions)
        {
            if (instrunction.type == GsInstructionType.LABEL)
            {
                jumpTable[instrunction.operand.asString] = i;
            }
        }
        
        finalize();
    }
    
    void run(size_t initialIp = 0, size_t initialCallDepth = 1)
    {
        finalize();
        running = true;
        mainThread.start(initialIp, initialCallDepth);
        
        // Progress each active thread
        while(running)
        {
            size_t numActiveThreads = 0;
            
            GsThread tr = mainThread;
            
            while(tr !is null)
            {
                if (!tr.running || tr.paused)
                {
                    tr = tr.next;
                    continue;
                }
                
                numActiveThreads++;
                
                tr.callFrame = &tr.callFrames[tr.cp];
                
                if (tr.ip >= instructions.length)
                {
                    tr.running = false;
                    tr.waiting = false;
                    continue;
                }
                
                auto instruction = instructions[tr.ip];
                
                tr.ip++;
                
                switch (instruction.type)
                {
                    case GsInstructionType.LABEL:
                        break;
                    case GsInstructionType.PUSH:
                        tr.push(instruction.operand);
                        break;
                    case GsInstructionType.POP:
                        tr.pop();
                        break;
                    case GsInstructionType.ADD:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber + b.asNumber));
                        else
                        {
                            fatality("Fatality: addition of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.SUB:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber - b.asNumber));
                        else
                        {
                            fatality("Fatality: subtraction of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.MUL:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber * b.asNumber));
                        else
                        {
                            fatality("Fatality: multiplication of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.DIV:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber / b.asNumber));
                        else
                        {
                            fatality("Fatality: division of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.NEG:
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number)
                            tr.push(GsDynamic(-a.asNumber));
                        else
                        {
                            fatality("Fatality: negation of %s", a.type);
                            return;
                        }
                        break;
                    case GsInstructionType.MOD:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber % b.asNumber));
                        else
                        {
                            fatality("Fatality: modulo of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.POW:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber ^^ b.asNumber));
                        else
                        {
                            fatality("Fatality: power of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.BITWISE_AND:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(cast(long)a.asNumber & cast(long)b.asNumber));
                        else
                        {
                            fatality("Fatality: bitwise AND of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.BITWISE_OR:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(cast(long)a.asNumber | cast(long)b.asNumber));
                        else
                        {
                            fatality("Fatality: bitwise OR of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.BITWISE_XOR:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(cast(long)a.asNumber ^ cast(long)b.asNumber));
                        else
                        {
                            fatality("Fatality: bitwise XOR of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.AND:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber && b.asNumber));
                        else
                        {
                            fatality("Fatality: logical AND of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.OR:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number && b.type == GsDynamicType.Number)
                            tr.push(GsDynamic(a.asNumber || b.asNumber));
                        else
                        {
                            fatality("Fatality: logical OR of %s and %s", a.type, b.type);
                            return;
                        }
                        break;
                    case GsInstructionType.NOT:
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.Number)
                            tr.push(GsDynamic(!a.asNumber));
                        else
                        {
                            fatality("Fatality: logical NOT of %s", a.type);
                            return;
                        }
                        break;
                    case GsInstructionType.CAT:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        if (a.type == GsDynamicType.String && b.type == GsDynamicType.String)
                        {
                            tr.push(GsDynamic(heap.cat(a.toString(), b.toString())));
                        }
                        else if (a.type == GsDynamicType.Array && b.type == GsDynamicType.Array)
                        {
                            GsDynamic[] newArr = heap.cat(a.asArray, b.asArray);
                            tr.push(GsDynamic(newArr));
                        }
                        else if (a.type == GsDynamicType.Array && b.type != GsDynamicType.Array)
                        {
                            GsDynamic[] newArr = heap.cat(a.asArray, b);
                            tr.push(GsDynamic(newArr));
                        }
                        else if (a.type != GsDynamicType.Array && b.type == GsDynamicType.Array)
                        {
                            GsDynamic[] newArr = heap.cat(a, b.asArray);
                            tr.push(GsDynamic(newArr));
                        }
                        else
                        {
                            GsDynamic[] newArr = heap.create!(GsDynamic[])(2);
                            newArr[0] = a;
                            newArr[0] = b;
                            tr.push(GsDynamic(newArr));
                        }
                        break;
                    case GsInstructionType.EQ:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        tr.push(GsDynamic(a == b));
                        break;
                    case GsInstructionType.LESS:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a < b));
                        break;
                    case GsInstructionType.GREATER:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a > b));
                        break;
                    case GsInstructionType.NEQ:
                        auto b = tr.pop();
                        auto a = tr.pop();
                        tr.push(GsDynamic(a != b));
                        break;
                    case GsInstructionType.LESS_EQ:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a <= b));
                        break;
                    case GsInstructionType.GREATER_EQ:
                        auto b = tr.pop().asNumber;
                        auto a = tr.pop().asNumber;
                        tr.push(GsDynamic(a >= b));
                        break;
                    case GsInstructionType.JMP:
                        tr.ip = jumpTable[instruction.operand.asString];
                        break;
                    case GsInstructionType.JMP_IF:
                        if (cast(bool)tr.pop().asNumber)
                            tr.ip = jumpTable[instruction.operand.asString];
                        break;
                    case GsInstructionType.JMP_IF_NOT:
                        if (!cast(bool)tr.pop().asNumber)
                            tr.ip = jumpTable[instruction.operand.asString];
                        break;
                    case GsInstructionType.INDEX_GET:
                        size_t index = cast(size_t)tr.pop().asNumber;
                        auto arrayParam = tr.pop();
                        if (arrayParam.type == GsDynamicType.Array)
                        {
                            auto array = arrayParam.asArray;
                            if (index >= 0 && index < array.length)
                            {
                                tr.push(array[index]);
                                break;
                            }
                            else
                            {
                                fatality("Fatality: index is outside array capability");
                                return;
                            }
                        }
                        else if (arrayParam.type == GsDynamicType.String)
                        {
                            auto str = arrayParam.asString;
                            if (index >= 0 && index < str.length)
                            {
                                tr.push(GsDynamic(cast(double)str[index]));
                                break;
                            }
                            else
                            {
                                fatality("Fatality: index is outside string length");
                                return;
                            }
                        }
                        else
                        {
                            fatality("Fatality: attempting to index %s which is not an array", arrayParam.type);
                            return;
                        }
                    case GsInstructionType.INDEX_SET:
                        size_t index = cast(size_t)tr.pop().asNumber;
                        auto arrayParam = tr.pop();
                        if (arrayParam.type == GsDynamicType.Array)
                        {
                            auto array = arrayParam.asArray;
                            auto value = tr.pop();
                            if (index >= 0 && index < array.length)
                                array[index] = value;
                            else
                            {
                                fatality("Fatality: index is outside array capability");
                                return;
                            }
                            tr.push(value);
                            break;
                        }
                        else
                        {
                            fatality("Fatality: attempting to index %s which is not an array", arrayParam.type);
                            return;
                        }
                    case GsInstructionType.LENGTH:
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.Array)
                            tr.push(GsDynamic(param.asArray.length));
                        else if (param.type == GsDynamicType.String)
                            tr.push(GsDynamic(param.asString.length));
                        else if (param.type == GsDynamicType.Undefined)
                            tr.push(GsDynamic(0.0));
                        else
                            tr.push(GsDynamic(1.0));
                        break;
                    case GsInstructionType.PRINT:
                        writeln(tr.pop());
                        break;
                    case GsInstructionType.GLOBAL:
                        tr.push(GsDynamic(this));
                        break;
                    case GsInstructionType.ARRAY:
                        size_t len = cast(size_t)tr.pop().asNumber;
                        auto arr = createArray(len);
                        for (size_t ai = 0; ai < len; ai++)
                        {
                            arr[$ - 1 - ai] = tr.pop();
                        }
                        tr.push(GsDynamic(arr));
                        break;
                    case GsInstructionType.CALL:
                        size_t numParams = cast(size_t)instruction.operand.asNumber;
                        
                        auto func = tr.pop();
                        
                        GsNativeMethod nativeMethod;
                        GsNativeFunc nativeFuncPtr;
                        bool useNativeMethod = false;
                        bool useNativeFunc = false;
                        
                        if (func.type == GsDynamicType.NativeMethod)
                        {
                            nativeMethod = func.asNativeMethod;
                            useNativeMethod = true;
                        }
                        else if (func.type == GsDynamicType.NativeFunction)
                        {
                            nativeFuncPtr = func.asNativeFunction;
                            useNativeFunc = true;
                        }
                        else
                        {
                            if (func.type == GsDynamicType.String)
                            {
                                string funcName = func.asString;
                                if (funcName in jumpTable)
                                {
                                    tr.callStack[tr.cp] = tr.ip; // Push the current instruction pointer onto the call stack
                                    // Push a new call frame
                                    tr.cp++;
                                    tr.callFrame = &tr.callFrames[tr.cp];
                                    for(size_t pi = 0; pi < tr.callFrame.parameters.length; pi++)
                                    {
                                        if (pi < numParams)
                                            tr.callFrame.parameters[numParams - 1 - pi] = tr.pop();
                                        else
                                            tr.callFrame.parameters[pi] = GsDynamic();
                                    }
                                    tr.callFrame.numParameters = numParams;
                                    
                                    tr.ip = jumpTable[funcName]; // Jump to the function's starting instruction
                                    
                                    tr.callDepth++;
                                    
                                    break;
                                }
                                else
                                {
                                    fatality("Fatality: undefined jump label \"%s\"", funcName);
                                    return;
                                }
                            }
                            else
                            {
                                fatality("Fatality: attempting to call %s, which is not a function", func.type);
                                return;
                            }
                        }
                        
                        // Native call: push a new call frame
                        tr.cp++;
                        tr.callFrame = &tr.callFrames[tr.cp];
                        for(size_t pi = 0; pi < tr.callFrame.parameters.length; pi++)
                        {
                            if (pi < numParams)
                                tr.callFrame.parameters[numParams - 1 - pi] = tr.pop();
                            else
                                tr.callFrame.parameters[pi] = GsDynamic();
                        }
                        tr.callFrame.numParameters = numParams;
                        
                        GsDynamic result;
                        if (useNativeMethod)
                            result = nativeMethod(tr.callFrame.parameters[0..numParams]);
                        else if (useNativeFunc)
                            result = nativeFuncPtr(tr.callFrame.parameters[0..numParams]);
                         
                        tr.cp--;
                        tr.callFrame = &tr.callFrames[tr.cp];
                        tr.push(result);
                        break;
                    case GsInstructionType.RET:
                        if (tr.callDepth > 0)
                        {
                            tr.cp--;
                            tr.ip = tr.callStack[tr.cp]; // Pop the return address from the call stack
                            tr.callFrame = &tr.callFrames[tr.cp];
                            tr.callDepth--;
                        }
                        else
                        {
                            // Return from external call, halt execution
                            tr.yieldValue = tr.pop();
                            tr.finalize();
                        }
                        break;
                    case GsInstructionType.YIELD:
                        if (tr.callDepth > 0)
                        {
                            // Same as return
                            tr.cp--;
                            tr.ip = tr.callStack[tr.cp]; // Pop the return address from the call stack
                            tr.callFrame = &tr.callFrames[tr.cp];
                            tr.callDepth--;
                        }
                        else
                        {
                            // Yield a value and pause the thread
                            tr.yieldValue = tr.pop();
                            tr.pause();
                        }
                        break;
                    case GsInstructionType.STORE_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.callFrames[tr.cp].localVariables[vIndex] = tr.peek(); // Store a value into a local variable
                        break;
                    case GsInstructionType.LOAD_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.push(tr.callFrames[tr.cp].localVariables[vIndex]); // Load a local variable onto the stack
                        break;
                    case GsInstructionType.STORE_ARG:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.callFrames[tr.cp].parameters[vIndex] = tr.peek(); // Store a stack value into a parameter
                        break;
                    case GsInstructionType.LOAD_ARG:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.push(tr.callFrames[tr.cp].parameters[vIndex]); // Load a parameter onto the stack
                        break;
                    case GsInstructionType.LOAD_ARGS:
                        auto frame = &tr.callFrames[tr.cp];
                        tr.push(GsDynamic(frame.parameters[0..frame.numParameters])); // Load all parameters onto the stack
                        break;
                    case GsInstructionType.GLOBAL_STORE_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        mainThread.callFrames[0].localVariables[vIndex] = tr.peek(); // Store a value into a global variable
                        break;
                    case GsInstructionType.GLOBAL_LOAD_VAR:
                        size_t vIndex = cast(size_t)instruction.operand.asNumber;
                        tr.push(mainThread.callFrames[0].localVariables[vIndex]); // Load a global variable onto the stack
                        break;
                    case GsInstructionType.NEW:
                        auto obj = createObject();
                        tr.push(GsDynamic(obj));
                        break;
                    case GsInstructionType.REUSE:
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.Object)
                        {
                            auto newObj = createObject();
                            newObj.setPrototype(param.asObject);
                            tr.push(GsDynamic(newObj));
                        }
                        else
                        {
                            fatality("Fatality: attempting to reuse non-object");
                            return;
                        }
                        break;
                    case GsInstructionType.GET:
                        auto key = instruction.operand.asString;
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.Object)
                        {
                            tr.push(param.asObject.get(key));
                        }
                        else
                        {
                            fatality("Fatality: attempting to read member \"", key, "\" of non-object");
                            return;
                        }
                        break;
                    case GsInstructionType.SET:
                        auto key = instruction.operand.asString;
                        auto param = tr.pop();
                        auto value = tr.pop();
                        if (param.type == GsDynamicType.Object)
                        {
                            param.asObject.set(key, value);
                            tr.push(value);
                            break;
                        }
                        else
                        {
                            fatality("Fatality: attempting to write member \"", key, "\" of non-object");
                            return;
                        }
                        break;
                    case GsInstructionType.INIT_SET:
                        auto key = instruction.operand.asString;
                        auto value = tr.pop();
                        auto param = tr.peek();
                        if (param.type == GsDynamicType.Object)
                        {
                            param.asObject.set(key, value);
                            break;
                        }
                        else
                        {
                            fatality("Fatality: attempting to write member \"", key, "\" of non-object");
                            return;
                        }
                        break;
                    case GsInstructionType.CONTAINS:
                        auto key = instruction.operand.asString;
                        auto param = tr.pop();
                        if (param.type == GsDynamicType.Object)
                        {
                            tr.push(GsDynamic(param.asObject.contains(key)));
                        }
                        else
                        {
                            fatality("Fatality: attempting to read member \"", key, "\" of non-object");
                            return;
                        }
                        break;
                    case GsInstructionType.SPAWN:
                        size_t numParams = cast(size_t)instruction.operand.asNumber;
                        auto func = tr.pop();
                        if (func.type == GsDynamicType.String)
                        {
                            string jumpLabel = func.asString;
                            if (jumpLabel in jumpTable)
                            {
                                GsThread newThread = New!GsThread(this);
                                threads.append(newThread);
                                
                                // Add to linked list
                                if (tr.next)
                                    newThread.next = tr.next;
                                tr.next = newThread;
                                
                                auto cf = &newThread.callFrames[0];
                                cf.parameters[0] = GsDynamic(newThread);
                                for(size_t i = 0; i < numParams; i++)
                                {
                                    cf.parameters[1 + numParams - 1 - i] = tr.pop();
                                }
                                for(size_t pi = numParams + 1; pi < cf.parameters.length; pi++)
                                {
                                    cf.parameters[pi] = GsDynamic();
                                }
                                cf.numParameters = numParams + 1;
                                
                                newThread.start(jumpTable[jumpLabel], 0);
                                
                                tr.push(GsDynamic(newThread));
                            }
                            else
                            {
                                fatality("Fatality: unknown jump label %s", jumpLabel);
                                return;
                            }
                        }
                        else
                        {
                            fatality("Fatality: attempting to spawn %s, which is not a function", func.type);
                            return;
                        }
                        break;
                    case GsInstructionType.AWAIT:
                        auto param = tr.peek();
                        if (param.type == GsDynamicType.Object)
                        {
                            GsThread paramThread = cast(GsThread)param.asObject;
                            if (paramThread)
                            {
                                if (!paramThread.running || paramThread.paused)
                                {
                                    tr.waiting = false;
                                    tr.pop();
                                    tr.push(paramThread.yieldValue);
                                    if (paramThread.running)
                                        paramThread.paused = false;
                                }
                                else
                                {
                                    tr.waiting = true;
                                    tr.ip--;
                                }
                            }
                            else
                            {
                                fatality("Fatality: attempting to await non-thread object", param.type);
                                return;
                            }
                        }
                        else
                        {
                            fatality("Fatality: attempting to await %s, which is not a thread", param.type);
                            return;
                        }
                        break;
                    case GsInstructionType.SYNC:
                        auto param = tr.peek();
                        if (param.type == GsDynamicType.Object)
                        {
                            GsThread paramThread = cast(GsThread)param.asObject;
                            if (paramThread)
                            {
                                if (!paramThread.running || paramThread.paused)
                                {
                                    tr.waiting = false;
                                    tr.pop();
                                    tr.push(paramThread.yieldValue);
                                }
                                else
                                {
                                    tr.waiting = true;
                                    tr.ip--;
                                }
                            }
                            else
                            {
                                fatality("Fatality: attempting to sync non-thread object", param.type);
                                return;
                            }
                        }
                        else
                        {
                            fatality("Fatality: attempting to sync %s, which is not a thread", param.type);
                            return;
                        }
                        break;
                    case GsInstructionType.HALT:
                        tr.finalize();
                        break;
                    default:
                        fatality("Fatality: unknown instruction: ", instruction.type);
                        return;
                }
                
                tr = tr.next;
            }
            
            if (numActiveThreads == 0)
                running = false;
        }
    }
}

class GsThread: Owner, GsObject
{
  protected:
    GsVirtualMachine vm;
    GsObject data;
    GsDynamic[] stack;
    size_t[] callStack;            // Call stack for subroutine return addresses
    GsCallFrame[] callFrames;      // Stack of call frames
    size_t ip;                     // Instruction pointer
    size_t sp;                     // Stack pointer
    size_t cp;                     // Call stack pointer
    size_t callDepth = 1;
    
  public:
    GsCallFrame* callFrame;        // Current call frame
    bool running = false;
    bool paused = true;
    bool waiting = false;
    GsDynamic yieldValue;          //
    GsThread next = null;          // Linked list of threads
    
    this(GsVirtualMachine vm)
    {
        super(vm);
        
        this.vm = vm;
        
        data = vm.createObject();
        data.set("pause", GsDynamic(&bindPause));
        data.set("resume", GsDynamic(&bindResume));
        
        stack = New!(GsDynamic[])(256);
        callStack = New!(size_t[])(256);
        callFrames = New!(GsCallFrame[])(256);
        ip = 0;
        sp = 0;
        cp = 0;
        
        yieldValue = GsDynamic();
    }
    
    ~this()
    {
        Delete(stack);
        Delete(callStack);
        Delete(callFrames);
    }
    
    GsDynamic get(string key)
    {
        return data.get(key);
    }
    
    void set(string key, GsDynamic value)
    {
        return data.set(key, value);
    }
    
    bool contains(string key)
    {
        return data.contains(key);
    }
    
    void setPrototype(GsObject proto)
    {
        data.setPrototype(proto);
    }
    
    // Stack manipulation methods
    GsDynamic pop()
    {
        if (sp == 0)
        {
            vm.fatality("Fatality: stack underflow");
        }
        return stack[--sp];
    }

    GsDynamic peek()
    {
        if (sp == 0)
        {
            vm.fatality("Fatality: stack is empty");
        }
        return stack[sp - 1];
    }

    void push(GsDynamic value)
    {
        if (sp >= stack.length)
        {
            vm.fatality("Fatality: stack overflow");
        }
        stack[sp++] = value;
    }
    
    void pause()
    {
        if (running)
            paused = true;
    }
    
    void resume()
    {
        if (running)
            paused = false;
    }
    
    GsDynamic bindPause(GsDynamic[] args)
    {
        if (running)
            paused = true;
        return GsDynamic();
    }
    
    GsDynamic bindResume(GsDynamic[] args)
    {
        if (running)
            paused = false;
        return GsDynamic();
    }
    
    void finalize()
    {
        ip = vm.instructions.length - 1;
        running = false;
        paused = true;
        waiting = false;
        data.set("running", GsDynamic(0.0));
    }
    
    void start(size_t initialIp = 0, size_t initialCallDepth = 1)
    {
        ip = initialIp;
        sp = 0;
        cp = 0;
        callDepth = initialCallDepth;
        running = true;
        paused = false;
        waiting = false;
        data.set("running", GsDynamic(1.0));
        yieldValue = GsDynamic();
    }
}
