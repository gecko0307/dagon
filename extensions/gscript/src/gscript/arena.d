/*
Copyright (c) 2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/** 
 * General-purpose region-based memory allocator.
 *
 * Copyright: Timur Gafarov 2025.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module gscript.arena;

import std.traits;
import std.conv;
import std.meta;
import std.string;
import std.uni: isWhite;
import core.exception: onOutOfMemoryError;
import core.stdc.stdio;

import dlib.core.memory;
import dlib.core.ownership;
import dlib.container.array;

/// Represents a single memory block within the `Arena`.
struct GsArenaBuffer
{
    ubyte[] data;
    size_t offset;
}

/// Represents an allocation state of the `GsArenaBuffer`.
struct GsAllocationMark
{
    GsArenaBuffer* buffer;
    size_t offset;
    size_t size;
}

/**
 * Arena is an owned allocator that pre-allocates memory in large blocks
 * (buffers) and distributes it in chunks on demand.
 * It never frees its buffers; they are freed at once on Arena destruction.
 * The whole Arena can be reset and reused without freeing.
 * This allows for efficient memory management for many small objects,
 * such as strings.
 *
 * Arena supports:
 * - allocating class instances, structures, arrays and strings
 * - automatic memory alignment
 * - reusing already allocated memory
 * - creating marks and rolling back to them
 */
class GsArena: Owner
{
    protected:
    
    Array!GsArenaBuffer buffers;
    size_t currentBufferIndex;
    GsArenaBuffer* lastBuffer;
    size_t lastAllocationSize;
    
    public:
    
    Array!Object objects;
    
    /**
     * Constructor.
     *
     * Params:
     *   bufferSize = Initial buffer size.
     *   owner = Owner object.
     */
    this(size_t bufferSize, Owner owner = null)
    {
        super(owner);
        addBuffer(bufferSize);
        currentBufferIndex = 0;
        lastAllocationSize = 0;
        lastBuffer = null;
        objects.reserve(1024);
    }
    
    ~this()
    {
        release();
    }
    
    /// Resets arena for reuse.
    void reset()
    {
        if (objects.length)
        {
            // Call destructors
            foreach_reverse(obj; objects)
            {
                destroy(obj);
            }
            
            // Don't free the register, just reset its position
            objects.removeBack(cast(uint)objects.length);
        }
        
        foreach (ref buf; buffers)
            buf.offset = 0;
        currentBufferIndex = 0;
        lastAllocationSize = 0;
        lastBuffer = null;
    }
    
    /// Releases all allocated buffers.
    void release()
    {
        // Call destructors and free the register
        foreach_reverse(Object obj; this.objects)
        {
            destroy(obj);
        }
        objects.free();
        
        foreach(buf; buffers)
            Delete(buf.data);
        buffers.free();
        
        currentBufferIndex = 0;
        lastAllocationSize = 0;
        lastBuffer = null;
    }
    
    /**
     * Aligns the specified offset with the given alignment.
     *
     * Params:
     *   offset - The original offset.
     *   alignment - The desired alignment (power of two).
     *
     * Returns:
     *   The new offset, aligned with alignment.
     */
    size_t alignup(size_t offset, size_t alignment)
    {
        return (offset + alignment - 1) & ~(alignment - 1);
    }
    
    /**
     * Adds a new memory buffer.
     *
     * Params:
     *   size - The buffer size in bytes.
     *
     * Returns:
     *   A pointer to the created buffer.
     */
    protected GsArenaBuffer* addBuffer(size_t size)
    {
        if (size == 0)
            size = 1024;
        GsArenaBuffer buf = {
            data: New!(ubyte[])(size),
            offset: 0
        };
        buffers.append(buf);
        return &buffers.data[buffers.length - 1];
    }
    
    /**
     * Allocates a chunk memory in the arena.
     *
     * Params:
     *   size - Chunk size in bytes.
     *   alignment = 1 - Desired alignment.
     *
     * Returns:
     *   Slice of allocated memory.
     */
    ubyte[] allocate(size_t size, size_t alignment = 1)
    {
        // Fast path: allocate in the current buffer, if possible
        GsArenaBuffer* currentBuffer = &buffers.data[currentBufferIndex];
        size_t alignedOffset = alignup(currentBuffer.offset, alignment);
        if (alignedOffset + size <= currentBuffer.data.length)
        {
            ubyte[] res = currentBuffer.data[alignedOffset..alignedOffset+size];
            currentBuffer.offset = alignedOffset + size;
            lastBuffer = currentBuffer;
            lastAllocationSize = size;
            return res;
        }
        
        // Try to find an existing buffer with enough space
        foreach (i, ref buf; buffers.data)
        {
            alignedOffset = alignup(buf.offset, alignment);
            if (alignedOffset + size <= buf.data.length)
            {
                currentBufferIndex = i;
                ubyte[] res = buf.data[alignedOffset..alignedOffset+size];
                buf.offset = alignedOffset + size;
                lastBuffer = &buffers.data[i];
                lastAllocationSize = size;
                return res;
            }
        }
        
        // No suitable buffer found, allocate a new one
        currentBuffer = addBuffer(size);
        currentBufferIndex = buffers.length - 1;
        ubyte[] res = currentBuffer.data[0..size];
        currentBuffer.offset = size;
        lastBuffer = currentBuffer;
        lastAllocationSize = size;
        return res;
    }

    /// Shrinks the last allocation to a new size.
    /// Only allowed if newSize <= lastAllocationSize.
    void shrinkLastAllocation(size_t newSize)
    {
        if (newSize <= lastAllocationSize)
        {
            // Move the buffer offset back by the difference
            lastBuffer.offset -= (lastAllocationSize - newSize);
            lastAllocationSize = newSize;
        }
    }
    
    /**
     * Creates a mark for the last allocation.
     */
    GsAllocationMark mark()
    {
        return GsAllocationMark(lastBuffer, lastBuffer ? lastBuffer.offset : 0, lastAllocationSize);
    }
    
    /**
     * Rolls back to the specified mark, reclaiming a memory allocated in the buffer after the mark.
     * Use with caution: all objects created after the mark must be destroyed.
     */
    void rollback(GsAllocationMark m)
    {
        if (m.buffer !is null)
        {
            lastBuffer = m.buffer;
            lastBuffer.offset = m.offset;
        }
    }
    
    /**
     * Creates an object of class T in the arena.
     *
     * Params:
     *   args - Arguments to the T constructor.
     *
     * Returns:
     *   The created object of type T.
     */
    T create(T, A...) (A args) if (is(T == class))
    {
        enum size = __traits(classInstanceSize, T);
        ubyte* p = allocate(size + psize, T.alignof).ptr;
        if (!p)
            onOutOfMemoryError();
        auto memory = p[psize..psize+size];
        *cast(size_t*)p = size;
        T res = emplace!(T, A)(memory, args);
        objects.append(res);
        return res;
    }
    
    /**
     * Creates an instance of structure T in the arena.
     *
     * Params:
     *   args - structure constructor arguments.
     *
     * Returns:
     *   A pointer to the created structure instance.
     */
    T* create(T, A...) (A args) if (is(T == struct))
    {
        enum size = T.sizeof;
        ubyte* p = allocate(size + psize, T.alignof).ptr;
        if (!p)
            onOutOfMemoryError();
        auto memory = p[psize..psize+size];
        *cast(size_t*)p = size;
        return emplace!(T, A)(memory, args);
    }
    
    /**
     * Creates an array in the arena.
     *
     * Params:
     *   length - The length of the array.
     *
     * Returns:
     *   A new array of type T.
     */
    T create(T)(size_t length) if (isArray!T)
    {
        alias AT = ForeachType!T;
        size_t size = length * AT.sizeof;
        ubyte[] mem = allocate(size + psize, AT.alignof);
        if (!mem.length)
            onOutOfMemoryError();
        T arr = cast(T)mem[psize..psize+size];
        foreach(ref v; arr)
            v = v.init;
        *cast(size_t*)mem = size;
        return arr;
    }
    
    /**
     * Allocates space for a null-terminated array of characters of the specified length.
     *
     * Params:
     *   len - The length of the string (excluding the null-terminator).
     *
     * Returns:
     *   An array of characters.
     */
    char[] allocateString(size_t len)
    {
        char[] space = cast(char[])allocate(len + 1);
        space[len] = 0; // zero-terminate
        return space[0..len];
    }
    
    /**
     * Copies a string to the arena, appending a null-terminator for C compatibility.
     *
     * Params:
     *   str - The original string.
     *
     * Returns:
     *   The string stored in the arena.
     */
    string store(string str)
    {
        char[] space = allocateString(str.length);
        space[] = str[];
        return cast(string)space;
    }
}

T[] cat(T)(GsArena arena, T[] a, T[] b)
{
    T[] arr = arena.create!(T[])(a.length + b.length);
    arr[0..a.length] = a[];
    arr[a.length..$] = b[];
    return arr;
}

T[] cat(T)(GsArena arena, T[] a, T b)
{
    T[] arr = arena.create!(T[])(a.length + 1);
    arr[0..a.length] = a[];
    arr[a.length] = b;
    return arr;
}

T[] cat(T)(GsArena arena, T a, T[] b)
{
    T[] arr = arena.create!(T[])(b.length + 1);
    arr[1..b.length] = b[];
    arr[0] = a;
    return arr;
}

/**
 * Concatenates two strings and stores the result in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   a - First string.
 *   b - Second string.
 *
 * Returns:
 *   The concatenated string.
 */
string cat(GsArena arena, string a, string b)
{
    char[] space = arena.allocateString(a.length + b.length);
    space[0..a.length] = a[];
    space[a.length..$] = b[];
    return cast(string)space;
}

/**
 * Concatenates any number of strings and stores the result in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   args - Strings to concatenate.
 *
 * Returns:
 *   The concatenated string.
 */
string cat(Args...)(GsArena arena, Args args)
    if (Args.length > 0 && allSatisfy!(isSomeString, Args))
{
    size_t totalLen = 0;
    foreach (s; args)
        totalLen += s.length;
    char[] space = arena.allocateString(totalLen);
    size_t pos = 0;
    foreach (s; args)
    {
        space[pos .. pos + s.length] = s[];
        pos += s.length;
    }
    return cast(string)space;
}

/**
 * Formats a string using the given format string and arguments, storing the result in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   fmt - The format string.
 *   args - Arguments to format.
 *
 * Returns:
 *   The formatted string stored in the arena.
 */
string format(T...)(GsArena arena, string fmt, T args)
{
    // Estimate the required size
    size_t size = 256;
    while (true)
    {
        char[] space = arena.allocateString(size);
        auto written = snprintf(space.ptr, space.length, fmt.ptr, args);
        if (written < 0)
            onOutOfMemoryError();
        if (cast(size_t)written < space.length)
        {
            // Successfully formatted, shrink to actual size, including null-terminator
            arena.shrinkLastAllocation(cast(size_t)written + 1);

            // Return the formatted string
            return cast(string)space[0..cast(size_t)written];
        }
        else
        {
            // Not enough space, try again with a larger buffer
            size = cast(size_t)written + 1;

            // Rollback the buffer
            arena.shrinkLastAllocation(0);
        }
    }
    
    // Should never get here
    return "";
}

/**
 * Splits a string by the specified delimiter and stores the parts in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   str - The original string.
 *   delimiter - The delimiter character.
 *
 * Returns:
 *   An array of strings.
 */
string[] split(GsArena arena, string str, char delimiter)
{
    size_t count = 1;
    foreach (c; str)
        if (c == delimiter)
            count++;

    auto result = arena.create!(string[])(count);

    size_t index = 0;
    size_t start = 0;
    size_t numChars = 0;
    for (size_t i = 0; i < str.length; i++)
    {
        if (str[i] == delimiter && numChars > 0)
        {
            string part = arena.store(str[start..start+numChars]);
            result[index++] = part;
            start = i + 1;
            numChars = 0;
        }
        else
            numChars++;
    }
    
    if (numChars > 0)
    {
        string part = arena.store(str[start..start+numChars]);
        result[index++] = part;
    }

    return result;
}

/**
 * Joins an array of strings with the specified separator and stores the result in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   parts - The array of strings to join.
 *   sep - The separator string.
 *
 * Returns:
 *   The joined string.
 */
string join(GsArena arena, string[] parts, string sep)
{
    if (parts.length == 0) return "";
    size_t totalLen = (parts.length - 1) * sep.length;
    foreach (p; parts)
        totalLen += p.length;
    char[] buf = arena.allocateString(totalLen);
    size_t pos = 0;
    foreach (i, p; parts)
    {
        if (i > 0)
        {
            buf[pos..pos+sep.length] = sep[];
            pos += sep.length;
        }
        buf[pos..pos+p.length] = p[];
        pos += p.length;
    }
    return cast(string)buf;
}

/**
 * Replaces all occurrences of a substring with another substring in the given string,
 * storing the result in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   str - The original string.
 *   strFrom - The substring to replace.
 *   strTo - The replacement substring.
 *
 * Returns:
 *   The modified string with replacements.
 */
string replace(GsArena arena, string str, string strFrom, string strTo)
{
    if (strFrom.length == 0) return arena.store(str);
    size_t count = 0, pos = 0;
    while ((pos = str.indexOf(strFrom, pos)) != -1)
    {
        ++count;
        pos += strFrom.length;
    }
    if (count == 0)
        return arena.store(str);

    size_t newLen = str.length + count * (strTo.length - strFrom.length);
    char[] buf = arena.allocateString(newLen);
    size_t src = 0, dst = 0;
    while (src < str.length)
    {
        auto idx = str.indexOf(strFrom, src);
        if (idx == -1)
        {
            buf[dst..dst+str.length-src] = str[src..$];
            break;
        }
        buf[dst..dst+idx-src] = str[src..idx];
        dst += idx - src;
        buf[dst..dst+strTo.length] = strTo[];
        dst += strTo.length;
        src = idx + strFrom.length;
    }
    return cast(string)buf;
}

/**
 * Trims whitespace from both ends of the string and stores the result in the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   s - The original string.
 *
 * Returns:
 *   The trimmed string.
 */
string trim(GsArena arena, string s)
{
    size_t start = 0, end = s.length;
    while (start < end && isWhite(s[start])) ++start;
    while (end > start && isWhite(s[end-1])) --end;
    return arena.store(s[start .. end]);
}

/**
 * Duplicates an array into the arena.
 *
 * Params:
 *   arena - The memory arena.
 *   arr - The original array.
 *
 * Returns:
 *   A copy of the array stored in the arena.
 */
T[] dup(T)(GsArena arena, const(T)[] arr)
{
    auto copy = arena.create!(T[])(arr.length);
    copy[] = arr[];
    return copy;
}

/**
 * Duplicates an array into the arena as an immutable array.
 *
 * Params:
 *   arena - The memory arena.
 *   arr - The original array.
 *
 * Returns:
 *   An immutable copy of the array stored in the arena.
 */
immutable(T)[] idup(T)(GsArena arena, const(T)[] arr)
{
    return cast(immutable(T)[])dup(arena, arr);
}
